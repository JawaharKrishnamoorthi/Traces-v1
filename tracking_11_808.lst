CCS PCD C Compiler, Version 5.074d, 1               07-Aug-17 11:41
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   F:\products\gps tracker\traces\Traces-v1\tracking_11_808.lst

               ROM used:   14444 bytes (33%)
                           Largest free fragment is 29584
               RAM used:   961 (12%) at main() level
                           1389 (17%) worst case
               Stack used: 52 locations (2 in main + 50 for interrupts)
               Stack size: 256

*
0000:  GOTO    33F0
*
0008:  DATA    8E,33,00
*
002A:  DATA    32,33,00
*
003A:  DATA    AE,33,00
....................  
.................... #include <24fj64ga002.h> 
.................... //////////// Standard Header file for the PIC24FJ64GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ64GA002 
*
0200:  CLR     32
0202:  MOV     #20C,W3
0204:  ADD     W3,W0,W0
0206:  TBLRDL.B[W0],W0L
0208:  CLR.B   1
020A:  RETURN  
020C:  DATA    41,54,00
020E:  DATA    45,30,00
0210:  DATA    25,63,00
0212:  DATA    00,00,00
0214:  CLR     32
0216:  MOV     #220,W3
0218:  ADD     W3,W0,W0
021A:  TBLRDL.B[W0],W0L
021C:  CLR.B   1
021E:  RETURN  
0220:  DATA    41,54,00
0222:  DATA    2B,43,00
0224:  DATA    47,52,00
0226:  DATA    45,47,00
0228:  DATA    3F,25,00
022A:  DATA    63,00,00
022C:  CLR     32
022E:  MOV     #238,W3
0230:  ADD     W3,W0,W0
0232:  TBLRDL.B[W0],W0L
0234:  CLR.B   1
0236:  RETURN  
0238:  DATA    41,54,00
023A:  DATA    2B,47,00
023C:  DATA    50,53,00
023E:  DATA    3D,31,00
0240:  DATA    0A,0D,00
0242:  DATA    00,00,00
0244:  CLR     32
0246:  MOV     #250,W3
0248:  ADD     W3,W0,W0
024A:  TBLRDL.B[W0],W0L
024C:  CLR.B   1
024E:  RETURN  
0250:  DATA    41,54,00
0252:  DATA    2B,43,00
0254:  DATA    47,4E,00
0256:  DATA    53,50,00
0258:  DATA    57,52,00
025A:  DATA    3D,31,00
025C:  DATA    25,63,00
025E:  DATA    00,00,00
0260:  CLR     32
0262:  MOV     #26C,W3
0264:  ADD     W3,W0,W0
0266:  TBLRDL.B[W0],W0L
0268:  CLR.B   1
026A:  RETURN  
026C:  DATA    41,54,00
026E:  DATA    2B,45,00
0270:  DATA    43,48,00
0272:  DATA    41,52,00
0274:  DATA    47,45,00
0276:  DATA    3D,31,00
0278:  DATA    0A,0D,00
027A:  DATA    00,00,00
027C:  CLR     32
027E:  MOV     #288,W3
0280:  ADD     W3,W0,W0
0282:  TBLRDL.B[W0],W0L
0284:  CLR.B   1
0286:  RETURN  
0288:  DATA    41,54,00
028A:  DATA    2B,45,00
028C:  DATA    43,48,00
028E:  DATA    41,52,00
0290:  DATA    47,45,00
0292:  DATA    3D,31,00
0294:  DATA    25,63,00
0296:  DATA    00,00,00
0298:  CLR     32
029A:  MOV     #2A4,W3
029C:  ADD     W3,W0,W0
029E:  TBLRDL.B[W0],W0L
02A0:  CLR.B   1
02A2:  RETURN  
02A4:  DATA    41,54,00
02A6:  DATA    2B,52,00
02A8:  DATA    47,50,00
02AA:  DATA    53,3D,00
02AC:  DATA    31,0A,00
02AE:  DATA    0D,00,00
02B0:  CLR     32
02B2:  MOV     #2BC,W3
02B4:  ADD     W3,W0,W0
02B6:  TBLRDL.B[W0],W0L
02B8:  CLR.B   1
02BA:  RETURN  
02BC:  DATA    41,54,00
02BE:  DATA    2B,43,00
02C0:  DATA    47,4E,00
02C2:  DATA    53,52,00
02C4:  DATA    53,54,00
02C6:  DATA    3D,30,00
02C8:  DATA    25,63,00
02CA:  DATA    00,00,00
02CC:  CLR     32
02CE:  MOV     #2D8,W3
02D0:  ADD     W3,W0,W0
02D2:  TBLRDL.B[W0],W0L
02D4:  CLR.B   1
02D6:  RETURN  
02D8:  DATA    43,41,00
02DA:  DATA    53,45,00
02DC:  DATA    2D,25,00
02DE:  DATA    75,0A,00
02E0:  DATA    0D,00,00
02E2:  CLR     32
02E4:  MOV     #22,W3
02E6:  SUB     W0,W3,W3
02E8:  BRA     C,2F4
02EA:  MOV     #2FE,W3
02EC:  ADD     W3,W0,W0
02EE:  TBLRDL.B[W0],W0L
02F0:  CLR.B   1
02F2:  RETURN  
02F4:  MOV     #2FE,W0
02F6:  ADD     W3,W3,W3
02F8:  ADD     W3,W0,W3
02FA:  TBLRDH  [W3],W0
02FC:  RETURN  
02FE:  DATA    41,54,73
0300:  DATA    2B,43,2E
0302:  DATA    49,50,63
0304:  DATA    53,54,6F
0306:  DATA    41,52,6D
0308:  DATA    54,3D,25
030A:  DATA    25,63,63
030C:  DATA    54,43,2C
030E:  DATA    50,25,25
0310:  DATA    63,2C,63
0312:  DATA    25,63,38
0314:  DATA    77,77,30
0316:  DATA    77,2E,25
0318:  DATA    67,70,63
031A:  DATA    73,74,25
031C:  DATA    72,61,63
031E:  DATA    63,65,00
0320:  CLR     32
0322:  MOV     #32C,W3
0324:  ADD     W3,W0,W0
0326:  TBLRDL.B[W0],W0L
0328:  CLR.B   1
032A:  RETURN  
032C:  DATA    41,54,00
032E:  DATA    2B,43,00
0330:  DATA    49,50,00
0332:  DATA    53,45,00
0334:  DATA    4E,44,00
0336:  DATA    00,00,00
0338:  CLR     32
033A:  MOV     #24,W3
033C:  SUB     W0,W3,W3
033E:  BRA     C,34A
0340:  MOV     #354,W3
0342:  ADD     W3,W0,W0
0344:  TBLRDL.B[W0],W0L
0346:  CLR.B   1
0348:  RETURN  
034A:  MOV     #354,W0
034C:  ADD     W3,W3,W3
034E:  ADD     W3,W0,W3
0350:  TBLRDH  [W3],W0
0352:  RETURN  
0354:  DATA    47,45,36
0356:  DATA    54,20,35
0358:  DATA    68,74,30
035A:  DATA    74,70,36
035C:  DATA    3A,2F,37
035E:  DATA    2F,77,30
0360:  DATA    77,77,32
0362:  DATA    2E,67,32
0364:  DATA    70,73,34
0366:  DATA    74,72,33
0368:  DATA    61,63,35
036A:  DATA    65,73,37
036C:  DATA    2E,63,30
036E:  DATA    6F,6D,38
0370:  DATA    2F,75,26
0372:  DATA    2F,75,00
0374:  DATA    3F,69,00
0376:  DATA    3D,38,00
0378:  CLR     32
037A:  MOV     #384,W3
037C:  ADD     W3,W0,W0
037E:  TBLRDL.B[W0],W0L
0380:  CLR.B   1
0382:  RETURN  
0384:  DATA    41,54,00
0386:  DATA    2B,43,00
0388:  DATA    49,50,00
038A:  DATA    43,4C,00
038C:  DATA    4F,53,00
038E:  DATA    45,00,00
0390:  CLR     32
0392:  MOV     #39C,W3
0394:  ADD     W3,W0,W0
0396:  TBLRDL.B[W0],W0L
0398:  CLR.B   1
039A:  RETURN  
039C:  DATA    2D,54,00
039E:  DATA    41,53,00
03A0:  DATA    4B,31,00
03A2:  DATA    2D,0A,00
03A4:  DATA    0D,00,00
03A6:  CLR     32
03A8:  MOV     #3B2,W3
03AA:  ADD     W3,W0,W0
03AC:  TBLRDL.B[W0],W0L
03AE:  CLR.B   1
03B0:  RETURN  
03B2:  DATA    41,43,00
03B4:  DATA    4B,2D,00
03B6:  DATA    25,75,00
03B8:  DATA    0A,0D,00
03BA:  DATA    00,00,00
03BC:  CLR     32
03BE:  MOV     #3C8,W3
03C0:  ADD     W3,W0,W0
03C2:  TBLRDL.B[W0],W0L
03C4:  CLR.B   1
03C6:  RETURN  
03C8:  DATA    41,54,00
03CA:  DATA    2B,43,00
03CC:  DATA    47,4E,00
03CE:  DATA    53,49,00
03D0:  DATA    4E,46,00
03D2:  DATA    25,63,00
03D4:  DATA    00,00,00
03D6:  CLR     32
03D8:  MOV     #3E2,W3
03DA:  ADD     W3,W0,W0
03DC:  TBLRDL.B[W0],W0L
03DE:  CLR.B   1
03E0:  RETURN  
03E2:  DATA    54,4F,00
03E4:  DATA    0D,0A,00
03E6:  DATA    00,00,00
03E8:  CLR     32
03EA:  MOV     #3F4,W3
03EC:  ADD     W3,W0,W0
03EE:  TBLRDL.B[W0],W0L
03F0:  CLR.B   1
03F2:  RETURN  
03F4:  DATA    53,74,00
03F6:  DATA    61,67,00
03F8:  DATA    65,20,00
03FA:  DATA    31,0A,00
03FC:  DATA    0D,00,00
03FE:  CLR     32
0400:  MOV     #40A,W3
0402:  ADD     W3,W0,W0
0404:  TBLRDL.B[W0],W0L
0406:  CLR.B   1
0408:  RETURN  
040A:  DATA    53,74,00
040C:  DATA    61,67,00
040E:  DATA    65,20,00
0410:  DATA    32,0A,00
0412:  DATA    0D,00,00
0414:  CLR     32
0416:  MOV     #420,W3
0418:  ADD     W3,W0,W0
041A:  TBLRDL.B[W0],W0L
041C:  CLR.B   1
041E:  RETURN  
0420:  DATA    53,74,00
0422:  DATA    61,67,00
0424:  DATA    65,20,00
0426:  DATA    33,0A,00
0428:  DATA    0D,00,00
042A:  CLR     32
042C:  MOV     #436,W3
042E:  ADD     W3,W0,W0
0430:  TBLRDL.B[W0],W0L
0432:  CLR.B   1
0434:  RETURN  
0436:  DATA    42,4F,00
0438:  DATA    4F,54,00
043A:  DATA    20,31,00
043C:  DATA    0A,0D,00
043E:  DATA    00,00,00
0440:  CLR     32
0442:  MOV     #44C,W3
0444:  ADD     W3,W0,W0
0446:  TBLRDL.B[W0],W0L
0448:  CLR.B   1
044A:  RETURN  
044C:  DATA    42,4F,00
044E:  DATA    4F,54,00
0450:  DATA    20,32,00
0452:  DATA    0A,0D,00
0454:  DATA    00,00,00
0456:  CLR     32
0458:  MOV     #462,W3
045A:  ADD     W3,W0,W0
045C:  TBLRDL.B[W0],W0L
045E:  CLR.B   1
0460:  RETURN  
0462:  DATA    42,4F,00
0464:  DATA    4F,54,00
0466:  DATA    20,33,00
0468:  DATA    0A,0D,00
046A:  DATA    00,00,00
046C:  CLR     32
046E:  MOV     #478,W3
0470:  ADD     W3,W0,W0
0472:  TBLRDL.B[W0],W0L
0474:  CLR.B   1
0476:  RETURN  
0478:  DATA    42,4F,00
047A:  DATA    4F,54,00
047C:  DATA    20,34,00
047E:  DATA    0A,0D,00
0480:  DATA    00,00,00
0482:  CLR     32
0484:  MOV     #48E,W3
0486:  ADD     W3,W0,W0
0488:  TBLRDL.B[W0],W0L
048A:  CLR.B   1
048C:  RETURN  
048E:  DATA    42,4F,00
0490:  DATA    4F,54,00
0492:  DATA    20,35,00
0494:  DATA    0A,0D,00
0496:  DATA    00,00,00
0498:  CLR     32
049A:  MOV     #4A4,W3
049C:  ADD     W3,W0,W0
049E:  TBLRDL.B[W0],W0L
04A0:  CLR.B   1
04A2:  RETURN  
04A4:  DATA    42,4F,00
04A6:  DATA    4F,54,00
04A8:  DATA    20,36,00
04AA:  DATA    0A,0D,00
04AC:  DATA    00,00,00
04AE:  CLR     32
04B0:  MOV     #4BA,W3
04B2:  ADD     W3,W0,W0
04B4:  TBLRDL.B[W0],W0L
04B6:  CLR.B   1
04B8:  RETURN  
04BA:  DATA    54,0A,00
04BC:  DATA    66,0A,00
04BE:  DATA    78,0A,00
04C0:  DATA    8A,0A,00
04C2:  DATA    9C,0A,00
04C4:  DATA    AE,0A,00
04C6:  CLR     32
04C8:  MOV     #4D2,W3
04CA:  ADD     W3,W0,W0
04CC:  TBLRDL.B[W0],W0L
04CE:  CLR.B   1
04D0:  RETURN  
04D2:  DATA    2C,00,00
*
050C:  MOV     W5,[W15++]
050E:  MOV     #C,W5
0510:  REPEAT  #3
0512:  MOV     [W5++],[W15++]
0514:  MOV     W0,W7
0516:  MOV     W4,W9
0518:  BCLR    W4.F
051A:  CP0     W4
051C:  BRA     NZ,52A
051E:  BTSC    W9.F
0520:  BRA     526
0522:  MOV     #0,W5
0524:  BRA     548
0526:  MOV     #0,W5
0528:  BRA     548
052A:  SUB.B   W4L,#6,W5L
052C:  BRA     NC,546
052E:  MOV     #30,W0
0530:  BTSS    W9.F
0532:  MOV     #20,W0
0534:  MOV     W0,[W15++]
0536:  BTSC.B  223.1
0538:  BRA     536
053A:  MOV     W0,224
053C:  MOV     [--W15],W0
053E:  DEC     W5,W5
0540:  BRA     NN,534
0542:  MOV     #5,W5
0544:  BRA     548
0546:  MOV     W4,W5
0548:  MOV     #6,W4
054A:  BSET    W5.E
054C:  BTSC    W9.F
054E:  BSET    W5.F
0550:  MOV     #2710,W8
0552:  REPEAT  #11
0554:  DIV.U   W7,W8
0556:  CALL    58A
055A:  MOV     W1,W7
055C:  MOV     #3E8,W8
055E:  REPEAT  #11
0560:  DIV.U   W7,W8
0562:  CALL    58A
0566:  MOV     W1,W7
0568:  MOV     #64,W8
056A:  REPEAT  #11
056C:  DIV.U   W7,W8
056E:  CALL    58A
0572:  MOV     W1,W7
0574:  MOV     #A,W8
0576:  REPEAT  #11
0578:  DIV.U   W7,W8
057A:  CALL    58A
057E:  MOV     #30,W0
0580:  ADD.B   W1L,W0L,W0L
0582:  BTSC.B  223.1
0584:  BRA     582
0586:  MOV     W0,224
0588:  BRA     5B8
058A:  MOV     #30,W6
058C:  CP0     W0
058E:  BRA     NZ,5AC
0590:  BTSS    W5.E
0592:  BRA     5AE
0594:  DEC     W4,W4
0596:  CP.B    W4L,W5L
0598:  BRA     Z,59E
059A:  BTSC.B  42.0
059C:  RETURN  
059E:  CP0     W0
05A0:  BRA     NZ,5AC
05A2:  BTSS    W5.E
05A4:  BRA     5AE
05A6:  BTSS    W5.F
05A8:  MOV     #20,W6
05AA:  BRA     5AE
05AC:  BCLR    W5.E
05AE:  ADD.B   W6L,W0L,W0L
05B0:  BTSC.B  223.1
05B2:  BRA     5B0
05B4:  MOV     W0,224
05B6:  RETURN  
05B8:  MOV     #12,W5
05BA:  REPEAT  #3
05BC:  MOV     [--W15],[W5--]
05BE:  MOV     [--W15],W5
05C0:  RETURN  
*
0B5C:  MOV     W6,[W15++]
0B5E:  MOV     #E,W6
0B60:  REPEAT  #6
0B62:  MOV     [W6++],[W15++]
0B64:  MOV     W2,W6
0B66:  MOV     W5,W7
0B68:  BCLR.B  42.0
0B6A:  BCLR.B  42.1
0B6C:  RLC     W2,W2
0B6E:  SWAP    W2
0B70:  AND     #FF,W2
0B72:  CP0     W2
0B74:  BRA     Z,C1A
0B76:  BCLR.B  42.0
0B78:  BCLR.B  42.1
0B7A:  RLC     W5,W5
0B7C:  SWAP    W5
0B7E:  AND     #FF,W5
0B80:  CP0     W5
0B82:  BRA     Z,C1A
0B84:  ADD.B   W2L,W5L,W5L
0B86:  BRA     C,B90
0B88:  SUB     #7F,W5
0B8A:  BRA     Z,C1A
0B8C:  BRA     NC,C1A
0B8E:  BRA     B94
0B90:  ADD.B   #81,W5L
0B92:  BRA     C,C1A
0B94:  XOR     W6,W7,W2
0B96:  BCLR.B  42.0
0B98:  BCLR.B  42.1
0B9A:  AND     #FF,W6
0B9C:  BSET    W6.7
0B9E:  CLR     0
0BA0:  AND     #FF,W7
0BA2:  BSET    W7.7
0BA4:  MUL.UU  W3,W0,W8
0BA6:  MUL.UU  W3,W1,W10
0BA8:  ADDC    W9,W10,W10
0BAA:  ADDC    #0,W11
0BAC:  MUL.UU  W3,W6,W8
0BAE:  ADD     W8,W11,W11
0BB0:  MOV     W9,W12
0BB2:  MUL.UU  W4,W0,W8
0BB4:  ADD     W8,W10,W10
0BB6:  ADDC    W9,W11,W11
0BB8:  MUL.UU  W4,W1,W8
0BBA:  ADD     W8,W11,W11
0BBC:  ADDC    W9,W12,W12
0BBE:  MUL.UU  W4,W6,W8
0BC0:  ADD     W8,W12,W12
0BC2:  ADDC    #0,W9
0BC4:  MOV     W9,W13
0BC6:  MUL.UU  W7,W0,W8
0BC8:  ADD     W8,W11,W11
0BCA:  ADDC    W9,W12,W12
0BCC:  MUL.UU  W7,W1,W8
0BCE:  ADD     W8,W12,W12
0BD0:  ADDC    W9,W13,W13
0BD2:  MUL.UU  W7,W6,W8
0BD4:  ADD     W8,W13,W13
0BD6:  MOV     W2,W8
0BD8:  INC     W5,W2
0BDA:  CLR     W0
0BDC:  CLR     W1
0BDE:  IOR      W13,  W12,W6
0BE0:  BRA     Z,BE4
0BE2:  BRA     BE8
0BE4:  IOR      W11,  W10,W6
0BE6:  BRA     Z,BF4
0BE8:  BTSC    W13.F
0BEA:  BRA     BF4
0BEC:  RLC     W11,W11
0BEE:  RLC     W12,W12
0BF0:  RLC     W13,W13
0BF2:  DEC     W2,W2
0BF4:  BCLR    W13.F
0BF6:  SWAP    W2
0BF8:  BCLR.B  42.0
0BFA:  BCLR.B  42.1
0BFC:  RRC     W2,W2
0BFE:  BCLR    W2.F
0C00:  BTSC    W8.F
0C02:  BSET    W2.F
0C04:  MOV.B   W13L,W1L
0C06:  SWAP    W13
0C08:  SWAP    W1
0C0A:  XOR.B   W13L,W2L,W2L
0C0C:  MOV.B   W12L,W0L
0C0E:  SWAP    W0
0C10:  SWAP    W12
0C12:  MOV.B   W12L,W1L
0C14:  SWAP    W11
0C16:  MOV.B   W11L,W0L
0C18:  BRA     C20
0C1A:  MUL.UU  W0,#0,W0
0C1C:  MOV     #0,W2
0C1E:  BRA     C20
0C20:  MOV     #1A,W6
0C22:  REPEAT  #6
0C24:  MOV     [--W15],[W6--]
0C26:  MOV     [--W15],W6
0C28:  RETURN  
0C2A:  MOV     W5,[W15++]
0C2C:  MOV     #C,W5
0C2E:  REPEAT  #3
0C30:  MOV     [W5++],[W15++]
0C32:  MOV     W0,W4
0C34:  MOV     W1,W5
0C36:  MOV     W2,W6
0C38:  MOV     W3,W7
0C3A:  CLR     W0
0C3C:  CLR     W1
0C3E:  CLR     W2
0C40:  CLR     W3
0C42:  BCLR    W10.0
0C44:  BTSS    W7.F
0C46:  BRA     C58
0C48:  BSET    W10.0
0C4A:  COM     W7,W7
0C4C:  COM     W6,W6
0C4E:  COM     W5,W5
0C50:  NEG     W4,W4
0C52:  ADDC    W5,#0,W5
0C54:  ADDC    W6,#0,W6
0C56:  ADDC    W7,#0,W7
0C58:  IOR      W4,  W5,W9
0C5A:  BRA     NZ,C60
0C5C:  IOR      W6,  W7,W9
0C5E:  BRA     Z,C8A
0C60:  MOV     #E6,W9
0C62:  BTSC    W2.7
0C64:  BRA     C7A
0C66:  BCLR.B  42.0
0C68:  RLC     W4,W4
0C6A:  RLC     W5,W5
0C6C:  RLC     W6,W6
0C6E:  RLC     W7,W7
0C70:  RLC     W0,W0
0C72:  RLC     W1,W1
0C74:  RLC     W2,W2
0C76:  DEC     W9,W9
0C78:  BRA     NZ,C62
0C7A:  SWAP    W9
0C7C:  BCLR.B  42.0
0C7E:  RRC     W9,W9
0C80:  BCLR    W9.F
0C82:  BCLR    W2.7
0C84:  XOR     W9,W2,W2
0C86:  BTSC    W10.0
0C88:  BSET    W2.F
0C8A:  MOV     #12,W5
0C8C:  REPEAT  #3
0C8E:  MOV     [--W15],[W5--]
0C90:  MOV     [--W15],W5
0C92:  RETURN  
0C94:  MOV     W6,[W15++]
0C96:  MOV     #E,W6
0C98:  REPEAT  #6
0C9A:  MOV     [W6++],[W15++]
0C9C:  XOR     W2,W5,W9
0C9E:  MOV     W2,W6
0CA0:  MOV     W5,W7
0CA2:  RLC     W6,W6
0CA4:  SWAP    W6
0CA6:  ZE      W6,W6
0CA8:  CP0     W6
0CAA:  BRA     Z,D5A
0CAC:  RLC     W7,W7
0CAE:  SWAP    W7
0CB0:  ZE      W7,W7
0CB2:  CP0     W7
0CB4:  BRA     Z,D5A
0CB6:  CLR     W10
0CB8:  SUB.B   W6L,W7L,W10L
0CBA:  BRA     NC,CC2
0CBC:  ADD.B   #7F,W10L
0CBE:  BRA     C,D5A
0CC0:  BRA     CC8
0CC2:  SUB.B   #81,W10L
0CC4:  BRA     NC,D5A
0CC6:  BRA     Z,D5A
0CC8:  CLR     W6
0CCA:  CLR     W7
0CCC:  CLR     W8
0CCE:  AND     #FF,W2
0CD0:  BSET    W2.7
0CD2:  AND     #FF,W5
0CD4:  BSET    W5.7
0CD6:  MOV     #29,W11
0CD8:  SUB     W0,W3,W0
0CDA:  SUBB    W1,W4,W1
0CDC:  SUBB    W2,W5,W2
0CDE:  BRA     N,CE4
0CE0:  BRA     C,CEC
0CE2:  BRA     NZ,CEE
0CE4:  ADD     W0,W3,W0
0CE6:  ADDC    W1,W4,W1
0CE8:  ADDC    W2,W5,W2
0CEA:  BRA     CEE
0CEC:  BSET    W6.0
0CEE:  DEC     W11,W11
0CF0:  BRA     Z,D04
0CF2:  BCLR.B  42.0
0CF4:  RLC     W0,W0
0CF6:  RLC     W1,W1
0CF8:  RLC     W2,W2
0CFA:  BCLR.B  42.0
0CFC:  RLC     W6,W6
0CFE:  RLC     W7,W7
0D00:  RLC     W8,W8
0D02:  BRA     CD8
0D04:  BTSC    W8.8
0D06:  BRA     D0A
0D08:  BRA     D40
0D0A:  BCLR.B  42.0
0D0C:  RRC     W8,W8
0D0E:  BCLR    W8.7
0D10:  RRC     W7,W7
0D12:  RRC     W6,W6
0D14:  RRC     W11,W11
0D16:  BRA     D1C
0D18:  DEC     W10,W10
0D1A:  BRA     Z,D5A
0D1C:  BTSC    W11.F
0D1E:  BRA     D2E
0D20:  RLC     W0,W0
0D22:  RLC     W1,W1
0D24:  RLC     W2,W2
0D26:  SUB     W0,W3,W3
0D28:  SUBB    W1,W4,W4
0D2A:  SUBB    W2,W5,W5
0D2C:  BRA     NC,D44
0D2E:  INC     W6,W6
0D30:  BRA     NZ,D44
0D32:  INC     W7,W7
0D34:  BRA     NZ,D44
0D36:  INC     W8,W8
0D38:  BRA     NZ,D44
0D3A:  INC     W10,W10
0D3C:  BRA     Z,D5A
0D3E:  BRA     D44
0D40:  DEC     W10,W10
0D42:  BRA     Z,D5A
0D44:  SWAP    W10
0D46:  BCLR.B  42.0
0D48:  RRC     W10,W2
0D4A:  BSET    W2.F
0D4C:  BTSS    W9.F
0D4E:  BCLR    W2.F
0D50:  BCLR    W8.7
0D52:  XOR.B   W8L,W2L,W2L
0D54:  MOV     W7,W1
0D56:  MOV     W6,W0
0D58:  BRA     D60
0D5A:  MUL.UU  W0,#0,W0
0D5C:  MOV     #0,W2
0D5E:  BRA     D60
0D60:  MOV     #1A,W6
0D62:  REPEAT  #6
0D64:  MOV     [--W15],[W6--]
0D66:  MOV     [--W15],W6
0D68:  RETURN  
0D6A:  MOV     W6,[W15++]
0D6C:  MOV     #E,W6
0D6E:  REPEAT  #6
0D70:  MOV     [W6++],[W15++]
0D72:  CLR     W9
0D74:  MOV     #8000,W8
0D76:  BTSC.B  43.0
0D78:  XOR     W8,W5,W5
0D7A:  CP0     W0
0D7C:  BRA     NZ,D88
0D7E:  CP0     W1
0D80:  BRA     NZ,D88
0D82:  MOV     #7FFF,W10
0D84:  AND     W2,W10,W10
0D86:  BTSS.B  42.1
0D88:  MOV     W2,W10
0D8A:  XOR     W5,W10,W11
0D8C:  MOV     W2,W6
0D8E:  MOV     W5,W7
0D90:  MOV     W5,W12
0D92:  BCLR.B  42.1
0D94:  BCLR.B  42.0
0D96:  RLC     W6,W6
0D98:  SWAP    W6
0D9A:  AND     #FF,W6
0D9C:  CP0     W6
0D9E:  BRA     Z,F0E
0DA0:  BCLR.B  42.1
0DA2:  BCLR.B  42.0
0DA4:  RLC     W7,W7
0DA6:  SWAP    W7
0DA8:  AND     #FF,W7
0DAA:  CP0     W7
0DAC:  BRA     Z,F1A
0DAE:  BCLR.B  42.1
0DB0:  BCLR.B  42.0
0DB2:  CP      W7,W6
0DB4:  BRA     Z,F1C
0DB6:  BRA     N,F2C
0DB8:  BCLR    W9.0
0DBA:  BSET    W9.1
0DBC:  SUB     W7,W6,W8
0DBE:  MOV     W7,W6
0DC0:  AND     #FF,W2
0DC2:  BSET    W2.7
0DC4:  AND     #FF,W5
0DC6:  BSET    W5.7
0DC8:  MOV     #28,W7
0DCA:  CP      W7,W8
0DCC:  BRA     N,DF4
0DCE:  BCLR.B  42.1
0DD0:  BCLR.B  42.0
0DD2:  RRC     W2,W2
0DD4:  RRC     W1,W1
0DD6:  RRC     W0,W0
0DD8:  DEC     W8,W8
0DDA:  BRA     NZ,DCE
0DDC:  BRA     E02
0DDE:  MOV     #28,W7
0DE0:  CP      W7,W8
0DE2:  BRA     N,DFC
0DE4:  BCLR.B  42.1
0DE6:  BCLR.B  42.0
0DE8:  RRC     W5,W5
0DEA:  RRC     W4,W4
0DEC:  RRC     W3,W3
0DEE:  DEC     W8,W8
0DF0:  BRA     NZ,DE4
0DF2:  BRA     E20
0DF4:  MOV     W3,W0
0DF6:  MOV     W4,W1
0DF8:  MOV     W5,W2
0DFA:  XOR     W11,W12,W12
0DFC:  BTSC    W12.F
0DFE:  BTG     W11.F
0E00:  BRA     EEC
0E02:  BTSS    W11.F
0E04:  BRA     E34
0E06:  BTSC    W9.4
0E08:  MOV     W12,W11
0E0A:  COM     W0,W0
0E0C:  COM     W1,W1
0E0E:  COM.B   W2L,W2L
0E10:  INC     W0,W0
0E12:  BRA     NZ,E1A
0E14:  INC     W1,W1
0E16:  BRA     NZ,E1A
0E18:  INC.B   W2L,W2L
0E1A:  BTSC    W9.4
0E1C:  BRA     E7C
0E1E:  BRA     E34
0E20:  BTSS    W11.F
0E22:  BRA     E34
0E24:  COM     W3,W3
0E26:  COM     W4,W4
0E28:  COM.B   W5L,W5L
0E2A:  INC     W3,W3
0E2C:  BRA     NZ,E34
0E2E:  INC     W4,W4
0E30:  BRA     NZ,E34
0E32:  INC.B   W5L,W5L
0E34:  AND     #FF,W5
0E36:  BCLR.B  42.1
0E38:  BCLR.B  42.0
0E3A:  ADD     W0,W3,W0
0E3C:  ADDC    W1,W4,W1
0E3E:  ADDC.B  W2L,W5L,W2L
0E40:  BTSC.B  42.0
0E42:  BSET    W9.3
0E44:  BTSC    W9.0
0E46:  BRA     E5A
0E48:  BTSC    W9.1
0E4A:  BRA     E4E
0E4C:  BRA     E64
0E4E:  BTSC    W11.F
0E50:  BRA     E7C
0E52:  BTSC    W9.3
0E54:  BRA     EAE
0E56:  BSET    W9.6
0E58:  BRA     E9C
0E5A:  BTSC    W11.F
0E5C:  BRA     E7C
0E5E:  BTSC    W9.3
0E60:  BRA     EAE
0E62:  BRA     E9C
0E64:  BCLR    W9.2
0E66:  BTSC    W11.F
0E68:  BRA     E72
0E6A:  MOV     W10,W11
0E6C:  BTSC    W9.3
0E6E:  BRA     EAE
0E70:  BRA     EEC
0E72:  BSET    W9.4
0E74:  XOR.B   #80,W2L
0E76:  BTSC    W2.7
0E78:  BRA     E06
0E7A:  MOV     W10,W11
0E7C:  AND     #FF,W2
0E7E:  IOR      W2,  W1,W7
0E80:  BRA     NZ,E86
0E82:  CP0     W0
0E84:  BRA     Z,E9C
0E86:  BTSC    W2.7
0E88:  BRA     E9C
0E8A:  BCLR.B  42.1
0E8C:  BCLR.B  42.0
0E8E:  RLC     W0,W0
0E90:  RLC     W1,W1
0E92:  RLC     W2,W2
0E94:  DEC     W6,W6
0E96:  BTSC.B  42.1
0E98:  BRA     F08
0E9A:  BRA     E86
0E9C:  BTSC    W9.0
0E9E:  MOV     W10,W11
0EA0:  BTSC    W9.1
0EA2:  MOV     W12,W11
0EA4:  BTSS    W9.5
0EA6:  BRA     EE4
0EA8:  BTSC    W10.F
0EAA:  BSET    W0.8
0EAC:  BRA     EEC
0EAE:  BSET.B  42.0
0EB0:  RRC.B   W2L,W2L
0EB2:  RRC     W1,W1
0EB4:  RRC     W0,W0
0EB6:  BTSC.B  42.0
0EB8:  BSET    W9.5
0EBA:  INC     W6,W6
0EBC:  BRA     Z,F08
0EBE:  BTSS    W9.5
0EC0:  BRA     ED8
0EC2:  INC     W0,W0
0EC4:  BRA     NZ,ED8
0EC6:  INC     W1,W1
0EC8:  BRA     NZ,ED8
0ECA:  INC.B   W2L,W2L
0ECC:  BRA     NZ,ED8
0ECE:  RRC.B   W2L,W2L
0ED0:  RRC     W1,W1
0ED2:  RRC     W0,W0
0ED4:  INC     W6,W6
0ED6:  BRA     Z,F08
0ED8:  BTSC    W9.0
0EDA:  MOV     W10,W11
0EDC:  BTSC    W9.1
0EDE:  MOV     W12,W11
0EE0:  BTSC.B  42.1
0EE2:  BRA     F08
0EE4:  BTSC    W9.6
0EE6:  MOV     W10,W11
0EE8:  BTSC    W9.7
0EEA:  MOV     W12,W11
0EEC:  IOR      W0,  W1,W4
0EEE:  BRA     NZ,EF4
0EF0:  IOR      W2,  W4,W4
0EF2:  BRA     Z,F3C
0EF4:  BCLR    W2.7
0EF6:  SWAP    W6
0EF8:  BCLR.B  42.1
0EFA:  BCLR.B  42.0
0EFC:  RRC     W6,W6
0EFE:  XOR     W6,W2,W2
0F00:  BSET    W2.F
0F02:  BTSS    W11.F
0F04:  BCLR    W2.F
0F06:  BRA     F3C
0F08:  MUL.UU  W0,#0,W0
0F0A:  MOV     #0,W2
0F0C:  BRA     F3C
0F0E:  BTSC    W10.F
0F10:  XOR     W8,W5,W5
0F12:  MOV     W5,W2
0F14:  MOV     W4,W1
0F16:  MOV     W3,W0
0F18:  BRA     F3C
0F1A:  BRA     F3C
0F1C:  AND     #FF,W5
0F1E:  BSET    W5.7
0F20:  AND     #FF,W2
0F22:  BSET    W2.7
0F24:  BTSC    W11.F
0F26:  BCLR    W5.7
0F28:  BSET    W9.2
0F2A:  BRA     E20
0F2C:  SUB     W6,W7,W8
0F2E:  AND     #FF,W2
0F30:  BSET    W2.7
0F32:  AND     #FF,W5
0F34:  BSET    W5.7
0F36:  BCLR    W9.1
0F38:  BSET    W9.0
0F3A:  BRA     DDE
0F3C:  MOV     #1A,W6
0F3E:  REPEAT  #6
0F40:  MOV     [--W15],[W6--]
0F42:  MOV     [--W15],W6
0F44:  RETURN  
*
136E:  MOV     W6,[W15++]
1370:  MOV     W7,[W15++]
1372:  MOV     W8,[W15++]
1374:  MOV     W9,[W15++]
1376:  MOV     #0,W9
1378:  BTSC.B  43.0
137A:  MOV     #1,W9
137C:  MOV     W9,[W15++]
137E:  CLR     W6
1380:  CLR     W7
1382:  CLR     W8
1384:  CLR     W9
1386:  CLR     W10
1388:  CLR     W11
138A:  XOR     W3,W4,W13
138C:  BRA     NZ,1392
138E:  XOR     W13,W5,W13
1390:  BRA     Z,13E2
1392:  CLR     W13
1394:  BTSS    W2.F
1396:  BRA     13A4
1398:  BSET    W13.F
139A:  COM     W2,W2
139C:  COM     W1,W1
139E:  NEG     W0,W0
13A0:  ADDC    W1,#0,W1
13A2:  ADDC    W2,#0,W2
13A4:  BTSS    W5.F
13A6:  BRA     13B4
13A8:  BTG     W13.F
13AA:  COM     W5,W5
13AC:  COM     W4,W4
13AE:  NEG     W3,W3
13B0:  ADDC    W4,#0,W4
13B2:  ADDC    W5,#0,W5
13B4:  MOV     #30,W12
13B6:  BCLR.B  42.0
13B8:  RLC     W0,W0
13BA:  RLC     W1,W1
13BC:  RLC     W2,W2
13BE:  RLC     W6,W6
13C0:  RLC     W7,W7
13C2:  RLC     W8,W8
13C4:  CP      W8,W5
13C6:  BRA     NZ,13CE
13C8:  CPB     W7,W4
13CA:  BRA     NZ,13CE
13CC:  CPB     W6,W3
13CE:  BRA     NC,13D8
13D0:  SUB     W6,W3,W6
13D2:  SUBB    W7,W4,W7
13D4:  SUBB    W8,W5,W8
13D6:  BSET.B  42.0
13D8:  RLC     W9,W9
13DA:  RLC     W10,W10
13DC:  RLC     W11,W11
13DE:  DEC     W12,W12
13E0:  BRA     NZ,13B6
13E2:  MOV     W11,W2
13E4:  MOV     W10,W1
13E6:  MOV     W9,W0
13E8:  BTSS    W13.F
13EA:  BRA     13FA
13EC:  COM     W3,W3
13EE:  COM     W2,W2
13F0:  COM     W1,W1
13F2:  NEG     W0,W0
13F4:  ADDC    W1,#0,W1
13F6:  ADDC    W2,#0,W2
13F8:  ADDC    W3,#0,W3
13FA:  MOV     [--W15],W9
13FC:  CP0     W9
13FE:  BRA     Z,1406
1400:  MOV     W6,W0
1402:  MOV     W7,W1
1404:  MOV     W8,W2
1406:  MOV     [--W15],W9
1408:  MOV     [--W15],W8
140A:  MOV     [--W15],W7
140C:  MOV     [--W15],W6
140E:  RETURN  
*
1536:  MOV     W5,[W15++]
1538:  MOV     #C,W5
153A:  REPEAT  #3
153C:  MOV     [W5++],[W15++]
153E:  MUL.UU  W0,W2,W4
1540:  BTSS    W3.F
1542:  BRA     1548
1544:  MUL.SS  W0,W3,W6
1546:  BRA     154A
1548:  MUL.UU  W0,W3,W6
154A:  BCLR.B  42.0
154C:  ADD     W6,W5,W5
154E:  ADDC    W7,#0,W8
1550:  BTSS    W1.F
1552:  BRA     1558
1554:  MUL.SS  W1,W2,W6
1556:  BRA     155A
1558:  MUL.UU  W1,W2,W6
155A:  ADDC    W6,W5,W5
155C:  ADDC    W7,W8,W8
155E:  ADDC    #0,W9
1560:  MUL.SS  W1,W3,W6
1562:  ADDC    W6,W8,W8
1564:  ADDC    W9,W7,W7
1566:  MOV     W7,W3
1568:  MOV     W8,W2
156A:  MOV     W5,W1
156C:  MOV     W4,W0
156E:  MOV     #12,W5
1570:  REPEAT  #3
1572:  MOV     [--W15],[W5--]
1574:  MOV     [--W15],W5
1576:  RETURN  
*
188E:  MOV     W5,[W15++]
1890:  MOV     #C,W5
1892:  REPEAT  #3
1894:  MOV     [W5++],[W15++]
1896:  MOV     #0,W9
1898:  BTSC.B  43.0
189A:  MOV     #1,W9
189C:  MOV     W9,[W15++]
189E:  XOR     W1,W3,W9
18A0:  BTSS    W1.F
18A2:  BRA     18AA
18A4:  COM     W1,W1
18A6:  NEG     W0,W0
18A8:  ADDC    W1,#0,W1
18AA:  BTSS    W3.F
18AC:  BRA     18B4
18AE:  COM     W3,W3
18B0:  NEG     W2,W2
18B2:  ADDC    W3,#0,W3
18B4:  XOR     W2,W3,W4
18B6:  BRA     Z,18E2
18B8:  CLR     W4
18BA:  CLR     W5
18BC:  CLR     W6
18BE:  CLR     W7
18C0:  MOV     #20,W8
18C2:  BCLR.B  42.0
18C4:  RLC     W0,W0
18C6:  RLC     W1,W1
18C8:  RLC     W4,W4
18CA:  RLC     W5,W5
18CC:  CP      W5,W3
18CE:  BRA     NZ,18D2
18D0:  CPB     W4,W2
18D2:  BRA     NC,18DA
18D4:  SUB     W4,W2,W4
18D6:  SUBB    W5,W3,W5
18D8:  BSET.B  42.0
18DA:  RLC     W6,W6
18DC:  RLC     W7,W7
18DE:  DEC     W8,W8
18E0:  BRA     NZ,18C2
18E2:  BTSS    W9.F
18E4:  BRA     18F4
18E6:  NEG     W6,W0
18E8:  BRA     Z,18EC
18EA:  BRA     NZ,18F0
18EC:  NEG     W7,W1
18EE:  BRA     18FA
18F0:  COM     W7,W1
18F2:  BRA     18FA
18F4:  MOV     W7,W1
18F6:  MOV     W6,W0
18F8:  BRA     18FA
18FA:  MOV     [--W15],W9
18FC:  CP0     W9
18FE:  BRA     Z,1902
1900:  MOV.D   W4,W0
1902:  MOV     #12,W5
1904:  REPEAT  #3
1906:  MOV     [--W15],[W5--]
1908:  MOV     [--W15],W5
190A:  RETURN  
190C:  MOV     W5,[W15++]
190E:  MOV     W6,[W15++]
1910:  MOV     #8E,W1
1912:  BCLR    W6.0
1914:  BTSS    W0.F
1916:  BRA     191E
1918:  BSET    W6.0
191A:  NEG     W0,W0
191C:  BRA     191E
191E:  CP0     W0
1920:  BRA     Z,194A
1922:  BTSC    W0.F
1924:  BRA     192E
1926:  BCLR.B  42.0
1928:  RLC     W0,W0
192A:  DEC     W1,W1
192C:  BRA     1922
192E:  SWAP    W1
1930:  BCLR.B  42.0
1932:  RRC     W1,W1
1934:  BCLR    W0.F
1936:  SWAP    W0
1938:  XOR.B   W0L,W1L,W1L
193A:  AND.B   #0,W0L
193C:  BTSC    W6.0
193E:  BSET    W1.F
1940:  BRA     1950
1942:  MOV.B   W1L,W0L
1944:  BSET    W1.7
1946:  AND.B   #0,W1L
1948:  BRA     1950
194A:  CLR     W0
194C:  CLR     W1
194E:  BRA     1950
1950:  MOV     [--W15],W6
1952:  MOV     [--W15],W5
1954:  RETURN  
1956:  MOV     W5,[W15++]
1958:  MOV     #C,W5
195A:  REPEAT  #4
195C:  MOV     [W5++],[W15++]
195E:  CLR     W9
1960:  XOR     W1,W3,W9
1962:  MOV     W1,W6
1964:  MOV     W0,W5
1966:  MOV     W3,W8
1968:  MOV     W2,W7
196A:  RLC     W1,W1
196C:  SWAP    W1
196E:  ZE      W1,W1
1970:  CP0     W1
1972:  BRA     Z,1A10
1974:  RLC     W3,W3
1976:  SWAP    W3
1978:  ZE      W3,W3
197A:  CP0     W3
197C:  BRA     Z,1A10
197E:  CLR     W0
1980:  SUB.B   W1L,W3L,W0L
1982:  BRA     NC,198A
1984:  ADD.B   #7F,W0L
1986:  BRA     C,1A10
1988:  BRA     1990
198A:  SUB.B   #81,W0L
198C:  BRA     NC,1A10
198E:  BRA     Z,1A10
1990:  MOV     W5,W1
1992:  MOV     W6,W2
1994:  BSET    W2.7
1996:  AND     #FF,W2
1998:  AND     #FF,W8
199A:  BSET    W8.7
199C:  MOV     #19,W10
199E:  CLR     W3
19A0:  CLR     W4
19A2:  SUB     W1,W7,W1
19A4:  SUBB    W2,W8,W2
19A6:  BRA     N,19AC
19A8:  BRA     C,19B2
19AA:  BRA     NZ,19B4
19AC:  ADD     W1,W7,W1
19AE:  ADDC    W2,W8,W2
19B0:  BRA     19B4
19B2:  BSET    W4.0
19B4:  DEC     W10,W10
19B6:  BRA     Z,19C6
19B8:  BCLR.B  42.0
19BA:  RLC     W1,W1
19BC:  RLC     W2,W2
19BE:  BCLR.B  42.0
19C0:  RLC     W4,W4
19C2:  RLC     W3,W3
19C4:  BRA     19A2
19C6:  CLR     W10
19C8:  BTSC    W3.8
19CA:  BRA     19CE
19CC:  BRA     19DA
19CE:  BCLR.B  42.0
19D0:  RRC     W3,W3
19D2:  BCLR    W3.7
19D4:  RRC     W4,W4
19D6:  RLC     W10,W10
19D8:  BRA     19DE
19DA:  DEC     W0,W0
19DC:  BRA     Z,1A10
19DE:  BTSC    W10.F
19E0:  BRA     NC,19EC
19E2:  RLC     W1,W1
19E4:  RLC     W2,W2
19E6:  SUB     W1,W7,W1
19E8:  SUBB    W2,W8,W2
19EA:  BRA     NC,19FE
19EC:  INC     W4,W4
19EE:  BRA     NZ,19FE
19F0:  INC     W3,W3
19F2:  BRA     NZ,19FE
19F4:  INC     W0,W0
19F6:  BRA     Z,1A10
19F8:  BRA     19FE
19FA:  DEC     W0,W0
19FC:  BRA     Z,1A10
19FE:  SWAP    W0
1A00:  RRC     W0,W1
1A02:  BSET    W1.F
1A04:  BTSS    W9.F
1A06:  BCLR    W1.F
1A08:  BCLR    W3.7
1A0A:  XOR.B   W3L,W1L,W1L
1A0C:  MOV     W4,W0
1A0E:  BRA     1A16
1A10:  MOV     #0,W0
1A12:  MOV     #0,W1
1A14:  BRA     1A16
1A16:  MOV     #14,W5
1A18:  REPEAT  #4
1A1A:  MOV     [--W15],[W5--]
1A1C:  MOV     [--W15],W5
1A1E:  RETURN  
1A20:  MOV     W5,[W15++]
1A22:  MOV     #C,W5
1A24:  REPEAT  #3
1A26:  MOV     [W5++],[W15++]
1A28:  CLR     W9
1A2A:  MOV     #8000,W8
1A2C:  BTSC.B  43.0
1A2E:  XOR     W8,W3,W3
1A30:  CP0     W0
1A32:  BRA     NZ,1A3A
1A34:  MOV     #7FFF,W10
1A36:  AND     W1,W10,W10
1A38:  BTSS.B  42.1
1A3A:  MOV     W1,W10
1A3C:  XOR     W3,W10,W11
1A3E:  MOV     W1,W6
1A40:  MOV     W3,W7
1A42:  MOV     W3,W12
1A44:  BCLR.B  42.1
1A46:  BCLR.B  42.0
1A48:  RLC     W6,W6
1A4A:  SWAP    W6
1A4C:  AND     #FF,W6
1A4E:  CP0     W6
1A50:  BRA     Z,1B94
1A52:  BCLR.B  42.1
1A54:  BCLR.B  42.0
1A56:  RLC     W7,W7
1A58:  SWAP    W7
1A5A:  AND     #FF,W7
1A5C:  CP0     W7
1A5E:  BRA     Z,1B9E
1A60:  BCLR.B  42.1
1A62:  BCLR.B  42.0
1A64:  CP      W7,W6
1A66:  BRA     Z,1BA0
1A68:  BRA     N,1BB0
1A6A:  BCLR    W9.0
1A6C:  BSET    W9.1
1A6E:  SUB     W7,W6,W8
1A70:  MOV     W7,W6
1A72:  AND     #FF,W1
1A74:  BSET    W1.7
1A76:  AND     #FF,W3
1A78:  BSET    W3.7
1A7A:  MOV     #28,W7
1A7C:  CP      W7,W8
1A7E:  BRA     N,1AA2
1A80:  BCLR.B  42.1
1A82:  BCLR.B  42.0
1A84:  RRC     W1,W1
1A86:  RRC     W0,W0
1A88:  DEC     W8,W8
1A8A:  BRA     NZ,1A80
1A8C:  BRA     1AA8
1A8E:  MOV     #28,W7
1A90:  CP      W7,W8
1A92:  BRA     N,1AA6
1A94:  BCLR.B  42.1
1A96:  BCLR.B  42.0
1A98:  RRC     W3,W3
1A9A:  RRC     W2,W2
1A9C:  DEC     W8,W8
1A9E:  BRA     NZ,1A94
1AA0:  BRA     1AC0
1AA2:  MOV     W2,W0
1AA4:  MOV     W3,W1
1AA6:  BRA     1B2E
1AA8:  BTSS    W11.F
1AAA:  BRA     1ACE
1AAC:  BTSC    W9.4
1AAE:  MOV     W12,W11
1AB0:  NEG     W0,W0
1AB2:  BRA     Z,1AB8
1AB4:  COM.B   W1L,W1L
1AB6:  BRA     1ABA
1AB8:  NEG     W1,W1
1ABA:  BTSC    W9.4
1ABC:  BRA     1B14
1ABE:  BRA     1ACE
1AC0:  BTSS    W11.F
1AC2:  BRA     1ACE
1AC4:  NEG     W2,W2
1AC6:  BRA     Z,1ACC
1AC8:  COM.B   W3L,W3L
1ACA:  BRA     1ACE
1ACC:  NEG     W3,W3
1ACE:  AND     #FF,W5
1AD0:  BCLR.B  42.1
1AD2:  BCLR.B  42.0
1AD4:  ADD     W0,W2,W0
1AD6:  ADDC.B  W1L,W3L,W1L
1AD8:  BTSC.B  42.0
1ADA:  BSET    W9.3
1ADC:  BTSC    W9.0
1ADE:  BRA     1AF2
1AE0:  BTSC    W9.1
1AE2:  BRA     1AE6
1AE4:  BRA     1AFC
1AE6:  BTSC    W11.F
1AE8:  BRA     1B14
1AEA:  BTSC    W9.3
1AEC:  BRA     1B40
1AEE:  BSET    W9.6
1AF0:  BRA     1B2E
1AF2:  BTSC    W11.F
1AF4:  BRA     1B14
1AF6:  BTSC    W9.3
1AF8:  BRA     1B40
1AFA:  BRA     1B2E
1AFC:  BCLR    W9.2
1AFE:  BTSC    W11.F
1B00:  BRA     1B0A
1B02:  MOV     W10,W11
1B04:  BTSC    W9.3
1B06:  BRA     1B40
1B08:  BRA     1B76
1B0A:  BSET    W9.4
1B0C:  XOR.B   #80,W1L
1B0E:  BTSC    W1.7
1B10:  BRA     1AAC
1B12:  MOV     W10,W11
1B14:  AND     #FF,W1
1B16:  IOR      W0,  W1,W7
1B18:  BRA     Z,1B2E
1B1A:  BTSC    W1.7
1B1C:  BRA     1B2E
1B1E:  BCLR.B  42.1
1B20:  BCLR.B  42.0
1B22:  RLC     W0,W0
1B24:  RLC     W1,W1
1B26:  DEC     W6,W6
1B28:  BTSC.B  42.1
1B2A:  BRA     1B8E
1B2C:  BRA     1B1A
1B2E:  BTSC    W9.0
1B30:  MOV     W10,W11
1B32:  BTSC    W9.1
1B34:  MOV     W12,W11
1B36:  BTSS    W9.5
1B38:  BRA     1B6E
1B3A:  BTSC    W10.F
1B3C:  BSET    W0.8
1B3E:  BRA     1B76
1B40:  BSET.B  42.0
1B42:  RRC.B   W1L,W1L
1B44:  RRC     W0,W0
1B46:  BTSC.B  42.0
1B48:  BSET    W9.5
1B4A:  INC     W6,W6
1B4C:  BRA     Z,1B8E
1B4E:  BTSS    W9.5
1B50:  BRA     1B62
1B52:  INC     W0,W0
1B54:  BRA     NZ,1B62
1B56:  INC.B   W1L,W1L
1B58:  BRA     NZ,1B62
1B5A:  RRC.B   W1L,W1L
1B5C:  RRC     W0,W0
1B5E:  INC     W6,W6
1B60:  BRA     Z,1B8E
1B62:  BTSC    W9.0
1B64:  MOV     W10,W11
1B66:  BTSC    W9.1
1B68:  MOV     W12,W11
1B6A:  BTSC.B  42.1
1B6C:  BRA     1B8E
1B6E:  BTSC    W9.6
1B70:  MOV     W10,W11
1B72:  BTSC    W9.7
1B74:  MOV     W12,W11
1B76:  IOR      W0,  W1,W2
1B78:  BRA     Z,1BC0
1B7A:  BCLR    W1.7
1B7C:  SWAP    W6
1B7E:  BCLR.B  42.1
1B80:  BCLR.B  42.0
1B82:  RRC     W6,W6
1B84:  XOR     W6,W1,W1
1B86:  BSET    W1.F
1B88:  BTSS    W11.F
1B8A:  BCLR    W1.F
1B8C:  BRA     1BC0
1B8E:  MOV     #0,W0
1B90:  MOV     #0,W1
1B92:  BRA     1BC0
1B94:  BTSC    W10.F
1B96:  XOR     W8,W3,W3
1B98:  MOV     W2,W0
1B9A:  MOV     W3,W1
1B9C:  BRA     1BC0
1B9E:  BRA     1BC0
1BA0:  AND     #FF,W3
1BA2:  BSET    W3.7
1BA4:  AND     #FF,W1
1BA6:  BSET    W1.7
1BA8:  BTSC    W11.F
1BAA:  BCLR    W3.7
1BAC:  BSET    W9.2
1BAE:  BRA     1AC0
1BB0:  SUB     W6,W7,W8
1BB2:  AND     #FF,W1
1BB4:  BSET    W1.7
1BB6:  AND     #FF,W3
1BB8:  BSET    W3.7
1BBA:  BCLR    W9.1
1BBC:  BSET    W9.0
1BBE:  BRA     1A8E
1BC0:  MOV     #12,W5
1BC2:  REPEAT  #3
1BC4:  MOV     [--W15],[W5--]
1BC6:  MOV     [--W15],W5
1BC8:  RETURN  
1BCA:  MOV     W5,[W15++]
1BCC:  MOV     W6,[W15++]
1BCE:  MOV     W7,[W15++]
1BD0:  XOR     W1,W3,W4
1BD2:  BTSS    W4.F
1BD4:  BRA     1BE2
1BD6:  BCLR.B  42.0
1BD8:  BCLR.B  42.1
1BDA:  BTSS    W1.F
1BDC:  BRA     1C2A
1BDE:  BSET.B  42.0
1BE0:  BRA     1C2A
1BE2:  MOV     W1,W4
1BE4:  MOV     W0,W5
1BE6:  MOV     W3,W6
1BE8:  MOV     W2,W7
1BEA:  RLC     W1,W1
1BEC:  SWAP    W1
1BEE:  RLC     W3,W3
1BF0:  SWAP    W3
1BF2:  SUB.B   W3L,W1L,W1L
1BF4:  BRA     Z,1C00
1BF6:  BTSS    W4.F
1BF8:  BRA     1C2A
1BFA:  MOV     #1,W0
1BFC:  XOR.B   42
1BFE:  BRA     1C2A
1C00:  MOV.B   W4L,W1L
1C02:  MOV.B   W6L,W3L
1C04:  BCLR    W1.7
1C06:  BCLR    W3.7
1C08:  SUB.B   W3L,W1L,W1L
1C0A:  BRA     Z,1C16
1C0C:  BTSS    W4.F
1C0E:  BRA     1C2A
1C10:  MOV     #1,W0
1C12:  XOR.B   42
1C14:  BRA     1C2A
1C16:  SUB     W7,W5,W1
1C18:  BRA     Z,1C24
1C1A:  BTSS    W4.F
1C1C:  BRA     1C2A
1C1E:  MOV     #1,W0
1C20:  XOR.B   42
1C22:  BRA     1C2A
1C24:  BCLR.B  42.0
1C26:  BRA     1C2A
1C28:  BRA     1C2A
1C2A:  MOV     [--W15],W7
1C2C:  MOV     [--W15],W6
1C2E:  MOV     [--W15],W5
1C30:  RETURN  
1C32:  MOV     W5,[W15++]
1C34:  MOV     #C,W5
1C36:  REPEAT  #4
1C38:  MOV     [W5++],[W15++]
1C3A:  MOV     W0,W4
1C3C:  MOV     W1,W5
1C3E:  MOV     W3,W7
1C40:  MOV     W2,W6
1C42:  BCLR.B  42.0
1C44:  BCLR.B  42.1
1C46:  RLC     W1,W1
1C48:  SWAP    W1
1C4A:  AND     #FF,W1
1C4C:  CP0     W1
1C4E:  BRA     Z,1CE6
1C50:  BCLR.B  42.0
1C52:  BCLR.B  42.1
1C54:  RLC     W3,W3
1C56:  SWAP    W3
1C58:  AND     #FF,W3
1C5A:  CP0     W3
1C5C:  BRA     Z,1CE6
1C5E:  ZE      W0,W0
1C60:  ADD.B   W3L,W1L,W0L
1C62:  BRA     C,1C6C
1C64:  SUB     #7F,W0
1C66:  BRA     Z,1CE6
1C68:  BRA     NC,1CE6
1C6A:  BRA     1C70
1C6C:  ADD.B   #81,W0L
1C6E:  BRA     C,1CE6
1C70:  XOR     W5,W7,W10
1C72:  BCLR.B  42.0
1C74:  BCLR.B  42.1
1C76:  AND     #FF,W5
1C78:  BSET    W5.7
1C7A:  BCLR.B  42.0
1C7C:  AND     #FF,W7
1C7E:  BSET    W7.7
1C80:  MUL.UU  W4,W6,W2
1C82:  MUL.UU  W5,W6,W8
1C84:  ADDC    W8,W3,W3
1C86:  MOV     W9,W1
1C88:  BTSC.B  42.0
1C8A:  INC     W1,W1
1C8C:  BCLR.B  42.0
1C8E:  MUL.UU  W7,W4,W8
1C90:  ADDC    W8,W3,W3
1C92:  ADDC    W9,W1,W1
1C94:  MUL.UU  W5,W7,W8
1C96:  ADDC    W8,W1,W1
1C98:  INC     W0,W0
1C9A:  CP0     W1
1C9C:  BTSC.B  42.1
1C9E:  BRA     1CA2
1CA0:  BRA     1CA8
1CA2:  CP0     W3
1CA4:  BTSC.B  42.1
1CA6:  BRA     1CB2
1CA8:  BTSC    W1.F
1CAA:  BRA     1CB2
1CAC:  RLC     W3,W3
1CAE:  RLC     W1,W1
1CB0:  DEC     W0,W0
1CB2:  MOV     W1,W2
1CB4:  BCLR.B  42.0
1CB6:  BTSS    W3.7
1CB8:  BRA     1CCC
1CBA:  MOV     #FF00,W7
1CBC:  AND     W3,W7,W3
1CBE:  ADD     #100,W3
1CC0:  ADDC    W2,#0,W2
1CC2:  CP0     W2
1CC4:  BRA     NZ,1CCC
1CC6:  CP0     W3
1CC8:  BRA     NZ,1CCC
1CCA:  INC     W0,W0
1CCC:  SWAP    W0
1CCE:  BCLR.B  42.0
1CD0:  BCLR.B  42.1
1CD2:  RRC     W0,W1
1CD4:  BTSC    W10.F
1CD6:  BSET    W1.F
1CD8:  BCLR    W2.F
1CDA:  SWAP    W2
1CDC:  XOR.B   W2L,W1L,W1L
1CDE:  SWAP    W3
1CE0:  MOV.B   W3L,W2L
1CE2:  MOV     W2,W0
1CE4:  BRA     1CEC
1CE6:  MOV     #0,W0
1CE8:  MOV     #0,W1
1CEA:  BRA     1CEC
1CEC:  MOV     #14,W5
1CEE:  REPEAT  #4
1CF0:  MOV     [--W15],[W5--]
1CF2:  MOV     [--W15],W5
1CF4:  RETURN  
1CF6:  MOV     W0,W2
1CF8:  MOV     W1,W3
1CFA:  MOV.B   W1L,W0L
1CFC:  SWAP    W0
1CFE:  BSET    W0.F
1D00:  RLC     W1,W1
1D02:  SWAP    W1
1D04:  ZE      W1,W1
1D06:  MOV     #8E,W4
1D08:  SUB.B   W4L,W1L,W1L
1D0A:  BRA     Z,1D18
1D0C:  CP0     W0
1D0E:  BRA     Z,1D18
1D10:  BCLR.B  42.0
1D12:  RRC     W0,W0
1D14:  DEC     W1,W1
1D16:  BRA     NZ,1D0C
1D18:  BTSS    W3.F
1D1A:  BRA     1D20
1D1C:  NEG     W0,W0
1D1E:  BRA     1D20
1D20:  RETURN  
1D22:  MOV     W5,[W15++]
1D24:  MOV     W6,[W15++]
1D26:  MOV     #8E,W1
1D28:  CP0     W0
1D2A:  BRA     Z,1D50
1D2C:  BTSC    W0.F
1D2E:  BRA     1D38
1D30:  BCLR.B  42.0
1D32:  RLC     W0,W0
1D34:  DEC     W1,W1
1D36:  BRA     1D2C
1D38:  SWAP    W1
1D3A:  BCLR.B  42.0
1D3C:  RRC     W1,W1
1D3E:  BCLR    W0.F
1D40:  SWAP    W0
1D42:  XOR.B   W0L,W1L,W1L
1D44:  AND.B   #0,W0L
1D46:  BRA     1D56
1D48:  MOV.B   W1L,W0L
1D4A:  BSET    W1.7
1D4C:  AND.B   #0,W1L
1D4E:  BRA     1D56
1D50:  CLR     W0
1D52:  CLR     W1
1D54:  BRA     1D56
1D56:  MOV     [--W15],W6
1D58:  MOV     [--W15],W5
1D5A:  RETURN  
*
2B20:  MOV     W5,[W15++]
2B22:  MOV     W6,[W15++]
2B24:  MOV     W2,W3
2B26:  MOV     W2,W5
2B28:  BCLR.B  42.0
2B2A:  RLC     W3,W3
2B2C:  SWAP    W3
2B2E:  AND     #FF,W3
2B30:  BRA     NZ,2B38
2B32:  MUL.UU  W0,#0,W0
2B34:  MUL.UU  W2,#0,W2
2B36:  BRA     2B64
2B38:  ADD     #380,W3
2B3A:  AND     #7F,W2
2B3C:  MOV     #3,W6
2B3E:  CLR     W4
2B40:  BCLR.B  42.0
2B42:  RRC     W2,W2
2B44:  RRC     W1,W1
2B46:  RRC     W0,W0
2B48:  BTSC.B  42.0
2B4A:  INC     W4,W4
2B4C:  DEC     W6,W6
2B4E:  BRA     NZ,2B40
2B50:  BCLR    W2.7
2B52:  SL      W3,#4,W3
2B54:  BCLR    W3.F
2B56:  BTSC    W5.F
2B58:  BSET    W3.F
2B5A:  XOR     W2,W3,W3
2B5C:  MOV     W1,W2
2B5E:  MOV     W0,W1
2B60:  ADD     W4,W1,W1
2B62:  CLR     W0
2B64:  MOV     [--W15],W6
2B66:  MOV     [--W15],W5
2B68:  RETURN  
2B6A:  MOV     W8,[W15++]
2B6C:  MOV     #12,W8
2B6E:  REPEAT  #4
2B70:  MOV     [W8++],[W15++]
2B72:  CLR     W11
2B74:  MUL.UU  W12,#0,W12
2B76:  MOV     W3,W8
2B78:  MOV     W7,W9
2B7A:  MOV     #7FF,W10
2B7C:  BCLR.B  42.0
2B7E:  BCLR.B  42.1
2B80:  ASR     W8,#4,W8
2B82:  AND     W10,W8,W8
2B84:  CP0     W8
2B86:  BRA     Z,2C6A
2B88:  BCLR.B  42.0
2B8A:  BCLR.B  42.1
2B8C:  ASR     W9,#4,W9
2B8E:  AND     W10,W9,W9
2B90:  CP0     W9
2B92:  BRA     Z,2C6A
2B94:  ADD     W9,W8,W8
2B96:  BTSC    W9.B
2B98:  BRA     2BA2
2B9A:  SUB     #3FF,W8
2B9C:  BRA     Z,2C6A
2B9E:  BRA     NC,2C6A
2BA0:  BRA     2BA8
2BA2:  MOV     #401,W10
2BA4:  ADD.B   W10L,W5L,W5L
2BA6:  BRA     C,2C6A
2BA8:  XOR     W3,W7,W13
2BAA:  BCLR.B  42.0
2BAC:  BCLR.B  42.1
2BAE:  AND     #F,W3
2BB0:  BSET    W3.4
2BB2:  AND     #F,W7
2BB4:  BSET    W7.4
2BB6:  MOV     W8,[W15++]
2BB8:  MUL.UU  W4,W1,W8
2BBA:  MUL.UU  W5,W0,W10
2BBC:  ADD     W8,W10,W10
2BBE:  ADDC    W9,W11,W11
2BC0:  ADDC    #0,W12
2BC2:  MUL.UU  W4,W2,W8
2BC4:  ADD     W8,W11,W11
2BC6:  ADDC    W9,W12,W12
2BC8:  MUL.UU  W5,W1,W8
2BCA:  CLR     W10
2BCC:  ADD     W8,W11,W11
2BCE:  ADDC    W9,W12,W12
2BD0:  ADDC    #0,W10
2BD2:  MUL.UU  W6,W0,W8
2BD4:  ADD     W8,W11,W11
2BD6:  ADDC    W9,W12,W12
2BD8:  ADDC    #0,W10
2BDA:  CLR     W11
2BDC:  MUL.UU  W4,W3,W8
2BDE:  ADD     W8,W12,W12
2BE0:  ADDC    W9,W10,W10
2BE2:  ADDC    #0,W11
2BE4:  MUL.UU  W5,W2,W8
2BE6:  ADD     W8,W12,W12
2BE8:  ADDC    W9,W10,W10
2BEA:  ADDC    #0,W11
2BEC:  MUL.UU  W6,W1,W8
2BEE:  ADD     W8,W12,W12
2BF0:  ADDC    W9,W10,W10
2BF2:  ADDC    #0,W11
2BF4:  MUL.UU  W7,W0,W8
2BF6:  ADD     W8,W12,W12
2BF8:  ADDC    W9,W10,W10
2BFA:  ADDC    #0,W11
2BFC:  MOV     W12,W0
2BFE:  CLR     W12
2C00:  MUL.UU  W5,W3,W8
2C02:  ADD     W8,W10,W10
2C04:  ADDC    W9,W11,W11
2C06:  ADDC    #0,W12
2C08:  MUL.UU  W6,W2,W8
2C0A:  ADD     W8,W10,W10
2C0C:  ADDC    W9,W11,W11
2C0E:  ADDC    #0,W12
2C10:  MUL.UU  W6,W3,W8
2C12:  ADD     W8,W11,W11
2C14:  ADDC    W9,W12,W12
2C16:  MUL.UU  W7,W1,W8
2C18:  ADD     W8,W10,W10
2C1A:  ADDC    W9,W11,W11
2C1C:  ADDC    #0,W12
2C1E:  MUL.UU  W7,W2,W8
2C20:  ADD     W8,W11,W11
2C22:  ADDC    W9,W12,W12
2C24:  MUL.UU  W7,W3,W8
2C26:  ADD     W8,W12,W12
2C28:  MOV     W10,W1
2C2A:  MOV     W11,W2
2C2C:  MOV     W12,W3
2C2E:  MOV     #5,W4
2C30:  BCLR.B  42.0
2C32:  RRC     W3,W3
2C34:  RRC     W2,W2
2C36:  RRC     W1,W1
2C38:  RRC     W0,W0
2C3A:  DEC     W4,W4
2C3C:  BRA     NZ,2C30
2C3E:  MOV     [--W15],W8
2C40:  INC     W8,W8
2C42:  IOR      W0,  W1,W6
2C44:  BRA     Z,2C48
2C46:  BRA     2C4C
2C48:  IOR      W2,  W3,W6
2C4A:  BRA     Z,2C5C
2C4C:  BTSC    W3.4
2C4E:  BRA     2C5C
2C50:  BCLR.B  42.0
2C52:  RLC     W0,W0
2C54:  RLC     W1,W1
2C56:  RLC     W2,W2
2C58:  RLC     W3,W3
2C5A:  DEC     W8,W8
2C5C:  SL      W8,#4,W8
2C5E:  BCLR    W3.F
2C60:  BTSC    W13.F
2C62:  BSET    W3.F
2C64:  BCLR    W3.4
2C66:  XOR     W8,W3,W3
2C68:  BRA     2C70
2C6A:  MUL.UU  W0,#0,W0
2C6C:  MUL.UU  W0,#0,W2
2C6E:  BRA     2C70
2C70:  MOV     #1A,W8
2C72:  REPEAT  #4
2C74:  MOV     [--W15],[W8--]
2C76:  MOV     [--W15],W8
2C78:  RETURN  
2C7A:  MOV     W5,[W15++]
2C7C:  MOV     #C,W5
2C7E:  REPEAT  #5
2C80:  MOV     [W5++],[W15++]
2C82:  MOV     W3,W8
2C84:  MOV     W2,W7
2C86:  MOV     W1,W6
2C88:  MOV     W0,W5
2C8A:  MOV     W3,W9
2C8C:  MOV     #473,W11
2C8E:  ASR     W3,#4,W3
2C90:  MOV     #7FF,W10
2C92:  AND     W10,W3,W3
2C94:  SUB     W11,W3,W11
2C96:  AND     #1F,W8
2C98:  BSET    W8.4
2C9A:  CLR     W0
2C9C:  CLR     W1
2C9E:  CLR     W2
2CA0:  CLR     W3
2CA2:  BCLR.B  42.0
2CA4:  RRC     W8,W8
2CA6:  RRC     W7,W7
2CA8:  RRC     W6,W6
2CAA:  RRC     W5,W5
2CAC:  RRC     W3,W3
2CAE:  RRC     W2,W2
2CB0:  RRC     W1,W1
2CB2:  RRC     W0,W0
2CB4:  DEC     W11,W11
2CB6:  BRA     NZ,2CA2
2CB8:  BTSS    W9.F
2CBA:  BRA     2CCE
2CBC:  COM     W0,W0
2CBE:  COM     W1,W1
2CC0:  COM     W2,W2
2CC2:  COM     W3,W3
2CC4:  INC     W0,W0
2CC6:  ADDC    #0,W1
2CC8:  ADDC    #0,W2
2CCA:  ADDC    #0,W3
2CCC:  BRA     2CCE
2CCE:  MOV     #16,W5
2CD0:  REPEAT  #5
2CD2:  MOV     [--W15],[W5--]
2CD4:  MOV     [--W15],W5
2CD6:  RETURN  
2CD8:  MOV     W12,[W15++]
2CDA:  MOV     W13,[W15++]
2CDC:  CLR     W8
2CDE:  CLR     W9
2CE0:  CLR     W10
2CE2:  CLR     W11
2CE4:  CLR     W12
2CE6:  CLR     W13
2CE8:  MOV     #E,W8
2CEA:  MOV     #0,W9
2CEC:  LNK     #10
2CEE:  MOV     W12,[W14+W8]
2CF0:  DEC2    W8,W8
2CF2:  BRA     NN,2CEE
2CF4:  XOR     W4,W5,W8
2CF6:  BRA     NZ,2CFC
2CF8:  XOR     W6,W7,W8
2CFA:  BRA     Z,2D5A
2CFC:  CLR     W8
2CFE:  MOV     #40,W13
2D00:  MOV     #40,W13
2D02:  BCLR.B  42.0
2D04:  RLC     W0,W0
2D06:  RLC     W1,W1
2D08:  RLC     W2,W2
2D0A:  RLC     W3,W3
2D0C:  RLC     W8,W8
2D0E:  RLC     W9,W9
2D10:  RLC     W10,W10
2D12:  RLC     W11,W11
2D14:  CP      W11,W7
2D16:  BRA     NZ,2D22
2D18:  CPB     W10,W6
2D1A:  BRA     NZ,2D22
2D1C:  CPB     W9,W5
2D1E:  BRA     NZ,2D22
2D20:  CPB     W8,W4
2D22:  BRA     NC,2D2E
2D24:  SUB     W8,W4,W8
2D26:  SUBB    W9,W5,W9
2D28:  SUBB    W10,W6,W10
2D2A:  SUBB    W11,W7,W11
2D2C:  BSET.B  42.0
2D2E:  MOV     W8,[W14]
2D30:  MOV     W9,[W14+#2]
2D32:  MOV     W10,[W14+#4]
2D34:  MOV     W11,[W14+#6]
2D36:  MOV     [W14+#8],W8
2D38:  MOV     [W14+#A],W9
2D3A:  MOV     [W14+#C],W10
2D3C:  MOV     [W14+#E],W11
2D3E:  RLC     W8,W8
2D40:  RLC     W9,W9
2D42:  RLC     W10,W10
2D44:  RLC     W11,W11
2D46:  MOV     W8,[W14+#8]
2D48:  MOV     W9,[W14+#A]
2D4A:  MOV     W10,[W14+#C]
2D4C:  MOV     W11,[W14+#E]
2D4E:  MOV     [W14],W8
2D50:  MOV     [W14+#2],W9
2D52:  MOV     [W14+#4],W10
2D54:  MOV     [W14+#6],W11
2D56:  DEC     W13,W13
2D58:  BRA     NZ,2D02
2D5A:  MOV     [W14+#8],W0
2D5C:  MOV     [W14+#A],W1
2D5E:  MOV     [W14+#C],W2
2D60:  MOV     [W14+#E],W3
2D62:  ULNK    
2D64:  BRA     2D66
2D66:  MOV     [--W15],W13
2D68:  MOV     [--W15],W12
2D6A:  RETURN  
2D6C:  MOV     W5,[W15++]
2D6E:  MOV     #C,W5
2D70:  REPEAT  #7
2D72:  MOV     [W5++],[W15++]
2D74:  LNK     #2A
2D76:  MOV     #28,W8
2D78:  CLR     W12
2D7A:  MOV     W12,[W14+W8]
2D7C:  DEC2    W8,W8
2D7E:  BRA     NN,2D7A
2D80:  MOV     W10,[W14+#28]
2D82:  CP0     W9
2D84:  BRA     Z,2DA0
2D86:  MOV     W9,[W14+#26]
2D88:  MOV     #4024,W7
2D8A:  CLR     W6
2D8C:  MUL.UU  W4,#0,W4
2D8E:  MOV     W9,[W14+#24]
2D90:  MOV     #4024,W7
2D92:  CLR     W6
2D94:  MUL.UU  W4,#0,W4
2D96:  CALL    2B6A
2D9A:  MOV     [W14+#24],W9
2D9C:  DEC     W9,W9
2D9E:  BRA     NZ,2D8E
2DA0:  MOV     [W14+#26],W9
2DA2:  MOV     #14,W8
2DA4:  MOV     W8,[W14+#24]
2DA6:  MOV     #41CD,W7
2DA8:  MOV     #CD65,W6
2DAA:  MUL.UU  W4,#0,W4
2DAC:  MOV     W0,[W14+#10]
2DAE:  MOV     W1,[W14+#12]
2DB0:  MOV     W2,[W14+#14]
2DB2:  MOV     W3,[W14+#16]
2DB4:  MOV     #14,W8
2DB6:  MOV     W8,[W14+#20]
2DB8:  MOV     #0,W4
2DBA:  MOV     #89E8,W5
2DBC:  MOV     #2304,W6
2DBE:  MOV     #8AC7,W7
2DC0:  MOV     W4,[W14+#18]
2DC2:  MOV     W5,[W14+#1A]
2DC4:  MOV     W6,[W14+#1C]
2DC6:  MOV     W7,[W14+#1E]
2DC8:  BTSS    W3.F
2DCA:  BRA     2DD4
2DCC:  MOV     [W14+#28],W8
2DCE:  DEC     W8,W8
2DD0:  BSET    W8.D
2DD2:  MOV     W8,[W14+#28]
2DD4:  BCLR    W3.F
2DD6:  CALL    2C7A
2DDA:  MOV     [W14+#28],W8
2DDC:  MOV     [W14+#26],W9
2DDE:  CP0     W9
2DE0:  BTSC.B  42.1
2DE2:  INC.B   W8L,W8L
2DE4:  MOV     W8,[W14+#28]
2DE6:  MOV     [W14+#22],W9
2DE8:  CLR     W9
2DEA:  MOV     W9,[W14+#22]
2DEC:  MOV     [W14+#18],W4
2DEE:  MOV     [W14+#1A],W5
2DF0:  MOV     [W14+#1C],W6
2DF2:  MOV     [W14+#1E],W7
2DF4:  CALL    2CD8
2DF8:  MOV     [W14+#22],W13
2DFA:  BTSC    W13.0
2DFC:  BRA     2EC2
2DFE:  MOV     W8,[W14+#10]
2E00:  MOV     W9,[W14+#12]
2E02:  MOV     W10,[W14+#14]
2E04:  MOV     W11,[W14+#16]
2E06:  MOV     [W14+#22],W13
2E08:  BTG     W13.0
2E0A:  MOV     W13,[W14+#22]
2E0C:  CP0     W0
2E0E:  BRA     NZ,2E34
2E10:  MOV     [W14+#26],W9
2E12:  INC     W9,W9
2E14:  MOV     [W14+#24],W10
2E16:  SUB     W10,W9,W8
2E18:  BRA     Z,2E34
2E1A:  MOV     [W14+#28],W11
2E1C:  CP0     W11
2E1E:  BRA     Z,2E3C
2E20:  AND     W11,#1F,W8
2E22:  SUB     W10,W8,W8
2E24:  BRA     Z,2E28
2E26:  BRA     C,2EAA
2E28:  BTSC    W11.F
2E2A:  BRA     2EAA
2E2C:  BTSC    W11.E
2E2E:  BRA     2E3C
2E30:  MOV     #20,W0
2E32:  BRA     2EA2
2E34:  MOV     [W14+#28],W11
2E36:  MOV     #2000,W12
2E38:  AND     W12,W11,W11
2E3A:  MOV     W11,[W14+#28]
2E3C:  MOV     [W14+#28],W11
2E3E:  BTSS    W11.D
2E40:  BRA     2E60
2E42:  BCLR    W11.D
2E44:  MOV     [W14+#26],W9
2E46:  CP0     W9
2E48:  BTSS.B  42.1
2E4A:  DEC     W11,W11
2E4C:  CLR     W11
2E4E:  MOV     W11,[W14+#28]
2E50:  MOV     W0,W10
2E52:  BTSC.B  233.1
2E54:  BRA     2E52
2E56:  MOV     #2D,W4
2E58:  MOV     W4,234
2E5A:  MOV     W10,W0
2E5C:  CLR     W11
2E5E:  MOV     W11,[W14+#28]
2E60:  MOV     [W14+#26],W9
2E62:  MOV     [W14+#24],W10
2E64:  SUB     W10,W9,W8
2E66:  BRA     NZ,2E80
2E68:  CLR     W11
2E6A:  MOV     W11,[W14+#28]
2E6C:  MOV     W0,W10
2E6E:  BTSC.B  233.1
2E70:  BRA     2E6E
2E72:  MOV     #2E,W4
2E74:  MOV     W4,234
2E76:  MOV     [W14+#28],W11
2E78:  MOV     #2000,W12
2E7A:  AND     W12,W11,W11
2E7C:  MOV     W11,[W14+#28]
2E7E:  MOV     W10,W0
2E80:  MOV     #30,W1
2E82:  MOV     [W14+#28],W11
2E84:  BTSS    W11.D
2E86:  BRA     2EA2
2E88:  BCLR    W11.D
2E8A:  MOV     [W14+#26],W9
2E8C:  CP0     W9
2E8E:  BTSS.B  42.1
2E90:  DEC     W11,W11
2E92:  CLR     W11
2E94:  MOV     W11,[W14+#28]
2E96:  BTSC.B  233.1
2E98:  BRA     2E96
2E9A:  MOV     #2D,W4
2E9C:  MOV     W4,234
2E9E:  CLR     W0
2EA0:  MOV     #30,W1
2EA2:  ADD     W1,W0,W0
2EA4:  BTSC.B  233.1
2EA6:  BRA     2EA4
2EA8:  MOV     W0,234
2EAA:  MOV     [W14+#24],W13
2EAC:  DEC     W13,W13
2EAE:  BRA     Z,2EE2
2EB0:  MOV     W13,[W14+#24]
2EB2:  MOV     [W14+#18],W0
2EB4:  MOV     [W14+#1A],W1
2EB6:  MOV     [W14+#1C],W2
2EB8:  MOV     [W14+#1E],W3
2EBA:  MOV     #A,W4
2EBC:  CLR     W5
2EBE:  MUL.UU  W6,#0,W6
2EC0:  BRA     2DF4
2EC2:  MOV     W0,[W14+#18]
2EC4:  MOV     W1,[W14+#1A]
2EC6:  MOV     W2,[W14+#1C]
2EC8:  MOV     W3,[W14+#1E]
2ECA:  MOV     W0,W4
2ECC:  MOV     W1,W5
2ECE:  MOV     W2,W6
2ED0:  MOV     W3,W7
2ED2:  MOV     [W14+#10],W0
2ED4:  MOV     [W14+#12],W1
2ED6:  MOV     [W14+#14],W2
2ED8:  MOV     [W14+#16],W3
2EDA:  MOV     [W14+#22],W13
2EDC:  BTG     W13.0
2EDE:  MOV     W13,[W14+#22]
2EE0:  BRA     2DF4
2EE2:  ULNK    
2EE4:  MOV     #1A,W5
2EE6:  REPEAT  #7
2EE8:  MOV     [--W15],[W5--]
2EEA:  MOV     [--W15],W5
2EEC:  RETURN  
*
2F6C:  MOV     W5,[W15++]
2F6E:  MOV     #C,W5
2F70:  REPEAT  #3
2F72:  MOV     [W5++],[W15++]
2F74:  MOV     W0,W7
2F76:  MOV     W4,W9
2F78:  BCLR    W4.F
2F7A:  CP0     W4
2F7C:  BRA     NZ,2F8A
2F7E:  BTSC    W9.F
2F80:  BRA     2F86
2F82:  MOV     #0,W5
2F84:  BRA     2FA8
2F86:  MOV     #0,W5
2F88:  BRA     2FA8
2F8A:  SUB.B   W4L,#6,W5L
2F8C:  BRA     NC,2FA6
2F8E:  MOV     #30,W0
2F90:  BTSS    W9.F
2F92:  MOV     #20,W0
2F94:  MOV     W0,[W15++]
2F96:  BTSC.B  233.1
2F98:  BRA     2F96
2F9A:  MOV     W0,234
2F9C:  MOV     [--W15],W0
2F9E:  DEC     W5,W5
2FA0:  BRA     NN,2F94
2FA2:  MOV     #5,W5
2FA4:  BRA     2FA8
2FA6:  MOV     W4,W5
2FA8:  MOV     #6,W4
2FAA:  BSET    W5.E
2FAC:  BTSC    W9.F
2FAE:  BSET    W5.F
2FB0:  MOV     #2710,W8
2FB2:  REPEAT  #11
2FB4:  DIV.U   W7,W8
2FB6:  CALL    2FEA
2FBA:  MOV     W1,W7
2FBC:  MOV     #3E8,W8
2FBE:  REPEAT  #11
2FC0:  DIV.U   W7,W8
2FC2:  CALL    2FEA
2FC6:  MOV     W1,W7
2FC8:  MOV     #64,W8
2FCA:  REPEAT  #11
2FCC:  DIV.U   W7,W8
2FCE:  CALL    2FEA
2FD2:  MOV     W1,W7
2FD4:  MOV     #A,W8
2FD6:  REPEAT  #11
2FD8:  DIV.U   W7,W8
2FDA:  CALL    2FEA
2FDE:  MOV     #30,W0
2FE0:  ADD.B   W1L,W0L,W0L
2FE2:  BTSC.B  233.1
2FE4:  BRA     2FE2
2FE6:  MOV     W0,234
2FE8:  BRA     3018
2FEA:  MOV     #30,W6
2FEC:  CP0     W0
2FEE:  BRA     NZ,300C
2FF0:  BTSS    W5.E
2FF2:  BRA     300E
2FF4:  DEC     W4,W4
2FF6:  CP.B    W4L,W5L
2FF8:  BRA     Z,2FFE
2FFA:  BTSC.B  42.0
2FFC:  RETURN  
2FFE:  CP0     W0
3000:  BRA     NZ,300C
3002:  BTSS    W5.E
3004:  BRA     300E
3006:  BTSS    W5.F
3008:  MOV     #20,W6
300A:  BRA     300E
300C:  BCLR    W5.E
300E:  ADD.B   W6L,W0L,W0L
3010:  BTSC.B  233.1
3012:  BRA     3010
3014:  MOV     W0,234
3016:  RETURN  
3018:  MOV     #12,W5
301A:  REPEAT  #3
301C:  MOV     [--W15],[W5--]
301E:  MOV     [--W15],W5
3020:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(clock=16000000) 
*
33E0:  CP0     W0
33E2:  BTSC.B  42.1
33E4:  BRA     33EE
33E6:  REPEAT  #1F3B
33E8:  NOP     
33EA:  DEC     W0,W0
33EC:  BRA     NZ,33E6
33EE:  RETURN  
.................... #use rtos(timer=1,minor_cycle=100ms,statistics)// 
....................  
.................... #use fixed_io(b_outputs=PIN_b6) 
.................... #fuses nowdt,protect,FRC_PLL 
.................... #build (stack=256) 
....................  
.................... #define fet1 PIN_b6//d5 
.................... //#define fet2 PIN_b14//d4 
....................  
.................... //#define led1 PIN_b10 
.................... //#define led2 PIN_b11 
.................... //#define led3 PIN_b12 
.................... //#define led4 PIN_b13 
....................  
.................... //#define TOSTRING(s)   #s 
.................... //#define nmea(ss) NMEA_##ss(); 
.................... //------------------------------------------------------------------------------// 
.................... #include<gsm_7.h> 
.................... /****************IMEI-866762029510326;BAUD-19200  *****************************/ 
.................... /****************IMEI-866593020769383;BAUD-9600  *****************************/ 
.................... /****************IMEI-866762027240124;BAUD-19200  *****************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
*
04D4:  MOV     W5,[W15++]
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
04D6:  PUSH    C50
04D8:  POP     C56
04DA:  CP0     C54
04DC:  BRA     Z,4F4
04DE:  MOV     C52,W0
04E0:  CP0.B   [W0]
04E2:  BRA     Z,4F4
....................      *s++ = *s2++; 
04E4:  MOV     C56,W0
04E6:  INC     0C56
04E8:  MOV     W0,W5
04EA:  MOV     C52,W0
04EC:  INC     0C52
04EE:  MOV.B   [W0],[W5]
04F0:  DEC     0C54
04F2:  BRA     4DA
....................   for (; n > 0; n--) 
04F4:  CP0     C54
04F6:  BRA     Z,504
....................      *s++ = '\0'; 
04F8:  MOV     C56,W0
04FA:  INC     0C56
04FC:  MOV     W0,W5
04FE:  CLR.B   [W5]
0500:  DEC     0C54
0502:  BRA     4F4
....................  
....................   return(s1); 
0504:  PUSH    C50
0506:  POP     0
0508:  MOV     [--W15],W5
050A:  RETURN  
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
*
060C:  MOV     W5,[W15++]
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
060E:  CP0     C58
0610:  BRA     Z,64E
....................       if (*s1 != *s2) 
0612:  MOV     C54,W0
0614:  MOV.B   [W0],W5L
0616:  MOV     C56,W0
0618:  MOV     W0,W4
061A:  MOV.B   [W4],W0L
061C:  CP.B    W5L,W0L
061E:  BRA     Z,638
....................          return((*s1 <*s2) ? -1: 1); 
0620:  MOV     C54,W0
0622:  MOV.B   [W0],W5L
0624:  MOV     C56,W0
0626:  MOV     W0,W4
0628:  MOV.B   [W4],W0L
062A:  CP.B    W5L,W0L
062C:  BRA     C,632
062E:  SETM.B  W0
0630:  BRA     634
0632:  MOV.B   #1,W0L
0634:  BRA     650
0636:  BRA     642
....................       else if (*s1 == '\0') 
0638:  MOV     C54,W0
063A:  CP0.B   [W0]
063C:  BRA     NZ,642
....................          return(0); 
063E:  CLR.B   0
0640:  BRA     650
0642:  MOV     C54,W0
0644:  INC     0C54
0646:  MOV     C56,W0
0648:  INC     0C56
064A:  DEC     0C58
064C:  BRA     60E
....................    return(0); 
064E:  CLR.B   0
0650:  MOV     [--W15],W5
0652:  RETURN  
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
*
0AC4:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
0AC6:  PUSH    B66
0AC8:  POP     B6A
0ACA:  MOV     B6A,W0
0ACC:  CP0.B   [W0]
0ACE:  BRA     Z,AF6
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0AD0:  PUSH    B68
0AD2:  POP     B6C
0AD4:  MOV     B6C,W0
0AD6:  CP0.B   [W0]
0AD8:  BRA     Z,AF2
....................          if (*sc1 == *sc2) 
0ADA:  MOV     B6A,W0
0ADC:  MOV.B   [W0],W5L
0ADE:  MOV     B6C,W0
0AE0:  MOV     W0,W4
0AE2:  MOV.B   [W4],W0L
0AE4:  CP.B    W5L,W0L
0AE6:  BRA     NZ,AEE
....................             return(sc1); 
0AE8:  PUSH    B6A
0AEA:  POP     0
0AEC:  BRA     AF8
0AEE:  INC     0B6C
0AF0:  BRA     AD4
0AF2:  INC     0B6A
0AF4:  BRA     ACA
....................    return(0); 
0AF6:  CLR     0
0AF8:  MOV     [--W15],W5
0AFA:  RETURN  
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
*
0A82:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
0A84:  PUSH    B66
0A86:  POP     B6A
0A88:  MOV     B6A,W0
0A8A:  CP0.B   [W0]
0A8C:  BRA     Z,ABA
....................       for (sc2 = s2; ; sc2++) 
0A8E:  PUSH    B68
0A90:  POP     B6C
....................     if (*sc2 == '\0') 
0A92:  MOV     B6C,W0
0A94:  CP0.B   [W0]
0A96:  BRA     NZ,AA2
....................        return(sc1 - s1); 
0A98:  MOV     B6A,W4
0A9A:  MOV     B66,W3
0A9C:  SUB     W4,W3,W0
0A9E:  BRA     AC0
0AA0:  BRA     AB2
....................          else if (*sc1 == *sc2) 
0AA2:  MOV     B6A,W0
0AA4:  MOV.B   [W0],W5L
0AA6:  MOV     B6C,W0
0AA8:  MOV     W0,W4
0AAA:  MOV.B   [W4],W0L
0AAC:  CP.B    W5L,W0L
0AAE:  BRA     NZ,AB2
....................             break; 
0AB0:  BRA     AB6
0AB2:  INC     0B6C
0AB4:  BRA     A92
0AB6:  INC     0B6A
0AB8:  BRA     A88
....................    return(sc1 - s1); 
0ABA:  MOV     B6A,W4
0ABC:  MOV     B66,W3
0ABE:  SUB     W4,W3,W0
0AC0:  MOV     [--W15],W5
0AC2:  RETURN  
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
*
0A66:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
0A68:  PUSH    B66
0A6A:  POP     B68
0A6C:  MOV     B68,W0
0A6E:  CP0.B   [W0]
0A70:  BRA     Z,A76
0A72:  INC     0B68
0A74:  BRA     A6C
....................    return(sc - s); 
0A76:  MOV     B68,W4
0A78:  MOV     B66,W3
0A7A:  SUB     W4,W3,W0
0A7C:  MOV     W0,0
0A7E:  MOV     [--W15],W5
0A80:  RETURN  
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
*
0AFC:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
0AFE:  CP0     B5C
0B00:  BRA     Z,B06
0B02:  MOV     B5C,W0
0B04:  BRA     B08
0B06:  MOV     804,W0
0B08:  MOV     W0,B60
....................    beg += strspn(beg, s2); 
0B0A:  PUSH    B60
0B0C:  POP     B66
0B0E:  PUSH    B5E
0B10:  POP     B68
0B12:  CALL    A82
0B16:  MOV.B   W0L,W5L
0B18:  ZE      W5,W5
0B1A:  MOV     W5,W0
0B1C:  ADD     B60
....................    if (*beg == '\0') 
0B1E:  MOV     B60,W0
0B20:  CP0.B   [W0]
0B22:  BRA     NZ,B28
....................       return(0); 
0B24:  CLR     0
0B26:  BRA     B58
....................        
....................    end = strpbrk(beg, s2); 
0B28:  PUSH    B60
0B2A:  POP     B66
0B2C:  PUSH    B5E
0B2E:  POP     B68
0B30:  CALL    AC4
0B34:  MOV     W0,B62
....................    if (end != '\0') 
0B36:  CP0     B62
0B38:  BRA     Z,B46
....................    { 
....................       *end = '\0'; 
0B3A:  MOV     B62,W5
0B3C:  CLR.B   [W5]
....................       end++; 
0B3E:  INC     0B62
....................       save = end; 
0B40:  PUSH    B62
0B42:  POP     804
....................    } 
0B44:  BRA     B54
....................    else 
....................       save = beg + strlen(beg); 
0B46:  PUSH    B60
0B48:  POP     B66
0B4A:  CALL    A66
0B4E:  MOV     B60,W4
0B50:  ADD     W0,W4,W0
0B52:  MOV     W0,804
....................     
....................    return(beg); 
0B54:  PUSH    B60
0B56:  POP     0
0B58:  MOV     [--W15],W5
0B5A:  RETURN  
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
*
1EF6:  MOV     W5,[W15++]
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
1EF8:  MOV     B8C,W0
1EFA:  MOV     B8E,W1
1EFC:  MOV     #0,W2
1EFE:  MOV     #0,W3
1F00:  CALL    1BCA
1F04:  BRA     C,1F08
1F06:  BRA     NZ,1F0E
....................       return(0.0); 
1F08:  MOV     #0,W0
1F0A:  MOV     #0,W1
1F0C:  BRA     1FC6
....................  
....................    y=x; 
1F0E:  PUSH    B8C
1F10:  POP     B90
1F12:  PUSH    B8E
1F14:  POP     B92
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
1F16:  MOV     #B93,W4
1F18:  MOV     W4,B9C
....................     data1 = *(((unsigned int8 *)(&y))+3); 
1F1A:  MOV     #B93,W0
1F1C:  MOV     B98,W4
1F1E:  MOV.B   [W0+#0],W4L
1F20:  MOV     W4,B98
1F22:  CLR.B   B99
....................     data2 = *(((unsigned int8 *)(&y))+2); 
1F24:  MOV     #B92,W0
1F26:  MOV     B9A,W4
1F28:  MOV.B   [W0+#0],W4L
1F2A:  MOV     W4,B9A
1F2C:  CLR.B   B9B
....................     rotate_left(&data1,1);     
1F2E:  MOV     #B98,W1
1F30:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7))     
1F32:  BTSS.B  B9A.7
1F34:  BRA     1F38
....................        bit_set(data1,0);     
1F36:  BSET.B  B98.0
....................     data1 = ((data1+127) >>1); 
1F38:  MOV     #7F,W4
1F3A:  MOV     B98,W3
1F3C:  ADD     W3,W4,W5
1F3E:  MOV     W5,B98
1F40:  LSR     B98
....................     bit_clear(data2,7); 
1F42:  BCLR.B  B9A.7
....................     if(bit_test(data1,0)) 
1F44:  BTSS.B  B98.0
1F46:  BRA     1F4A
....................        bit_set(data2,7); 
1F48:  BSET.B  B9A.7
....................     data1 = data1 >>1; 
1F4A:  LSR     B98
....................     *(((unsigned int8 *)(&y))+3) = data1; 
1F4C:  MOV     #B93,W5
1F4E:  MOV     B98,W0
1F50:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
1F52:  MOV     #B92,W5
1F54:  MOV     B9A,W0
1F56:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
1F58:  PUSH    B90
1F5A:  POP     B94
1F5C:  PUSH    B92
1F5E:  POP     B96
....................       y+=(x/y); 
1F60:  MOV     B8C,W0
1F62:  MOV     B8E,W1
1F64:  MOV     B90,W2
1F66:  MOV     B92,W3
1F68:  CALL    1956
1F6C:  BCLR.B  43.0
1F6E:  MOV     W0,W2
1F70:  MOV     W1,W3
1F72:  MOV     B90,W0
1F74:  MOV     B92,W1
1F76:  CALL    1A20
1F7A:  MOV     W0,B90
1F7C:  MOV     W1,B92
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
1F7E:  MOV     #B93,W0
1F80:  MOV     B98,W4
1F82:  MOV.B   [W0+#0],W4L
1F84:  MOV     W4,B98
1F86:  CLR.B   B99
....................     data2 = *(((unsigned int8 *)(&y))+2); 
1F88:  MOV     #B92,W0
1F8A:  MOV     B9A,W4
1F8C:  MOV.B   [W0+#0],W4L
1F8E:  MOV     W4,B9A
1F90:  CLR.B   B9B
....................     rotate_left(&data1,1); 
1F92:  MOV     #B98,W1
1F94:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7)) 
1F96:  BTSS.B  B9A.7
1F98:  BRA     1F9C
....................        bit_set(data1,0);     
1F9A:  BSET.B  B98.0
....................     data1--; 
1F9C:  DEC     0B98
....................     bit_clear(data2,7); 
1F9E:  BCLR.B  B9A.7
....................     if(bit_test(data1,0)) 
1FA0:  BTSS.B  B98.0
1FA2:  BRA     1FA6
....................        bit_set(data2,7); 
1FA4:  BSET.B  B9A.7
....................     data1 = data1 >>1; 
1FA6:  LSR     B98
....................     *(((unsigned int8 *)(&y))+3) = data1; 
1FA8:  MOV     #B93,W5
1FAA:  MOV     B98,W0
1FAC:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
1FAE:  MOV     #B92,W5
1FB0:  MOV     B9A,W0
1FB2:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................    } while(res != y); 
1FB4:  MOV     B94,W0
1FB6:  MOV     B96,W1
1FB8:  MOV     B90,W2
1FBA:  MOV     B92,W3
1FBC:  CALL    1BCA
1FC0:  BRA     NZ,1F58
....................  
....................    return(res); 
1FC2:  MOV     B94,W0
1FC4:  MOV     B96,W1
1FC6:  MOV     [--W15],W5
1FC8:  RETURN  
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
1D5C:  MOV     W5,[W15++]
1D5E:  MOV     W6,[W15++]
1D60:  CLR     BA6
1D62:  MOV     #3F80,W4
1D64:  MOV     W4,BA8
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
1D66:  CLR     BAE
1D68:  MOV     #BF00,W4
1D6A:  MOV     W4,BB0
1D6C:  MOV     #AAA3,W4
1D6E:  MOV     W4,BB2
1D70:  MOV     #3D2A,W4
1D72:  MOV     W4,BB4
1D74:  MOV     #9B4,W4
1D76:  MOV     W4,BB6
1D78:  MOV     #BAB6,W4
1D7A:  MOV     W4,BB8
1D7C:  MOV     #B6AA,W4
1D7E:  MOV     W4,BBA
1D80:  MOV     #37CF,W4
1D82:  MOV     W4,BBC
1D84:  MOV     #F6E8,W4
1D86:  MOV     W4,BBE
1D88:  MOV     #B48B,W4
1D8A:  MOV     W4,BC0
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
1D8C:  MOV     B98,W0
1D8E:  MOV     B9A,W1
1D90:  MOV     #0,W2
1D92:  MOV     #0,W3
1D94:  CALL    1BCA
1D98:  BRA     NC,1DA4
1D9A:  MOV     #B98,W0
1D9C:  MOV     #B98,W1
1D9E:  REPEAT  #3
1DA0:  MOV     [W0++],[W1++]
1DA2:  BTG.B   B9B.7
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
1DA4:  MOV     B98,W0
1DA6:  MOV     B9A,W1
1DA8:  MOV     #F983,W2
1DAA:  MOV     #3F22,W3
1DAC:  CALL    1C32
1DB0:  CALL    1CF6
1DB4:  MOV.B   W0L,B9C
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
1DB6:  MOV     B98,W0
1DB8:  MOV     B9A,W1
1DBA:  MOV     #F983,W2
1DBC:  MOV     #3F22,W3
1DBE:  CALL    1C32
1DC2:  MOV     W0,W5
1DC4:  MOV     W1,W6
1DC6:  MOV.B   B9C,W0L
1DC8:  CLR.B   1
1DCA:  CALL    1D22
1DCE:  BSET.B  43.0
1DD0:  MOV     W0,W2
1DD2:  MOV     W1,W3
1DD4:  MOV     W5,W0
1DD6:  MOV     W6,W1
1DD8:  CALL    1A20
1DDC:  MOV     W0,BAA
1DDE:  MOV     W1,BAC
....................    quad = quad % 4;                    // quadrant (0 to 3) 
1DE0:  MOV.B   B9C,W0L
1DE2:  AND.B   W0L,#3,W0L
1DE4:  MOV.B   W0L,B9C
....................  
....................    if (quad == 0 || quad == 2) 
1DE6:  CP0.B   B9C
1DE8:  BRA     Z,1DF0
1DEA:  MOV     B9C,W4
1DEC:  CP.B    W4L,#2
1DEE:  BRA     NZ,1E02
....................       t = frac * PI_DIV_BY_TWO; 
1DF0:  MOV     BAA,W0
1DF2:  MOV     BAC,W1
1DF4:  MOV     #FDB,W2
1DF6:  MOV     #3FC9,W3
1DF8:  CALL    1C32
1DFC:  MOV     W0,BA2
1DFE:  MOV     W1,BA4
1E00:  BRA     1E4E
....................    else if (quad == 1) 
1E02:  MOV     B9C,W4
1E04:  CP.B    W4L,#1
1E06:  BRA     NZ,1E2C
....................       t = (1-frac) * PI_DIV_BY_TWO; 
1E08:  BSET.B  43.0
1E0A:  MOV     #0,W0
1E0C:  MOV     #3F80,W1
1E0E:  MOV     BAA,W2
1E10:  MOV     BAC,W3
1E12:  CALL    1A20
1E16:  MOV     W0,W5
1E18:  MOV     W1,W6
1E1A:  MOV     W5,W0
1E1C:  MOV     W6,W1
1E1E:  MOV     #FDB,W2
1E20:  MOV     #3FC9,W3
1E22:  CALL    1C32
1E26:  MOV     W0,BA2
1E28:  MOV     W1,BA4
1E2A:  BRA     1E4E
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
1E2C:  BSET.B  43.0
1E2E:  MOV     BAA,W0
1E30:  MOV     BAC,W1
1E32:  MOV     #0,W2
1E34:  MOV     #3F80,W3
1E36:  CALL    1A20
1E3A:  MOV     W0,W5
1E3C:  MOV     W1,W6
1E3E:  MOV     W5,W0
1E40:  MOV     W6,W1
1E42:  MOV     #FDB,W2
1E44:  MOV     #3FC9,W3
1E46:  CALL    1C32
1E4A:  MOV     W0,BA2
1E4C:  MOV     W1,BA4
....................  
....................    y = 1.0; 
1E4E:  CLR     B9E
1E50:  MOV     #3F80,W4
1E52:  MOV     W4,BA0
....................    t = t * t; 
1E54:  MOV     BA2,W0
1E56:  MOV     BA4,W1
1E58:  MOV     BA2,W2
1E5A:  MOV     BA4,W3
1E5C:  CALL    1C32
1E60:  MOV     W0,BA2
1E62:  MOV     W1,BA4
....................    for (i = 0; i <= 4; i++) 
1E64:  CLR.B   B9D
1E66:  MOV     B9C,W4
1E68:  LSR     W4,#8,W4
1E6A:  CP.B    W4L,#4
1E6C:  BRA     GTU,1EB0
....................    { 
....................       t2 = t2 * t; 
1E6E:  MOV     BA6,W0
1E70:  MOV     BA8,W1
1E72:  MOV     BA2,W2
1E74:  MOV     BA4,W3
1E76:  CALL    1C32
1E7A:  MOV     W0,BA6
1E7C:  MOV     W1,BA8
....................       y = y + p[i] * t2; 
1E7E:  MOV.B   B9D,W0L
1E80:  CLR.B   1
1E82:  SL      W0,#2,W0
1E84:  MOV     #BAE,W4
1E86:  ADD     W0,W4,W0
1E88:  MOV     #A,W4
1E8A:  MOV     [W0++],[W4++]
1E8C:  MOV     [W0++],[W4++]
1E8E:  MOV     W5,W0
1E90:  MOV     W6,W1
1E92:  MOV     BA6,W2
1E94:  MOV     BA8,W3
1E96:  CALL    1C32
1E9A:  BCLR.B  43.0
1E9C:  MOV     W0,W2
1E9E:  MOV     W1,W3
1EA0:  MOV     B9E,W0
1EA2:  MOV     BA0,W1
1EA4:  CALL    1A20
1EA8:  MOV     W0,B9E
1EAA:  MOV     W1,BA0
1EAC:  INC.B   0B9D
1EAE:  BRA     1E66
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
1EB0:  MOV     B9C,W4
1EB2:  CP.B    W4L,#2
1EB4:  BRA     Z,1EBC
1EB6:  MOV     B9C,W4
1EB8:  CP.B    W4L,#1
1EBA:  BRA     NZ,1EC6
....................       y = -y;  // correct sign 
1EBC:  MOV     #B9E,W0
1EBE:  MOV     #B9E,W1
1EC0:  REPEAT  #3
1EC2:  MOV     [W0++],[W1++]
1EC4:  BTG.B   BA1.7
....................  
....................    return (y); 
1EC6:  MOV     B9E,W0
1EC8:  MOV     BA0,W1
1ECA:  MOV     [--W15],W6
1ECC:  MOV     [--W15],W5
1ECE:  RETURN  
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
1ED0:  MOV     W5,[W15++]
1ED2:  MOV     W6,[W15++]
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
1ED4:  BSET.B  43.0
1ED6:  MOV     B90,W0
1ED8:  MOV     B92,W1
1EDA:  MOV     #FDB,W2
1EDC:  MOV     #3FC9,W3
1EDE:  CALL    1A20
1EE2:  MOV     W0,W5
1EE4:  MOV     W1,W6
1EE6:  MOV     W5,B98
1EE8:  MOV     W6,B9A
1EEA:  CALL    1D5C
1EEE:  MOV.D   W0,W0
1EF0:  MOV     [--W15],W6
1EF2:  MOV     [--W15],W5
1EF4:  RETURN  
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
*
1FCA:  MOV     W5,[W15++]
1FCC:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
1FCE:  BCLR.B  B9E.0
....................    flag = 0; 
1FD0:  BCLR.B  B9E.1
....................    y = x; 
1FD2:  PUSH    B9A
1FD4:  POP     BA0
1FD6:  PUSH    B9C
1FD8:  POP     BA2
....................  
....................    if (x < 0) 
1FDA:  MOV     B9A,W0
1FDC:  MOV     B9C,W1
1FDE:  MOV     #0,W2
1FE0:  MOV     #0,W3
1FE2:  CALL    1BCA
1FE6:  BRA     NC,1FF4
....................    { 
....................       s = 1; 
1FE8:  BSET.B  B9E.0
....................       y = -y; 
1FEA:  MOV     #BA0,W0
1FEC:  MOV     #BA0,W1
1FEE:  REPEAT  #3
1FF0:  MOV     [W0++],[W1++]
1FF2:  BTG.B   BA3.7
....................    } 
....................  
....................    if (y > 1.0) 
1FF4:  MOV     #0,W0
1FF6:  MOV     #3F80,W1
1FF8:  MOV     BA0,W2
1FFA:  MOV     BA2,W3
1FFC:  CALL    1BCA
2000:  BRA     NC,2014
....................    { 
....................       y = 1.0/y; 
2002:  MOV     #0,W0
2004:  MOV     #3F80,W1
2006:  MOV     BA0,W2
2008:  MOV     BA2,W3
200A:  CALL    1956
200E:  MOV     W0,BA0
2010:  MOV     W1,BA2
....................       flag = 1; 
2012:  BSET.B  B9E.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
2014:  MOV     #890A,W0
2016:  MOV     #3E34,W1
2018:  MOV     BA0,W2
201A:  MOV     BA2,W3
201C:  CALL    1C32
2020:  MOV     W0,W5
2022:  MOV     W1,W6
2024:  MOV     W5,W0
2026:  MOV     W6,W1
2028:  MOV     BA0,W2
202A:  MOV     BA2,W3
202C:  CALL    1C32
2030:  MOV     W0,W5
2032:  MOV     W1,W6
2034:  BCLR.B  43.0
2036:  MOV     W5,W0
2038:  MOV     W6,W1
203A:  MOV     #797C,W2
203C:  MOV     #40B5,W3
203E:  CALL    1A20
2042:  MOV     W0,BA4
2044:  MOV     W1,BA6
....................    res = res*y*y + pat[2]; 
2046:  MOV     BA4,W0
2048:  MOV     BA6,W1
204A:  MOV     BA0,W2
204C:  MOV     BA2,W3
204E:  CALL    1C32
2052:  MOV     W0,W5
2054:  MOV     W1,W6
2056:  MOV     W5,W0
2058:  MOV     W6,W1
205A:  MOV     BA0,W2
205C:  MOV     BA2,W3
205E:  CALL    1C32
2062:  MOV     W0,W5
2064:  MOV     W1,W6
2066:  BCLR.B  43.0
2068:  MOV     W5,W0
206A:  MOV     W6,W1
206C:  MOV     #23F,W2
206E:  MOV     #41B3,W3
2070:  CALL    1A20
2074:  MOV     W0,BA4
2076:  MOV     W1,BA6
....................    res = res*y*y + pat[3]; 
2078:  MOV     BA4,W0
207A:  MOV     BA6,W1
207C:  MOV     BA0,W2
207E:  MOV     BA2,W3
2080:  CALL    1C32
2084:  MOV     W0,W5
2086:  MOV     W1,W6
2088:  MOV     W5,W0
208A:  MOV     W6,W1
208C:  MOV     BA0,W2
208E:  MOV     BA2,W3
2090:  CALL    1C32
2094:  MOV     W0,W5
2096:  MOV     W1,W6
2098:  BCLR.B  43.0
209A:  MOV     W5,W0
209C:  MOV     W6,W1
209E:  MOV     #8C33,W2
20A0:  MOV     #419E,W3
20A2:  CALL    1A20
20A6:  MOV     W0,BA4
20A8:  MOV     W1,BA6
....................  
....................    r = qat[0]*y*y + qat[1]; 
20AA:  MOV     #0,W0
20AC:  MOV     #3F80,W1
20AE:  MOV     BA0,W2
20B0:  MOV     BA2,W3
20B2:  CALL    1C32
20B6:  MOV     W0,W5
20B8:  MOV     W1,W6
20BA:  MOV     W5,W0
20BC:  MOV     W6,W1
20BE:  MOV     BA0,W2
20C0:  MOV     BA2,W3
20C2:  CALL    1C32
20C6:  MOV     W0,W5
20C8:  MOV     W1,W6
20CA:  BCLR.B  43.0
20CC:  MOV     W5,W0
20CE:  MOV     W6,W1
20D0:  MOV     #E41B,W2
20D2:  MOV     #4135,W3
20D4:  CALL    1A20
20D8:  MOV     W0,BA8
20DA:  MOV     W1,BAA
....................    r = r*y*y + qat[2]; 
20DC:  MOV     BA8,W0
20DE:  MOV     BAA,W1
20E0:  MOV     BA0,W2
20E2:  MOV     BA2,W3
20E4:  CALL    1C32
20E8:  MOV     W0,W5
20EA:  MOV     W1,W6
20EC:  MOV     W5,W0
20EE:  MOV     W6,W1
20F0:  MOV     BA0,W2
20F2:  MOV     BA2,W3
20F4:  CALL    1C32
20F8:  MOV     W0,W5
20FA:  MOV     W1,W6
20FC:  BCLR.B  43.0
20FE:  MOV     W5,W0
2100:  MOV     W6,W1
2102:  MOV     #DBA4,W2
2104:  MOV     #41E7,W3
2106:  CALL    1A20
210A:  MOV     W0,BA8
210C:  MOV     W1,BAA
....................    r = r*y*y + qat[3]; 
210E:  MOV     BA8,W0
2110:  MOV     BAA,W1
2112:  MOV     BA0,W2
2114:  MOV     BA2,W3
2116:  CALL    1C32
211A:  MOV     W0,W5
211C:  MOV     W1,W6
211E:  MOV     W5,W0
2120:  MOV     W6,W1
2122:  MOV     BA0,W2
2124:  MOV     BA2,W3
2126:  CALL    1C32
212A:  MOV     W0,W5
212C:  MOV     W1,W6
212E:  BCLR.B  43.0
2130:  MOV     W5,W0
2132:  MOV     W6,W1
2134:  MOV     #8C33,W2
2136:  MOV     #419E,W3
2138:  CALL    1A20
213C:  MOV     W0,BA8
213E:  MOV     W1,BAA
....................  
....................    res = y*res/r; 
2140:  MOV     BA0,W0
2142:  MOV     BA2,W1
2144:  MOV     BA4,W2
2146:  MOV     BA6,W3
2148:  CALL    1C32
214C:  MOV     W0,W5
214E:  MOV     W1,W6
2150:  MOV     W5,W0
2152:  MOV     W6,W1
2154:  MOV     BA8,W2
2156:  MOV     BAA,W3
2158:  CALL    1956
215C:  MOV     W0,BA4
215E:  MOV     W1,BA6
....................  
....................  
....................    if (flag)                              // for |x| > 1 
2160:  BTSS.B  B9E.1
2162:  BRA     2176
....................       res = PI_DIV_BY_TWO - res; 
2164:  BSET.B  43.0
2166:  MOV     #FDB,W0
2168:  MOV     #3FC9,W1
216A:  MOV     BA4,W2
216C:  MOV     BA6,W3
216E:  CALL    1A20
2172:  MOV     W0,BA4
2174:  MOV     W1,BA6
....................    if (s) 
2176:  BTSS.B  B9E.0
2178:  BRA     2184
....................       res = -res; 
217A:  MOV     #BA4,W0
217C:  MOV     #BA4,W1
217E:  REPEAT  #3
2180:  MOV     [W0++],[W1++]
2182:  BTG.B   BA7.7
....................  
....................    return(res); 
2184:  MOV     BA4,W0
2186:  MOV     BA6,W1
2188:  MOV     [--W15],W6
218A:  MOV     [--W15],W5
218C:  RETURN  
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
218E:  MOV     W5,[W15++]
2190:  MOV     W6,[W15++]
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
2192:  BCLR.B  B94.0
....................    quad=0; //quadrant 
2194:  CLR.B   B95
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
2196:  MOV     B8C,W0
2198:  MOV     B8E,W1
219A:  MOV     #0,W2
219C:  MOV     #0,W3
219E:  CALL    1BCA
21A2:  BRA     C,21A6
21A4:  BRA     NZ,21BE
21A6:  MOV     B90,W0
21A8:  MOV     B92,W1
21AA:  MOV     #0,W2
21AC:  MOV     #0,W3
21AE:  CALL    1BCA
21B2:  BRA     C,21B6
21B4:  BRA     NZ,21BA
21B6:  MOV.B   #3,W0L
21B8:  BRA     21BC
21BA:  MOV.B   #4,W0L
21BC:  BRA     21D2
21BE:  MOV     B90,W0
21C0:  MOV     B92,W1
21C2:  MOV     #0,W2
21C4:  MOV     #0,W3
21C6:  CALL    1BCA
21CA:  BRA     NC,21D0
21CC:  MOV.B   #2,W0L
21CE:  BRA     21D2
21D0:  MOV.B   #1,W0L
21D2:  MOV.B   W0L,B95
....................    if(y<0.0) 
21D4:  MOV     B8C,W0
21D6:  MOV     B8E,W1
21D8:  MOV     #0,W2
21DA:  MOV     #0,W3
21DC:  CALL    1BCA
21E0:  BRA     NC,21EE
....................    { 
....................       sign=1; 
21E2:  BSET.B  B94.0
....................       y=-y; 
21E4:  MOV     #B8C,W0
21E6:  MOV     #B8C,W1
21E8:  REPEAT  #3
21EA:  MOV     [W0++],[W1++]
21EC:  BTG.B   B8F.7
....................    } 
....................    if(x<0.0) 
21EE:  MOV     B90,W0
21F0:  MOV     B92,W1
21F2:  MOV     #0,W2
21F4:  MOV     #0,W3
21F6:  CALL    1BCA
21FA:  BRA     NC,2206
....................    { 
....................       x=-x; 
21FC:  MOV     #B90,W0
21FE:  MOV     #B90,W1
2200:  REPEAT  #3
2202:  MOV     [W0++],[W1++]
2204:  BTG.B   B93.7
....................    } 
....................    if (x==0.0) 
2206:  MOV     B90,W0
2208:  MOV     B92,W1
220A:  MOV     #0,W2
220C:  MOV     #0,W3
220E:  CALL    1BCA
2212:  BRA     NZ,2238
....................    { 
....................       if(y==0.0) 
2214:  MOV     B8C,W0
2216:  MOV     B8E,W1
2218:  MOV     #0,W2
221A:  MOV     #0,W3
221C:  CALL    1BCA
2220:  BRA     NZ,2224
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
2222:  BRA     2236
....................       else 
....................       { 
....................          if(sign) 
2224:  BTSS.B  B94.0
2226:  BRA     2230
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
2228:  MOV     #FDB,W0
222A:  MOV     #BFC9,W1
222C:  BRA     22CA
....................          } 
222E:  BRA     2236
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
2230:  MOV     #FDB,W0
2232:  MOV     #3FC9,W1
2234:  BRA     22CA
....................          } 
....................       } 
....................    } 
2236:  BRA     22CA
....................    else 
....................    { 
....................       z=y/x; 
2238:  MOV     B8C,W0
223A:  MOV     B8E,W1
223C:  MOV     B90,W2
223E:  MOV     B92,W3
2240:  CALL    1956
2244:  MOV     W0,B96
2246:  MOV     W1,B98
....................       switch(quad) 
2248:  MOV.B   B95,W0L
224A:  CLR.B   1
224C:  XOR     #1,W0
224E:  BRA     Z,225E
2250:  XOR     #3,W0
2252:  BRA     Z,2270
2254:  XOR     #1,W0
2256:  BRA     Z,2290
2258:  XOR     #7,W0
225A:  BRA     Z,22B4
225C:  BRA     22CA
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
225E:  PUSH    B96
2260:  POP     B9A
2262:  PUSH    B98
2264:  POP     B9C
2266:  CALL    1FCA
226A:  MOV.D   W0,W0
226C:  BRA     22CA
....................             break; 
226E:  BRA     22CA
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
2270:  PUSH    B96
2272:  POP     B9A
2274:  PUSH    B98
2276:  POP     B9C
2278:  CALL    1FCA
227C:  BSET.B  43.0
227E:  MOV     W0,W2
2280:  MOV     W1,W3
2282:  MOV     #FDB,W0
2284:  MOV     #4049,W1
2286:  CALL    1A20
228A:  MOV.D   W0,W0
228C:  BRA     22CA
....................             break; 
228E:  BRA     22CA
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
2290:  PUSH    B96
2292:  POP     B9A
2294:  PUSH    B98
2296:  POP     B9C
2298:  CALL    1FCA
229C:  MOV     W0,W5
229E:  MOV     W1,W6
22A0:  BSET.B  43.0
22A2:  MOV     W5,W0
22A4:  MOV     W6,W1
22A6:  MOV     #FDB,W2
22A8:  MOV     #4049,W3
22AA:  CALL    1A20
22AE:  MOV.D   W0,W0
22B0:  BRA     22CA
....................             break; 
22B2:  BRA     22CA
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
22B4:  PUSH    B96
22B6:  POP     B9A
22B8:  PUSH    B98
22BA:  POP     B9C
22BC:  CALL    1FCA
22C0:  MOV.D   W0,W0
22C2:  BTG     W1.F
22C4:  MOV.D   W0,W0
22C6:  BRA     22CA
....................             break; 
22C8:  BRA     22CA
....................          } 
....................       } 
....................    } 
22CA:  MOV     [--W15],W6
22CC:  MOV     [--W15],W5
22CE:  RETURN  
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
*
1578:  MOV     W5,[W15++]
157A:  MOV     W6,[W15++]
157C:  MOV     W7,[W15++]
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
157E:  CLR     B68
....................    sign = 0; 
1580:  CLR     B64
....................    base = 10; 
1582:  MOV     #A,W4
1584:  MOV     W4,B66
....................    result = 0; 
1586:  CLR     B60
1588:  CLR     B62
....................  
....................    if (!s) 
158A:  CP0     B5C
158C:  BRA     NZ,1594
....................       return 0; 
158E:  MOV     #0,W0
1590:  MOV     #0,W1
1592:  BRA     175A
....................    c = s[index++]; 
1594:  MOV     B68,W0
1596:  INC     0B68
1598:  MOV     W0,W5
159A:  MOV     W5,W0
159C:  ADD     B5C,W0
159E:  MOV     B5E,W4
15A0:  MOV.B   [W0+#0],W4L
15A2:  MOV     W4,B5E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
15A4:  MOV     B5E,W4
15A6:  XOR.B   #2D,W4L
15A8:  BRA     NZ,15C0
....................    { 
....................       sign = 1;         // Set the sign to negative 
15AA:  MOV     #1,W4
15AC:  MOV     W4,B64
....................       c = s[index++]; 
15AE:  MOV     B68,W0
15B0:  INC     0B68
15B2:  MOV     W0,W5
15B4:  MOV     W5,W0
15B6:  ADD     B5C,W0
15B8:  MOV     B5E,W4
15BA:  MOV.B   [W0+#0],W4L
15BC:  MOV     W4,B5E
....................    } 
15BE:  BRA     15D6
....................    else if (c == '+') 
15C0:  MOV     B5E,W4
15C2:  XOR.B   #2B,W4L
15C4:  BRA     NZ,15D6
....................    { 
....................       c = s[index++]; 
15C6:  MOV     B68,W0
15C8:  INC     0B68
15CA:  MOV     W0,W5
15CC:  MOV     W5,W0
15CE:  ADD     B5C,W0
15D0:  MOV     B5E,W4
15D2:  MOV.B   [W0+#0],W4L
15D4:  MOV     W4,B5E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
15D6:  MOV     B5E,W4
15D8:  MOV     #30,W3
15DA:  CP.B    W3L,W4L
15DC:  BRA     GT,173A
15DE:  MOV     B5E,W4
15E0:  MOV     #39,W3
15E2:  CP.B    W3L,W4L
15E4:  BRA     LT,173A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
15E6:  MOV     B5E,W4
15E8:  XOR.B   #30,W4L
15EA:  BRA     NZ,1616
15EC:  MOV     B68,W0
15EE:  ADD     B5C,W0
15F0:  MOV.B   [W0],W4L
15F2:  XOR.B   #78,W4L
15F4:  BRA     Z,1600
15F6:  MOV     B68,W0
15F8:  ADD     B5C,W0
15FA:  MOV.B   [W0],W4L
15FC:  XOR.B   #58,W4L
15FE:  BRA     NZ,1616
....................       { 
....................          base = 16; 
1600:  MOV     #10,W4
1602:  MOV     W4,B66
....................          index++; 
1604:  INC     0B68
....................          c = s[index++]; 
1606:  MOV     B68,W0
1608:  INC     0B68
160A:  MOV     W0,W5
160C:  MOV     W5,W0
160E:  ADD     B5C,W0
1610:  MOV     B5E,W4
1612:  MOV.B   [W0+#0],W4L
1614:  MOV     W4,B5E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1616:  MOV     B66,W4
1618:  CP      W4,#A
161A:  BRA     NZ,1668
....................       { 
....................          while (c >= '0' && c <= '9') 
161C:  MOV     B5E,W4
161E:  MOV     #30,W3
1620:  CP.B    W3L,W4L
1622:  BRA     GT,1666
1624:  MOV     B5E,W4
1626:  MOV     #39,W3
1628:  CP.B    W3L,W4L
162A:  BRA     LT,1666
....................          { 
....................             result = 10*result + (c - '0'); 
162C:  MOV     #A,W0
162E:  MOV     #0,W1
1630:  MOV     B60,W2
1632:  MOV     B62,W3
1634:  CALL    1536
1638:  MOV     W0,W5
163A:  MOV     W1,W6
163C:  MOV     B5E,W4
163E:  SUB.B   #30,W4L
1640:  MOV.B   W4L,W0L
1642:  MOV.B   W0L,0
1644:  SE      W0,W0
1646:  CLR     W1
1648:  BTSC    W0.F
164A:  SETM    W1
164C:  ADD     W0,W5,W0
164E:  MOV     W0,B60
1650:  ADDC    W1,W6,W0
1652:  MOV     W0,B62
....................             c = s[index++]; 
1654:  MOV     B68,W0
1656:  INC     0B68
1658:  MOV     W0,W5
165A:  MOV     W5,W0
165C:  ADD     B5C,W0
165E:  MOV     B5E,W4
1660:  MOV.B   [W0+#0],W4L
1662:  MOV     W4,B5E
1664:  BRA     161C
....................          } 
....................       } 
1666:  BRA     173A
....................       else if (base == 16)    // The number is a hexa number 
1668:  MOV     B66,W4
166A:  CP      W4,#10
166C:  BRA     NZ,173A
....................       { 
....................          c = toupper(c); 
166E:  MOV     B5E,W4
1670:  MOV     #61,W3
1672:  CP.B    W3L,W4L
1674:  BRA     GTU,1684
1676:  MOV     B5E,W4
1678:  MOV     #7A,W3
167A:  CP.B    W3L,W4L
167C:  BRA     NC,1684
167E:  MOV.B   B5E,W0L
1680:  AND.B   #DF,W0L
1682:  BRA     1686
1684:  MOV.B   B5E,W0L
1686:  MOV.B   W0L,B5E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
1688:  MOV     B5E,W4
168A:  MOV     #30,W3
168C:  CP.B    W3L,W4L
168E:  BRA     GT,169A
1690:  MOV     B5E,W4
1692:  MOV     #39,W3
1694:  CP.B    W3L,W4L
1696:  BRA     LT,169A
1698:  BRA     16AA
169A:  MOV     B5E,W4
169C:  MOV     #41,W3
169E:  CP.B    W3L,W4L
16A0:  BRA     GT,173A
16A2:  MOV     B5E,W4
16A4:  MOV     #46,W3
16A6:  CP.B    W3L,W4L
16A8:  BRA     LT,173A
....................          { 
....................             if (c >= '0' && c <= '9') 
16AA:  MOV     B5E,W4
16AC:  MOV     #30,W3
16AE:  CP.B    W3L,W4L
16B0:  BRA     GT,16E6
16B2:  MOV     B5E,W4
16B4:  MOV     #39,W3
16B6:  CP.B    W3L,W4L
16B8:  BRA     LT,16E6
....................                result = (result << 4) + (c - '0'); 
16BA:  MOV     #4,W4
16BC:  MOV     B60,W5
16BE:  MOV     B62,W6
16C0:  INC     W4,W4
16C2:  DEC     W4,W4
16C4:  BRA     Z,16CC
16C6:  SL      W5,W5
16C8:  RLC     W6,W6
16CA:  BRA     16C2
16CC:  MOV     B5E,W4
16CE:  SUB.B   #30,W4L
16D0:  MOV.B   W4L,W0L
16D2:  MOV.B   W0L,0
16D4:  SE      W0,W0
16D6:  CLR     W1
16D8:  BTSC    W0.F
16DA:  SETM    W1
16DC:  ADD     W0,W5,W0
16DE:  MOV     W0,B60
16E0:  ADDC    W1,W6,W0
16E2:  MOV     W0,B62
16E4:  BRA     170E
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
16E6:  MOV     #4,W4
16E8:  MOV     B60,W5
16EA:  MOV     B62,W6
16EC:  INC     W4,W4
16EE:  DEC     W4,W4
16F0:  BRA     Z,16F8
16F2:  SL      W5,W5
16F4:  RLC     W6,W6
16F6:  BRA     16EE
16F8:  MOV     B5E,W4
16FA:  SUB.B   #41,W4L
16FC:  MOV.B   W4L,W0L
16FE:  MOV.B   W0L,0
1700:  ZE      W0,W0
1702:  ADD     W0,#A,W0
1704:  ADD     W0,W5,W0
1706:  MOV     W0,B60
1708:  MOV     #0,W4
170A:  ADDC    W4,W6,W0
170C:  MOV     W0,B62
....................  
....................             c = s[index++];c = toupper(c); 
170E:  MOV     B68,W0
1710:  INC     0B68
1712:  MOV     W0,W5
1714:  MOV     W5,W0
1716:  ADD     B5C,W0
1718:  MOV     B5E,W4
171A:  MOV.B   [W0+#0],W4L
171C:  MOV     W4,B5E
171E:  MOV     B5E,W4
1720:  MOV     #61,W3
1722:  CP.B    W3L,W4L
1724:  BRA     GTU,1734
1726:  MOV     B5E,W4
1728:  MOV     #7A,W3
172A:  CP.B    W3L,W4L
172C:  BRA     NC,1734
172E:  MOV.B   B5E,W0L
1730:  AND.B   #DF,W0L
1732:  BRA     1736
1734:  MOV.B   B5E,W0L
1736:  MOV.B   W0L,B5E
1738:  BRA     1688
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
173A:  MOV     B66,W4
173C:  CP      W4,#A
173E:  BRA     NZ,1756
1740:  MOV     B64,W4
1742:  CP      W4,#1
1744:  BRA     NZ,1756
....................       result = -result; 
1746:  MOV     #0,W4
1748:  MOV     B60,W3
174A:  SUB     W4,W3,W0
174C:  MOV     W0,B60
174E:  MOV     #0,W4
1750:  MOV     B62,W3
1752:  SUBB    W4,W3,W0
1754:  MOV     W0,B62
....................  
....................    return(result); 
1756:  MOV     B60,W0
1758:  MOV     B62,W1
175A:  MOV     [--W15],W7
175C:  MOV     [--W15],W6
175E:  MOV     [--W15],W5
1760:  RETURN  
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
*
10EA:  MOV     W5,[W15++]
10EC:  MOV     W6,[W15++]
10EE:  MOV     W7,[W15++]
10F0:  MOV     W8,[W15++]
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
10F2:  CLR.B   B60
....................    sign = 0; 
10F4:  CLR.B   B5E
....................    base = 10; 
10F6:  MOV.B   #A,W0L
10F8:  MOV.B   W0L,B5F
....................    result = 0; 
10FA:  CLR     B62
10FC:  CLR     B64
10FE:  CLR     B66
....................  
....................    if (!s) 
1100:  CP0     B5C
1102:  BRA     NZ,110C
....................       return 0; 
1104:  MOV     #0,W0
1106:  MOV     #0,W1
1108:  MOV     #0,W2
110A:  BRA     1364
....................    c = s[index++]; 
110C:  MOV.B   B60,W0L
110E:  INC.B   0B60
1110:  SE      W0,W5
1112:  MOV     W5,W0
1114:  ADD     B5C,W0
1116:  MOV     W0,[W15++]
1118:  MOV.B   [W0],W0L
111A:  MOV.B   W0L,B61
111C:  MOV     [--W15],W0
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
111E:  MOV     B60,W4
1120:  LSR     W4,#8,W4
1122:  XOR.B   #2D,W4L
1124:  BRA     NZ,113E
....................    { 
....................       sign = 1;         // Set the sign to negative 
1126:  MOV.B   #1,W0L
1128:  MOV.B   W0L,B5E
....................       c = s[index++]; 
112A:  MOV.B   B60,W0L
112C:  INC.B   0B60
112E:  SE      W0,W5
1130:  MOV     W5,W0
1132:  ADD     B5C,W0
1134:  MOV     W0,[W15++]
1136:  MOV.B   [W0],W0L
1138:  MOV.B   W0L,B61
113A:  MOV     [--W15],W0
....................    } 
113C:  BRA     1158
....................    else if (c == '+') 
113E:  MOV     B60,W4
1140:  LSR     W4,#8,W4
1142:  XOR.B   #2B,W4L
1144:  BRA     NZ,1158
....................    { 
....................       c = s[index++]; 
1146:  MOV.B   B60,W0L
1148:  INC.B   0B60
114A:  SE      W0,W5
114C:  MOV     W5,W0
114E:  ADD     B5C,W0
1150:  MOV     W0,[W15++]
1152:  MOV.B   [W0],W0L
1154:  MOV.B   W0L,B61
1156:  MOV     [--W15],W0
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1158:  MOV     B60,W4
115A:  LSR     W4,#8,W4
115C:  MOV     #30,W3
115E:  CP.B    W3L,W4L
1160:  BRA     GT,1336
1162:  MOV     B60,W4
1164:  LSR     W4,#8,W4
1166:  MOV     #39,W3
1168:  CP.B    W3L,W4L
116A:  BRA     LT,1336
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
116C:  MOV     B60,W4
116E:  LSR     W4,#8,W4
1170:  XOR.B   #30,W4L
1172:  BRA     NZ,11A8
1174:  MOV.B   B60,W0L
1176:  SE      W0,W0
1178:  MOV     B5C,W4
117A:  ADD     W0,W4,W0
117C:  MOV.B   [W0],W4L
117E:  XOR.B   #78,W4L
1180:  BRA     Z,1190
1182:  MOV.B   B60,W0L
1184:  SE      W0,W0
1186:  MOV     B5C,W4
1188:  ADD     W0,W4,W0
118A:  MOV.B   [W0],W4L
118C:  XOR.B   #58,W4L
118E:  BRA     NZ,11A8
....................       { 
....................          base = 16; 
1190:  MOV.B   #10,W0L
1192:  MOV.B   W0L,B5F
....................          index++; 
1194:  INC.B   0B60
....................          c = s[index++]; 
1196:  MOV.B   B60,W0L
1198:  INC.B   0B60
119A:  SE      W0,W5
119C:  MOV     W5,W0
119E:  ADD     B5C,W0
11A0:  MOV     W0,[W15++]
11A2:  MOV.B   [W0],W0L
11A4:  MOV.B   W0L,B61
11A6:  MOV     [--W15],W0
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
11A8:  MOV.B   B5F,W0L
11AA:  SE      W0,W0
11AC:  CP      W0,#A
11AE:  BRA     NZ,1234
....................       { 
....................          while (c >= '0' && c <= '9') { 
11B0:  MOV     B60,W4
11B2:  LSR     W4,#8,W4
11B4:  MOV     #30,W3
11B6:  CP.B    W3L,W4L
11B8:  BRA     GT,1232
11BA:  MOV     B60,W4
11BC:  LSR     W4,#8,W4
11BE:  MOV     #39,W3
11C0:  CP.B    W3L,W4L
11C2:  BRA     LT,1232
....................             result = (result << 1) + (result << 3);  // result *= 10; 
11C4:  MOV     #1,W4
11C6:  MOV     B62,W5
11C8:  MOV     B64,W6
11CA:  MOV     B66,W7
11CC:  INC     W4,W4
11CE:  DEC     W4,W4
11D0:  BRA     Z,11DA
11D2:  SL      W5,W5
11D4:  RLC     W6,W6
11D6:  RLC     W7,W7
11D8:  BRA     11CE
11DA:  MOV     #3,W4
11DC:  MOV     B62,W0
11DE:  MOV     B64,W1
11E0:  MOV     B66,W2
11E2:  INC     W4,W4
11E4:  DEC     W4,W4
11E6:  BRA     Z,11F0
11E8:  SL      W0,W0
11EA:  RLC     W1,W1
11EC:  RLC     W2,W2
11EE:  BRA     11E4
11F0:  ADD     W0,W5,W0
11F2:  MOV     W0,B62
11F4:  ADDC    W1,W6,W0
11F6:  MOV     W0,B64
11F8:  ADDC    W2,W7,W0
11FA:  MOV     W0,B66
....................             result += (c - '0'); 
11FC:  MOV     B60,W4
11FE:  LSR     W4,#8,W4
1200:  SUB.B   #30,W4L
1202:  MOV.B   W4L,W0L
1204:  MOV.B   W0L,0
1206:  SE      W0,W0
1208:  CLR     W2
120A:  BTSC    W0.F
120C:  SETM    W2
120E:  MOV     W2,W1
1210:  ADD     B62
1212:  MOV     B64,W4
1214:  ADDC    W1,W4,W0
1216:  MOV     W0,B64
1218:  MOV     B66,W4
121A:  ADDC    W2,W4,W0
121C:  MOV     W0,B66
....................             c = s[index++]; 
121E:  MOV.B   B60,W0L
1220:  INC.B   0B60
1222:  SE      W0,W5
1224:  MOV     W5,W0
1226:  ADD     B5C,W0
1228:  MOV     W0,[W15++]
122A:  MOV.B   [W0],W0L
122C:  MOV.B   W0L,B61
122E:  MOV     [--W15],W0
1230:  BRA     11B0
....................          } 
....................       } 
1232:  BRA     1336
....................       else if (base == 16)    // The number is a hexa number 
1234:  MOV.B   B5F,W0L
1236:  SE      W0,W0
1238:  CP      W0,#10
123A:  BRA     NZ,1336
....................       { 
....................          c = toupper(c); 
123C:  MOV     B60,W4
123E:  LSR     W4,#8,W4
1240:  MOV     #61,W3
1242:  CP.B    W3L,W4L
1244:  BRA     GTU,1256
1246:  MOV     B60,W4
1248:  LSR     W4,#8,W4
124A:  MOV     #7A,W3
124C:  CP.B    W3L,W4L
124E:  BRA     NC,1256
1250:  MOV.B   B61,W0L
1252:  AND.B   #DF,W0L
1254:  BRA     1258
1256:  MOV.B   B61,W0L
1258:  MOV.B   W0L,B61
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
125A:  MOV     B60,W4
125C:  LSR     W4,#8,W4
125E:  MOV     #30,W3
1260:  CP.B    W3L,W4L
1262:  BRA     GT,1270
1264:  MOV     B60,W4
1266:  LSR     W4,#8,W4
1268:  MOV     #39,W3
126A:  CP.B    W3L,W4L
126C:  BRA     LT,1270
126E:  BRA     1284
1270:  MOV     B60,W4
1272:  LSR     W4,#8,W4
1274:  MOV     #41,W3
1276:  CP.B    W3L,W4L
1278:  BRA     GT,1336
127A:  MOV     B60,W4
127C:  LSR     W4,#8,W4
127E:  MOV     #46,W3
1280:  CP.B    W3L,W4L
1282:  BRA     LT,1336
....................          { 
....................             if (c >= '0' && c <= '9') 
1284:  MOV     B60,W4
1286:  LSR     W4,#8,W4
1288:  MOV     #30,W3
128A:  CP.B    W3L,W4L
128C:  BRA     GT,12D0
128E:  MOV     B60,W4
1290:  LSR     W4,#8,W4
1292:  MOV     #39,W3
1294:  CP.B    W3L,W4L
1296:  BRA     LT,12D0
....................                result = (result << 4) + (c - '0'); 
1298:  MOV     #4,W4
129A:  MOV     B62,W5
129C:  MOV     B64,W6
129E:  MOV     B66,W7
12A0:  INC     W4,W4
12A2:  DEC     W4,W4
12A4:  BRA     Z,12AE
12A6:  SL      W5,W5
12A8:  RLC     W6,W6
12AA:  RLC     W7,W7
12AC:  BRA     12A2
12AE:  MOV     B60,W4
12B0:  LSR     W4,#8,W4
12B2:  SUB.B   #30,W4L
12B4:  MOV.B   W4L,W0L
12B6:  MOV.B   W0L,0
12B8:  SE      W0,W0
12BA:  CLR     W2
12BC:  BTSC    W0.F
12BE:  SETM    W2
12C0:  MOV     W2,W1
12C2:  ADD     W0,W5,W0
12C4:  MOV     W0,B62
12C6:  ADDC    W1,W6,W0
12C8:  MOV     W0,B64
12CA:  ADDC    W2,W7,W0
12CC:  MOV     W0,B66
12CE:  BRA     1304
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
12D0:  MOV     #4,W4
12D2:  MOV     B62,W5
12D4:  MOV     B64,W6
12D6:  MOV     B66,W7
12D8:  INC     W4,W4
12DA:  DEC     W4,W4
12DC:  BRA     Z,12E6
12DE:  SL      W5,W5
12E0:  RLC     W6,W6
12E2:  RLC     W7,W7
12E4:  BRA     12DA
12E6:  MOV     B60,W4
12E8:  LSR     W4,#8,W4
12EA:  SUB.B   #41,W4L
12EC:  MOV.B   W4L,W0L
12EE:  MOV.B   W0L,0
12F0:  ZE      W0,W0
12F2:  ADD     W0,#A,W0
12F4:  ADD     W0,W5,W0
12F6:  MOV     W0,B62
12F8:  MOV     #0,W4
12FA:  ADDC    W4,W6,W0
12FC:  MOV     W0,B64
12FE:  MOV     #0,W4
1300:  ADDC    W4,W7,W0
1302:  MOV     W0,B66
....................  
....................             c = s[index++];c = toupper(c); 
1304:  MOV.B   B60,W0L
1306:  INC.B   0B60
1308:  SE      W0,W5
130A:  MOV     W5,W0
130C:  ADD     B5C,W0
130E:  MOV     W0,[W15++]
1310:  MOV.B   [W0],W0L
1312:  MOV.B   W0L,B61
1314:  MOV     [--W15],W0
1316:  MOV     B60,W4
1318:  LSR     W4,#8,W4
131A:  MOV     #61,W3
131C:  CP.B    W3L,W4L
131E:  BRA     GTU,1330
1320:  MOV     B60,W4
1322:  LSR     W4,#8,W4
1324:  MOV     #7A,W3
1326:  CP.B    W3L,W4L
1328:  BRA     NC,1330
132A:  MOV.B   B61,W0L
132C:  AND.B   #DF,W0L
132E:  BRA     1332
1330:  MOV.B   B61,W0L
1332:  MOV.B   W0L,B61
1334:  BRA     125A
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1336:  MOV.B   B5F,W0L
1338:  SE      W0,W0
133A:  CP      W0,#A
133C:  BRA     NZ,135E
133E:  MOV.B   B5E,W0L
1340:  SE      W0,W0
1342:  CP      W0,#1
1344:  BRA     NZ,135E
....................       result = -result; 
1346:  MOV     #0,W4
1348:  MOV     B62,W3
134A:  SUB     W4,W3,W0
134C:  MOV     W0,B62
134E:  MOV     #0,W4
1350:  MOV     B64,W3
1352:  SUBB    W4,W3,W0
1354:  MOV     W0,B64
1356:  MOV     #0,W4
1358:  MOV     B66,W3
135A:  SUBB    W4,W3,W0
135C:  MOV     W0,B66
....................  
....................    return(result); 
135E:  MOV     B62,W0
1360:  MOV     B64,W1
1362:  MOV     B66,W2
1364:  MOV     [--W15],W8
1366:  MOV     [--W15],W7
1368:  MOV     [--W15],W6
136A:  MOV     [--W15],W5
136C:  RETURN  
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
*
0F46:  MOV     W5,[W15++]
0F48:  MOV     W6,[W15++]
0F4A:  MOV     W7,[W15++]
0F4C:  CLR     B64
0F4E:  CLR     B66
0F50:  MOV     #3F80,W4
0F52:  MOV     W4,B68
0F54:  CLR     B6A
0F56:  CLR     B6C
0F58:  CLR     B6E
0F5A:  BSET.B  B60.0
0F5C:  BCLR.B  B60.1
0F5E:  BCLR.B  B60.2
0F60:  CLR.B   B62
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0F62:  CP0     B5C
0F64:  BRA     NZ,F6E
....................       return 0; 
0F66:  MOV     #0,W0
0F68:  MOV     #0,W1
0F6A:  MOV     #0,W2
0F6C:  BRA     10E2
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0F6E:  MOV.B   B62,W0L
0F70:  INC.B   0B62
0F72:  ZE      W0,W0
0F74:  MOV     B5C,W4
0F76:  ADD     W0,W4,W0
0F78:  MOV     W0,[W15++]
0F7A:  MOV.B   [W0],W0L
0F7C:  MOV.B   W0L,B61
0F7E:  MOV     [--W15],W0
0F80:  MOV.B   B61,W0L
0F82:  SE      W0,W0
0F84:  CP0     W0
0F86:  BRA     Z,10A6
....................    { 
....................       if (skip && !isspace(c)) 
0F88:  BTSS.B  B60.0
0F8A:  BRA     FB0
0F8C:  MOV     B60,W4
0F8E:  LSR     W4,#8,W4
0F90:  XOR.B   #20,W4L
0F92:  BRA     Z,FB0
....................       { 
....................          skip = 0; 
0F94:  BCLR.B  B60.0
....................          if (c == '+') 
0F96:  MOV     B60,W4
0F98:  LSR     W4,#8,W4
0F9A:  XOR.B   #2B,W4L
0F9C:  BRA     NZ,FA4
....................          { 
....................             sign = 0; 
0F9E:  BCLR.B  B60.1
....................             continue; 
0FA0:  BRA     1092
....................          }             
0FA2:  BRA     FB0
....................          else if (c == '-') 
0FA4:  MOV     B60,W4
0FA6:  LSR     W4,#8,W4
0FA8:  XOR.B   #2D,W4L
0FAA:  BRA     NZ,FB0
....................          { 
....................             sign = 1; 
0FAC:  BSET.B  B60.1
....................             continue; 
0FAE:  BRA     1092
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0FB0:  BTSC.B  B60.0
0FB2:  BRA     FC4
0FB4:  MOV     B60,W4
0FB6:  LSR     W4,#8,W4
0FB8:  XOR.B   #2E,W4L
0FBA:  BRA     NZ,FC4
0FBC:  BTSC.B  B60.2
0FBE:  BRA     FC4
....................          point = 1; 
0FC0:  BSET.B  B60.2
0FC2:  BRA     1092
....................       else if (!skip && isdigit(c)) 
0FC4:  BTSC.B  B60.0
0FC6:  BRA     108C
0FC8:  MOV     B60,W4
0FCA:  LSR     W4,#8,W4
0FCC:  MOV     #30,W3
0FCE:  CP.B    W3L,W4L
0FD0:  BRA     GTU,108C
0FD2:  MOV     B60,W4
0FD4:  LSR     W4,#8,W4
0FD6:  MOV     #39,W3
0FD8:  CP.B    W3L,W4L
0FDA:  BRA     NC,108C
....................       { 
....................          c -= '0'; 
0FDC:  MOV     B60,W4
0FDE:  LSR     W4,#8,W4
0FE0:  SUB.B   #30,W4L
0FE2:  MOV.B   W4L,W0L
0FE4:  MOV.B   W0L,B61
....................          if (point) 
0FE6:  BTSS.B  B60.2
0FE8:  BRA     1046
....................          { 
....................             pow10 = pow10 * 10.0; 
0FEA:  MOV     B64,W0
0FEC:  MOV     B66,W1
0FEE:  MOV     B68,W2
0FF0:  MOV     #0,W3
0FF2:  MOV     #0,W4
0FF4:  MOV     #4120,W5
0FF6:  CALL    B5C
0FFA:  MOV     W0,B64
0FFC:  MOV     W1,B66
0FFE:  MOV     W2,B68
....................             result += (float48)c / pow10;    
1000:  MOV.B   B61,W0L
1002:  SE      W0,W0
1004:  CLR     W3
1006:  BTSC    W0.F
1008:  SETM    W3
100A:  MOV     W3,W1
100C:  MOV     W3,W2
100E:  CALL    C2A
1012:  MOV     W0,W5
1014:  MOV     W1,W6
1016:  MOV     W2,W7
1018:  MOV     W5,[W15++]
101A:  MOV     W5,W0
101C:  MOV     W6,W1
101E:  MOV     W7,W2
1020:  MOV     B64,W3
1022:  MOV     B66,W4
1024:  MOV     B68,W5
1026:  CALL    C94
102A:  MOV     [--W15],W5
102C:  BCLR.B  43.0
102E:  MOV     W0,W3
1030:  MOV     W1,W4
1032:  MOV     W2,W5
1034:  MOV     B6A,W0
1036:  MOV     B6C,W1
1038:  MOV     B6E,W2
103A:  CALL    D6A
103E:  MOV     W0,B6A
1040:  MOV     W1,B6C
1042:  MOV     W2,B6E
....................          } 
1044:  BRA     108A
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
1046:  MOV     #0,W0
1048:  MOV     #0,W1
104A:  MOV     #4120,W2
104C:  MOV     B6A,W3
104E:  MOV     B6C,W4
1050:  MOV     B6E,W5
1052:  CALL    B5C
1056:  MOV     W0,W5
1058:  MOV     W1,W6
105A:  MOV     W2,W7
105C:  MOV.B   B61,W0L
105E:  SE      W0,W0
1060:  CLR     W3
1062:  BTSC    W0.F
1064:  SETM    W3
1066:  MOV     W3,W1
1068:  MOV     W3,W2
106A:  CALL    C2A
106E:  BCLR.B  43.0
1070:  MOV     W5,[W15++]
1072:  MOV     W0,W3
1074:  MOV     W1,W4
1076:  MOV     W5,W0
1078:  MOV     W6,W1
107A:  MOV     W2,W5
107C:  MOV     W7,W2
107E:  CALL    D6A
1082:  MOV     [--W15],W5
1084:  MOV     W0,B6A
1086:  MOV     W1,B6C
1088:  MOV     W2,B6E
....................          } 
....................       } 
108A:  BRA     1092
....................       else if (!skip) 
108C:  BTSC.B  B60.0
108E:  BRA     1092
....................          break; 
1090:  BRA     10A6
1092:  MOV.B   B62,W0L
1094:  INC.B   0B62
1096:  ZE      W0,W0
1098:  MOV     B5C,W4
109A:  ADD     W0,W4,W0
109C:  MOV     W0,[W15++]
109E:  MOV.B   [W0],W0L
10A0:  MOV.B   W0L,B61
10A2:  MOV     [--W15],W0
10A4:  BRA     F80
....................    } 
....................  
....................    if (sign) 
10A6:  BTSS.B  B60.1
10A8:  BRA     10C0
....................       result = -1*result; 
10AA:  MOV     #0,W0
10AC:  MOV     #0,W1
10AE:  MOV     #BF80,W2
10B0:  MOV     B6A,W3
10B2:  MOV     B6C,W4
10B4:  MOV     B6E,W5
10B6:  CALL    B5C
10BA:  MOV     W0,B6A
10BC:  MOV     W1,B6C
10BE:  MOV     W2,B6E
....................        
....................    if(endptr) 
10C0:  CP0     B5E
10C2:  BRA     Z,10DC
....................    { 
....................       if (ptr) { 
10C4:  CP0.B   B62
10C6:  BRA     Z,10D6
....................          ptr--; 
10C8:  DEC.B   0B62
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
10CA:  MOV     B5E,W5
10CC:  MOV     B62,W4
10CE:  CLR.B   9
10D0:  MOV     B5C,W3
10D2:  ADD     W3,W4,[W5]
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
10D4:  BRA     10DC
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
10D6:  MOV     B5E,W5
10D8:  MOV     B5C,W4
10DA:  MOV     W4,[W5+#0]
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
10DC:  MOV     B6A,W0
10DE:  MOV     B6C,W1
10E0:  MOV     B6E,W2
10E2:  MOV     [--W15],W7
10E4:  MOV     [--W15],W6
10E6:  MOV     [--W15],W5
10E8:  RETURN  
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <time.h> 
....................  
.................... #pin_select U1TX=PIN_b14 
.................... #pin_select U1RX=PIN_b15 
.................... #pin_select U2RX=PIN_b5 
.................... #pin_select U2TX=PIN_b4 
....................  
.................... //#use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,stream=GPS,errors) 
.................... //#use rs232(baud=19200,xmit=PIN_B14,rcv=PIN_B15,force_sw,stream=BUG,errors) 
.................... //#use rs232(baud=19200,UART1,stream=GPS,errors) 
.................... #use rs232(baud=57600,UART1,stream=BUG,errors) 
.................... #use rs232(baud=57600,UART2,stream=GSM,errors) 
*
05C2:  BTSS.B  232.0
05C4:  BRA     5C2
05C6:  PUSH    232
05C8:  POP     8BA
05CA:  MOV     236,W0
05CC:  BCLR.B  232.1
05CE:  RETURN  
.................... //#use rs232(baud=9600,xmit=PIN_C2,rcv=PIN_C3,force_sw,stream=GSM,errors) 
....................  
.................... #define GET_GSM_STATUS        fprintf(GSM,"AT+CGREG?%c",enter); 
.................... #define GPS_ON                fprintf(GSM,"AT+CGNSPWR=1%c",enter); 
.................... #define CANCEL_ECHO           fprintf(GSM,"ATE0%c",enter); 
.................... #define START_CIP             fprintf(GSM,"AT+CIPSTART=%cTCP%c,%cwww.gpstraces.com%c,%c80%c%c",set,set,set,set,set,set,enter); 
.................... #define GET_CIP_STATUS        fprintf(GSM,"AT+CIPSTATUS%c",enter);               //119.18.57.60 
.................... #define GET_GPS               fprintf(GSM,"AT+CGNSINF%c",enter); 
.................... #define GET_GPS_STATUS        fprintf(GSM,"AT+CGPSSTATUS?%c",enter); 
.................... #define GPS_REBOOT            fprintf(GSM,"AT+CGNSRST=0%c",enter); 
....................  
.................... //#define ACK_OK "OK"  
.................... //#define ACK_ERROR "ERROR" 
....................  
.................... boolean exception(unsigned char bb,INT8 cc); 
.................... int init_gsm(int dat); 
.................... int init_gsm_1(int dat); 
....................  
.................... int8 cip_start(); 
.................... void cip_send(); 
.................... void cip_send1(); 
.................... void cip_send2(); 
.................... void cip_send3(); 
.................... void cip_close(); 
.................... char timed_getc(); 
....................  
.................... boolean timeout_error=false,timeout_error_2=false,last_a=0,last_a4=0,p_s=0; 
.................... int8 j=0,post_var=0,init_var=0,nd=0; 
.................... unsigned char string2[30]={},v3=0; 
.................... unsigned char string6[30]={}; 
.................... unsigned char num_attempt=0; 
.................... unsigned char set=0x22,enter=0x0d,sent=0x1a,lf=0x0a; 
.................... unsigned char ACK_OK[3]="OK",APN_RE[18]="CSTTairtelgprscom",STATUS_RE[17]="OKSTATEIPINITIAL",STATUS_CON[12]="OKCONNECTOK"; 
.................... unsigned char GSM_STATE[8]="CGREG01",GSM_STATE_R[8]="CGREG05"; 
.................... unsigned char string3[110]={}; 
....................  
.................... char *ptr=0,term[2],*lat=null,*lon=null,*s_time=0,*s_date=0,*s_date1=0,*speed_k; 
.................... char string[20]={}; 
....................  
.................... INT8 buf_var=0,cmp_val,p_status=0,dir=0; 
.................... int8 jl=1,jm=1,p_hrs=5;  
.................... int8 ack_log=0,ack_log1=0,sec; 
.................... int old_min=0,old_sec=0,new_min=0,new_sec=0,date=0,month=0,year=0; 
.................... int v1=0,post_fail_count=0;  
.................... signed int32 yy=0,f_time=0,i_date=0; 
.................... signed int48 s_date_time; 
.................... int32 timeout,timeout_v,timeout_3=0,r_boot=0; 
....................  
.................... float v4=0,v5=0,f_lat=0,f_lon=0,new_hrs=0,old_hrs=null; 
.................... float v6=0,old_la=null,old_ln=null,new_la,new_ln,distt=0,speed=0; 
....................  
.................... struct rtos_stas_struct { 
....................                      unsigned int32 task_total_ticks;   //number of ticks the task has  
....................                                                                                  //used 
....................                      unsigned int16 task_min_ticks;   //the minimum number of ticks  
....................                                                                                  //used 
....................                      unsigned int16 task_max_ticks;  //the maximum number of ticks  
....................                                                                                  //used 
....................                      unsigned int16 hns_per_tick;       //us = (ticks*hns_per_tick)/10 
....................              }stats; 
....................  
.................... int init_gsm_1(int dat) 
.................... { 
....................    switch (dat) 
.................... { 
....................    case 1:  strncpy(string2,ACK_OK,2); 
....................             fprintf(GSM,"A%c",enter); 
....................             if(!exception(2,2)) 
....................             {      
....................                num_attempt+=1; 
....................                if(num_attempt>50){output_high(fet1);reset_cpu();}                
....................                return 0;    
....................                break; 
....................             } 
....................                num_attempt=0; 
....................                timeout_error=FALSE;                 
....................                return 1; 
....................                break; 
....................    case 2:  strncpy(string2,ACK_OK,2); 
....................             fprintf(GSM,"AT+IPR=57600%c",enter); 
....................             if(!exception(2,2)) 
....................             {      
....................                num_attempt+=1; 
....................                if(num_attempt>50){output_high(fet1);reset_cpu();}                
....................                return 0;    
....................                break; 
....................             } 
....................     
....................                num_attempt=0; 
....................                timeout_error=FALSE;                 
....................                return 1; 
....................                break; 
....................                 
....................    default: break;               
....................    } 
.................... } 
....................  
.................... int init_gsm(int dat){  
.................... switch (dat) 
*
075E:  MOV     AC2,W0
0760:  XOR     #1,W0
0762:  BRA     Z,776
0764:  XOR     #3,W0
0766:  BRA     Z,7DE
0768:  XOR     #1,W0
076A:  BRA     Z,85C
076C:  XOR     #7,W0
076E:  BRA     Z,8DC
0770:  XOR     #1,W0
0772:  BRA     Z,95C
0774:  BRA     9DC
.................... { 
....................    case 1:  strncpy(string2,ACK_OK,2);             
0776:  MOV     #8C2,W4
0778:  MOV     W4,C50
077A:  MOV     #904,W4
077C:  MOV     W4,C52
077E:  MOV     #2,W4
0780:  MOV     W4,C54
0782:  CALL    4D4
....................             CANCEL_ECHO 
0786:  MOV     #0,W1
0788:  MOV     W1,W0
078A:  CLR.B   1
078C:  CALL    200
0790:  INC     W1,W1
0792:  BTSC.B  233.1
0794:  BRA     792
0796:  MOV     W0,234
0798:  MOV     #3,W0
079A:  CPSGT   W1,W0
079C:  BRA     788
079E:  BTSC.B  233.1
07A0:  BRA     79E
07A2:  MOV.B   900,W0L
07A4:  MOV.B   W0L,234
07A6:  CLR.B   235
....................             if(!exception(2,2)) 
07A8:  MOV.B   #2,W0L
07AA:  MOV.B   W0L,C50
07AC:  MOV.B   #2,W0L
07AE:  MOV.B   W0L,C51
07B0:  CALL    654
07B4:  CP0.B   W0L
07B6:  BRA     NZ,7D2
....................             {      
....................                num_attempt+=1; 
07B8:  MOV     8FE,W4
07BA:  ADD.B   W4L,#1,W0L
07BC:  MOV.B   W0L,8FE
....................                if(num_attempt>10){output_high(fet1);reset_cpu();}                
07BE:  MOV     8FE,W4
07C0:  CP.B    W4L,#A
07C2:  BRA     LEU,7CC
07C4:  MOV     #FFBF,W4
07C6:  MOV     W4,2C8
07C8:  BSET.B  2CC.6
07CA:  RESET   
....................                return 0;    
07CC:  CLR     0
07CE:  BRA     9DE
....................                break; 
07D0:  BRA     9DE
....................             } 
....................                num_attempt=0; 
07D2:  CLR.B   8FE
....................                timeout_error=FALSE;                 
07D4:  BCLR.B  8BC.0
....................                return 1; 
07D6:  MOV     #1,W4
07D8:  MOV     W4,0
07DA:  BRA     9DE
....................                break; 
07DC:  BRA     9DE
....................                 
....................    case 2: strncpy(string2,GSM_STATE,7); 
07DE:  MOV     #8C2,W4
07E0:  MOV     W4,C50
07E2:  MOV     #938,W4
07E4:  MOV     W4,C52
07E6:  MOV     #7,W4
07E8:  MOV     W4,C54
07EA:  CALL    4D4
....................            strncpy(string6,GSM_STATE_R,7); 
07EE:  MOV     #8E0,W4
07F0:  MOV     W4,C50
07F2:  MOV     #940,W4
07F4:  MOV     W4,C52
07F6:  MOV     #7,W4
07F8:  MOV     W4,C54
07FA:  CALL    4D4
....................            GET_GSM_STATUS 
07FE:  MOV     #0,W1
0800:  MOV     W1,W0
0802:  CLR.B   1
0804:  CALL    214
0808:  INC     W1,W1
080A:  BTSC.B  233.1
080C:  BRA     80A
080E:  MOV     W0,234
0810:  MOV     #8,W0
0812:  CPSGT   W1,W0
0814:  BRA     800
0816:  BTSC.B  233.1
0818:  BRA     816
081A:  MOV.B   900,W0L
081C:  MOV.B   W0L,234
081E:  CLR.B   235
....................                timeout_error=FALSE; 
0820:  BCLR.B  8BC.0
....................                if(!exception(7,7)) 
0822:  MOV.B   #7,W0L
0824:  MOV.B   W0L,C50
0826:  MOV.B   #7,W0L
0828:  MOV.B   W0L,C51
082A:  CALL    654
082E:  CP0.B   W0L
0830:  BRA     NZ,850
....................                { 
....................                   num_attempt+=1; 
0832:  MOV     8FE,W4
0834:  ADD.B   W4L,#1,W0L
0836:  MOV.B   W0L,8FE
....................                   if(num_attempt>50){output_high(fet1);reset_cpu();}    
0838:  MOV     8FE,W4
083A:  MOV     #32,W3
083C:  CP.B    W3L,W4L
083E:  BRA     C,848
0840:  MOV     #FFBF,W4
0842:  MOV     W4,2C8
0844:  BSET.B  2CC.6
0846:  RESET   
....................                   return 0;  
0848:  CLR     0
084A:  BRA     9DE
....................                   break; 
084C:  BRA     9DE
....................                }else{ 
084E:  BRA     85C
....................                   num_attempt=0; 
0850:  CLR.B   8FE
....................                   timeout_error=FALSE;                     
0852:  BCLR.B  8BC.0
....................                   return 1; 
0854:  MOV     #1,W4
0856:  MOV     W4,0
0858:  BRA     9DE
....................                   break;} 
085A:  BRA     9DE
....................                 
....................    case 3:  strncpy(string2,ACK_OK,2); 
085C:  MOV     #8C2,W4
085E:  MOV     W4,C50
0860:  MOV     #904,W4
0862:  MOV     W4,C52
0864:  MOV     #2,W4
0866:  MOV     W4,C54
0868:  CALL    4D4
....................             fprintf(BUG,"AT+GPS=1\n\r"); 
086C:  MOV     #0,W1
086E:  MOV     W1,W0
0870:  CLR.B   1
0872:  CALL    22C
0876:  INC     W1,W1
0878:  BTSC.B  223.1
087A:  BRA     878
087C:  MOV     W0,224
087E:  MOV     #9,W0
0880:  CPSGT   W1,W0
0882:  BRA     86E
....................             GPS_ON 
0884:  MOV     #0,W1
0886:  MOV     W1,W0
0888:  CLR.B   1
088A:  CALL    244
088E:  INC     W1,W1
0890:  BTSC.B  233.1
0892:  BRA     890
0894:  MOV     W0,234
0896:  MOV     #B,W0
0898:  CPSGT   W1,W0
089A:  BRA     886
089C:  BTSC.B  233.1
089E:  BRA     89C
08A0:  MOV.B   900,W0L
08A2:  MOV.B   W0L,234
08A4:  CLR.B   235
....................             if(!exception(2,2)) 
08A6:  MOV.B   #2,W0L
08A8:  MOV.B   W0L,C50
08AA:  MOV.B   #2,W0L
08AC:  MOV.B   W0L,C51
08AE:  CALL    654
08B2:  CP0.B   W0L
08B4:  BRA     NZ,8D0
....................             {      
....................                 num_attempt+=1; 
08B6:  MOV     8FE,W4
08B8:  ADD.B   W4L,#1,W0L
08BA:  MOV.B   W0L,8FE
....................                 if(num_attempt>20){output_high(fet1);reset_cpu();}    
08BC:  MOV     8FE,W4
08BE:  CP.B    W4L,#14
08C0:  BRA     LEU,8CA
08C2:  MOV     #FFBF,W4
08C4:  MOV     W4,2C8
08C6:  BSET.B  2CC.6
08C8:  RESET   
....................                 return 0;  
08CA:  CLR     0
08CC:  BRA     9DE
....................                 break; 
08CE:  BRA     9DE
....................             } 
....................                num_attempt=0; 
08D0:  CLR.B   8FE
....................                timeout_error=FALSE;                
08D2:  BCLR.B  8BC.0
....................                return 1;   
08D4:  MOV     #1,W4
08D6:  MOV     W4,0
08D8:  BRA     9DE
....................                break;      
08DA:  BRA     9DE
....................    case 4:  strncpy(string2,ACK_OK,2); 
08DC:  MOV     #8C2,W4
08DE:  MOV     W4,C50
08E0:  MOV     #904,W4
08E2:  MOV     W4,C52
08E4:  MOV     #2,W4
08E6:  MOV     W4,C54
08E8:  CALL    4D4
....................             fprintf(BUG,"AT+ECHARGE=1\n\r"); 
08EC:  MOV     #0,W1
08EE:  MOV     W1,W0
08F0:  CLR.B   1
08F2:  CALL    260
08F6:  INC     W1,W1
08F8:  BTSC.B  223.1
08FA:  BRA     8F8
08FC:  MOV     W0,224
08FE:  MOV     #D,W0
0900:  CPSGT   W1,W0
0902:  BRA     8EE
....................             fprintf(GSM,"AT+ECHARGE=1%c",enter);    
0904:  MOV     #0,W1
0906:  MOV     W1,W0
0908:  CLR.B   1
090A:  CALL    27C
090E:  INC     W1,W1
0910:  BTSC.B  233.1
0912:  BRA     910
0914:  MOV     W0,234
0916:  MOV     #B,W0
0918:  CPSGT   W1,W0
091A:  BRA     906
091C:  BTSC.B  233.1
091E:  BRA     91C
0920:  MOV.B   900,W0L
0922:  MOV.B   W0L,234
0924:  CLR.B   235
....................             if(!exception(2,2)) 
0926:  MOV.B   #2,W0L
0928:  MOV.B   W0L,C50
092A:  MOV.B   #2,W0L
092C:  MOV.B   W0L,C51
092E:  CALL    654
0932:  CP0.B   W0L
0934:  BRA     NZ,950
....................             {      
....................                 num_attempt+=1; 
0936:  MOV     8FE,W4
0938:  ADD.B   W4L,#1,W0L
093A:  MOV.B   W0L,8FE
....................                 if(num_attempt>20){output_high(fet1);reset_cpu();}    
093C:  MOV     8FE,W4
093E:  CP.B    W4L,#14
0940:  BRA     LEU,94A
0942:  MOV     #FFBF,W4
0944:  MOV     W4,2C8
0946:  BSET.B  2CC.6
0948:  RESET   
....................                 return 0;  
094A:  CLR     0
094C:  BRA     9DE
....................                 break; 
094E:  BRA     9DE
....................             } 
....................                num_attempt=0; 
0950:  CLR.B   8FE
....................                timeout_error=FALSE;                
0952:  BCLR.B  8BC.0
....................                return 1;   
0954:  MOV     #1,W4
0956:  MOV     W4,0
0958:  BRA     9DE
....................                break;   
095A:  BRA     9DE
....................    case 5:  strncpy(string2,ACK_OK,2); 
095C:  MOV     #8C2,W4
095E:  MOV     W4,C50
0960:  MOV     #904,W4
0962:  MOV     W4,C52
0964:  MOV     #2,W4
0966:  MOV     W4,C54
0968:  CALL    4D4
....................             fprintf(BUG,"AT+RGPS=1\n\r"); 
096C:  MOV     #0,W1
096E:  MOV     W1,W0
0970:  CLR.B   1
0972:  CALL    298
0976:  INC     W1,W1
0978:  BTSC.B  223.1
097A:  BRA     978
097C:  MOV     W0,224
097E:  MOV     #A,W0
0980:  CPSGT   W1,W0
0982:  BRA     96E
....................             GPS_REBOOT 
0984:  MOV     #0,W1
0986:  MOV     W1,W0
0988:  CLR.B   1
098A:  CALL    2B0
098E:  INC     W1,W1
0990:  BTSC.B  233.1
0992:  BRA     990
0994:  MOV     W0,234
0996:  MOV     #B,W0
0998:  CPSGT   W1,W0
099A:  BRA     986
099C:  BTSC.B  233.1
099E:  BRA     99C
09A0:  MOV.B   900,W0L
09A2:  MOV.B   W0L,234
09A4:  CLR.B   235
....................             if(!exception(2,2)) 
09A6:  MOV.B   #2,W0L
09A8:  MOV.B   W0L,C50
09AA:  MOV.B   #2,W0L
09AC:  MOV.B   W0L,C51
09AE:  CALL    654
09B2:  CP0.B   W0L
09B4:  BRA     NZ,9D0
....................             {      
....................                num_attempt+=1; 
09B6:  MOV     8FE,W4
09B8:  ADD.B   W4L,#1,W0L
09BA:  MOV.B   W0L,8FE
....................                if(num_attempt>10){output_high(fet1);reset_cpu();}                
09BC:  MOV     8FE,W4
09BE:  CP.B    W4L,#A
09C0:  BRA     LEU,9CA
09C2:  MOV     #FFBF,W4
09C4:  MOV     W4,2C8
09C6:  BSET.B  2CC.6
09C8:  RESET   
....................                return 0;    
09CA:  CLR     0
09CC:  BRA     9DE
....................                break; 
09CE:  BRA     9DE
....................             } 
....................                num_attempt=0; 
09D0:  CLR.B   8FE
....................                timeout_error=FALSE;                
09D2:  BCLR.B  8BC.0
....................                return 1;   
09D4:  MOV     #1,W4
09D6:  MOV     W4,0
09D8:  BRA     9DE
....................                break;                 
09DA:  BRA     9DE
....................     
....................     default: break;               
09DC:  BRA     9DE
....................    } 
09DE:  RETURN  
.................... }          
....................  
.................... boolean exception(unsigned char bb,INT8 cc) 
*
0654:  MOV     W5,[W15++]
.................... {    
.................... //   string[1]='X'; 
....................    buf_var=0;cmp_val=bb;    
0656:  CLR.B   903
0658:  MOV.B   C50,W0L
065A:  MOV.B   W0L,907
....................    fprintf(BUG,"CASE-%u\n\r",jm);    
065C:  MOV     #0,W1
065E:  MOV     W1,W0
0660:  CLR.B   1
0662:  CALL    2CC
0666:  INC     W1,W1
0668:  BTSC.B  223.1
066A:  BRA     668
066C:  MOV     W0,224
066E:  MOV     #4,W0
0670:  CPSGT   W1,W0
0672:  BRA     65E
0674:  MOV.B   9DC,W0L
0676:  CLR.B   1
0678:  MOV     #0,W4
067A:  CALL    50C
067E:  BTSC.B  223.1
0680:  BRA     67E
0682:  MOV     #A,W4
0684:  MOV     W4,224
0686:  BTSC.B  223.1
0688:  BRA     686
068A:  MOV     #D,W4
068C:  MOV     W4,224
....................    timeout_error=FALSE; 
068E:  BCLR.B  8BC.0
....................    timeout_v = 400000; 
0690:  MOV     #1A80,W4
0692:  MOV     W4,A0A
0694:  MOV     #6,W4
0696:  MOV     W4,A0C
....................    while(buf_var <= cc && !timeout_error)    
0698:  MOV.B   903,W0L
069A:  MOV     C50,W4
069C:  LSR     W4,#8,W4
069E:  CP.B    W4L,W0L
06A0:  BRA     LT,706
06A2:  BTSC.B  8BC.0
06A4:  BRA     706
....................    { 
....................       v3 = timed_getc(); 
06A6:  CALL    5D0
06AA:  MOV.B   W0L,8C1
....................       if(isalpha(v3) || isdigit(v3)){ 
06AC:  MOV     8C0,W4
06AE:  LSR     W4,#8,W4
06B0:  MOV     #41,W3
06B2:  CP.B    W3L,W4L
06B4:  BRA     GTU,6C2
06B6:  MOV     8C0,W4
06B8:  LSR     W4,#8,W4
06BA:  MOV     #5A,W3
06BC:  CP.B    W3L,W4L
06BE:  BRA     NC,6C2
06C0:  BRA     6EC
06C2:  MOV     8C0,W4
06C4:  LSR     W4,#8,W4
06C6:  MOV     #61,W3
06C8:  CP.B    W3L,W4L
06CA:  BRA     GTU,6D8
06CC:  MOV     8C0,W4
06CE:  LSR     W4,#8,W4
06D0:  MOV     #7A,W3
06D2:  CP.B    W3L,W4L
06D4:  BRA     NC,6D8
06D6:  BRA     6EC
06D8:  MOV     8C0,W4
06DA:  LSR     W4,#8,W4
06DC:  MOV     #30,W3
06DE:  CP.B    W3L,W4L
06E0:  BRA     GTU,704
06E2:  MOV     8C0,W4
06E4:  LSR     W4,#8,W4
06E6:  MOV     #39,W3
06E8:  CP.B    W3L,W4L
06EA:  BRA     NC,704
....................       string[buf_var]=v3;    
06EC:  MOV.B   903,W0L
06EE:  SE      W0,W0
06F0:  MOV     #9C6,W4
06F2:  ADD     W0,W4,W5
06F4:  MOV.B   8C1,W0L
06F6:  MOV.B   W0L,[W5]
....................       fprintf(BUG,"%c",v3);  
06F8:  BTSC.B  223.1
06FA:  BRA     6F8
06FC:  MOV.B   8C1,W0L
06FE:  MOV.B   W0L,224
0700:  CLR.B   225
....................       buf_var++; 
0702:  INC.B   0903
....................       }       
0704:  BRA     698
....................    }    
.................... //   fprintf(BUG,"%s",string); 
....................    fprintf(BUG,"-\n\r"); 
0706:  BTSC.B  223.1
0708:  BRA     706
070A:  MOV     #2D,W4
070C:  MOV     W4,224
070E:  BTSC.B  223.1
0710:  BRA     70E
0712:  MOV     #A,W4
0714:  MOV     W4,224
0716:  BTSC.B  223.1
0718:  BRA     716
071A:  MOV     #D,W4
071C:  MOV     W4,224
.................... //   timeout_error=FALSE; 
.................... //   gets(string,GSM); 
....................    if(!strncmp(string,string2,cmp_val) || !strncmp(string,string6,cmp_val))   
071E:  MOV.B   907,W0L
0720:  MOV.B   W0L,W4L
0722:  SE      W4,W3
0724:  MOV     W3,C58
0726:  MOV     #9C6,W3
0728:  MOV     W3,C54
072A:  MOV     #8C2,W3
072C:  MOV     W3,C56
072E:  CALL    60C
0732:  CP0.B   W0L
0734:  BRA     Z,74E
0736:  MOV.B   907,W0L
0738:  MOV.B   W0L,W4L
073A:  SE      W4,W3
073C:  MOV     W3,C58
073E:  MOV     #9C6,W3
0740:  MOV     W3,C54
0742:  MOV     #8E0,W3
0744:  MOV     W3,C56
0746:  CALL    60C
074A:  CP0.B   W0L
074C:  BRA     NZ,756
....................    return 1;    
074E:  MOV.B   #1,W0L
0750:  MOV.B   W0L,0
0752:  BRA     75A
0754:  BRA     75A
....................    else 
....................    return 0;    
0756:  CLR.B   0
0758:  BRA     75A
075A:  MOV     [--W15],W5
075C:  RETURN  
.................... } 
....................  
.................... char timed_getc() {    
....................  
....................    timeout_error=FALSE; 
*
05D0:  BCLR.B  8BC.0
....................    timeout=0; 
05D2:  CLR     A06
05D4:  CLR     A08
....................    while(!kbhit(GSM) && (++timeout<timeout_v)) // 1/2 // second 
05D6:  BTSC.B  232.0
05D8:  BRA     5F8
05DA:  INC     0A06
05DC:  BTSC.B  42.1
05DE:  INC     0A08
05E0:  MOV     A08,W0
05E2:  MOV     A0C,W4
05E4:  CP      W4,W0
05E6:  BRA     LT,5F8
05E8:  BRA     GT,5F2
05EA:  MOV     A06,W0
05EC:  MOV     A0A,W4
05EE:  CP      W4,W0
05F0:  BRA     LEU,5F8
....................           delay_us(10); 
05F2:  REPEAT  #4E
05F4:  NOP     
05F6:  BRA     5D6
....................    if(kbhit(GSM)) {       
05F8:  BTSS.B  232.0
05FA:  BRA     604
....................           return(getc(GSM));} 
05FC:  CALL    5C2
0600:  BRA     60A
0602:  BRA     60A
....................    else { 
....................           timeout_error=TRUE;  
0604:  BSET.B  8BC.0
....................           return(0); 
0606:  CLR.B   0
0608:  BRA     60A
....................    } 
060A:  RETURN  
.................... } 
....................  
.................... boolean ack_1(char dat) 
*
2B00:  MOV     W5,[W15++]
.................... { 
....................       timeout_v = 40000000;            
2B02:  MOV     #5A00,W4
2B04:  MOV     W4,A0A
2B06:  MOV     #262,W4
2B08:  MOV     W4,A0C
....................       if(timed_getc() == dat || timeout_error==TRUE) 
2B0A:  CALL    5D0
2B0E:  CP.B    C48
2B10:  BRA     Z,2B16
2B12:  BTSS.B  8BC.0
2B14:  BRA     2B1C
....................       return 1;     
2B16:  MOV.B   #1,W0L
2B18:  MOV.B   W0L,0
2B1A:  BRA     2B1C
2B1C:  MOV     [--W15],W5
2B1E:  RETURN  
.................... } 
....................  
.................... int8 cip_start() 
.................... { 
....................     strncpy(string2,STATUS_CON,11); 
*
29FE:  MOV     #8C2,W4
2A00:  MOV     W4,C50
2A02:  MOV     #92C,W4
2A04:  MOV     W4,C52
2A06:  MOV     #B,W4
2A08:  MOV     W4,C54
2A0A:  CALL    4D4
....................     START_CIP 
2A0E:  MOV     #0,W1
2A10:  MOV     W1,W0
2A12:  CLR.B   1
2A14:  CALL    2E2
2A18:  INC     W1,W1
2A1A:  BTSC.B  233.1
2A1C:  BRA     2A1A
2A1E:  MOV     W0,234
2A20:  MOV     #B,W0
2A22:  CPSGT   W1,W0
2A24:  BRA     2A10
2A26:  BTSC.B  233.1
2A28:  BRA     2A26
2A2A:  MOV.B   8FF,W0L
2A2C:  MOV.B   W0L,234
2A2E:  CLR.B   235
2A30:  BTSC.B  233.1
2A32:  BRA     2A30
2A34:  MOV     #54,W4
2A36:  MOV     W4,234
2A38:  BTSC.B  233.1
2A3A:  BRA     2A38
2A3C:  MOV     #43,W4
2A3E:  MOV     W4,234
2A40:  BTSC.B  233.1
2A42:  BRA     2A40
2A44:  MOV     #50,W4
2A46:  MOV     W4,234
2A48:  BTSC.B  233.1
2A4A:  BRA     2A48
2A4C:  MOV.B   8FF,W0L
2A4E:  MOV.B   W0L,234
2A50:  CLR.B   235
2A52:  BTSC.B  233.1
2A54:  BRA     2A52
2A56:  MOV     #2C,W4
2A58:  MOV     W4,234
2A5A:  BTSC.B  233.1
2A5C:  BRA     2A5A
2A5E:  MOV.B   8FF,W0L
2A60:  MOV.B   W0L,234
2A62:  CLR.B   235
2A64:  MOV     #16,W1
2A66:  MOV     W1,W0
2A68:  CLR.B   1
2A6A:  CALL    2E2
2A6E:  INC     W1,W1
2A70:  BTSC.B  233.1
2A72:  BRA     2A70
2A74:  MOV     W0,234
2A76:  MOV     #26,W0
2A78:  CPSGT   W1,W0
2A7A:  BRA     2A66
2A7C:  BTSC.B  233.1
2A7E:  BRA     2A7C
2A80:  MOV.B   8FF,W0L
2A82:  MOV.B   W0L,234
2A84:  CLR.B   235
2A86:  BTSC.B  233.1
2A88:  BRA     2A86
2A8A:  MOV     #2C,W4
2A8C:  MOV     W4,234
2A8E:  BTSC.B  233.1
2A90:  BRA     2A8E
2A92:  MOV.B   8FF,W0L
2A94:  MOV.B   W0L,234
2A96:  CLR.B   235
2A98:  BTSC.B  233.1
2A9A:  BRA     2A98
2A9C:  MOV     #38,W4
2A9E:  MOV     W4,234
2AA0:  BTSC.B  233.1
2AA2:  BRA     2AA0
2AA4:  MOV     #30,W4
2AA6:  MOV     W4,234
2AA8:  BTSC.B  233.1
2AAA:  BRA     2AA8
2AAC:  MOV.B   8FF,W0L
2AAE:  MOV.B   W0L,234
2AB0:  CLR.B   235
2AB2:  BTSC.B  233.1
2AB4:  BRA     2AB2
2AB6:  MOV.B   900,W0L
2AB8:  MOV.B   W0L,234
2ABA:  CLR.B   235
....................  //   fprintf(BUG,"AT+\n\r");     
....................     if(!exception(10,11)) 
2ABC:  MOV.B   #A,W0L
2ABE:  MOV.B   W0L,C50
2AC0:  MOV.B   #B,W0L
2AC2:  MOV.B   W0L,C51
2AC4:  CALL    654
2AC8:  CP0.B   W0L
2ACA:  BRA     NZ,2AD4
....................     { 
.................... //      if(num_attempt++<=2) 
.................... //      goto l0; 
.................... //      else  
....................       return 80;  
2ACC:  MOV.B   #50,W0L
2ACE:  MOV.B   W0L,0
2AD0:  BRA     2ADA
....................       } 
2AD2:  BRA     2ADA
....................       else return 81;   
2AD4:  MOV.B   #51,W0L
2AD6:  MOV.B   W0L,0
2AD8:  BRA     2ADA
2ADA:  RETURN  
.................... } 
....................  
.................... void post() 
.................... {  
.................... //     disable_interrupts(INT_CNI); 
.................... //      cip_send(); 
....................       cip_send1(); 
*
3158:  CALL    2EEE
....................       cip_send2();   
315C:  CALL    3022
....................       cip_send3(); 
3160:  CALL    3096
3164:  RETURN  
.................... //      timeout_v = 800000; 
.................... //      rtos_await(kbhit()); 
.................... //      while(timed_getc()!='1' && timeout_error!=TRUE);             
.................... //      cip_close();      
.................... //      enable_interrupts(INT_CNI); 
.................... } 
....................  
.................... void cip_send() 
.................... {    
....................    fprintf(GSM,"AT+CIPSEND"); 
*
2ADC:  MOV     #0,W1
2ADE:  MOV     W1,W0
2AE0:  CLR.B   1
2AE2:  CALL    320
2AE6:  INC     W1,W1
2AE8:  BTSC.B  233.1
2AEA:  BRA     2AE8
2AEC:  MOV     W0,234
2AEE:  MOV     #9,W0
2AF0:  CPSGT   W1,W0
2AF2:  BRA     2ADE
....................    fprintf(GSM,"%c",enter);    
2AF4:  BTSC.B  233.1
2AF6:  BRA     2AF4
2AF8:  MOV.B   900,W0L
2AFA:  MOV.B   W0L,234
2AFC:  CLR.B   235
2AFE:  RETURN  
.................... //   while(timed_getc()!='>' && timeout_error!=TRUE); 
.................... //   if(timeout_error==TRUE){ 
.................... //      cip_close();      
.................... //      return;       
.................... } 
....................  
.................... void cip_send1() 
*
2EEE:  MOV     W9,[W15++]
2EF0:  MOV     W10,[W15++]
.................... {                                                                    //139.59.8.190 
....................    fprintf(GSM,"GET http://www.gpstraces.com/u/u?i=865067022435708&");   //imeiid=866762027240124//imeiid=866593020769383//866762027261112 
2EF2:  MOV     #0,W1
2EF4:  MOV     W1,W0
2EF6:  CLR.B   1
2EF8:  CALL    338
2EFC:  INC     W1,W1
2EFE:  BTSC.B  233.1
2F00:  BRA     2EFE
2F02:  MOV     W0,234
2F04:  MOV     #32,W0
2F06:  CPSGT   W1,W0
2F08:  BRA     2EF4
....................    fprintf(GSM,"ln="); 
2F0A:  BTSC.B  233.1
2F0C:  BRA     2F0A
2F0E:  MOV     #6C,W4
2F10:  MOV     W4,234
2F12:  BTSC.B  233.1
2F14:  BRA     2F12
2F16:  MOV     #6E,W4
2F18:  MOV     W4,234
2F1A:  BTSC.B  233.1
2F1C:  BRA     2F1A
2F1E:  MOV     #3D,W4
2F20:  MOV     W4,234
....................    fprintf(GSM,"%2.5g",new_ln);//2.6    
2F22:  MOV     A40,W2
2F24:  MOV     A3E,W1
2F26:  MOV     #0,W0
2F28:  CALL    2B20
2F2C:  MOV     #5,W9
2F2E:  MOV     #6,W10
2F30:  CALL    2D6C
....................    fprintf(GSM,"&");       
2F34:  BTSC.B  233.1
2F36:  BRA     2F34
2F38:  MOV     #26,W4
2F3A:  MOV     W4,234
....................    fprintf(GSM,"lt="); 
2F3C:  BTSC.B  233.1
2F3E:  BRA     2F3C
2F40:  MOV     #6C,W4
2F42:  MOV     W4,234
2F44:  BTSC.B  233.1
2F46:  BRA     2F44
2F48:  MOV     #74,W4
2F4A:  MOV     W4,234
2F4C:  BTSC.B  233.1
2F4E:  BRA     2F4C
2F50:  MOV     #3D,W4
2F52:  MOV     W4,234
....................    fprintf(GSM,"%2.5g",new_la);    
2F54:  MOV     A3C,W2
2F56:  MOV     A3A,W1
2F58:  MOV     #0,W0
2F5A:  CALL    2B20
2F5E:  MOV     #5,W9
2F60:  MOV     #6,W10
2F62:  CALL    2D6C
2F66:  MOV     [--W15],W10
2F68:  MOV     [--W15],W9
2F6A:  RETURN  
.................... } 
....................  
.................... void cip_send2() 
*
3022:  MOV     W9,[W15++]
3024:  MOV     W10,[W15++]
.................... { 
....................    fprintf(GSM,"&");  
3026:  BTSC.B  233.1
3028:  BRA     3026
302A:  MOV     #26,W4
302C:  MOV     W4,234
....................    fprintf(GSM,"s=");    
302E:  BTSC.B  233.1
3030:  BRA     302E
3032:  MOV     #73,W4
3034:  MOV     W4,234
3036:  BTSC.B  233.1
3038:  BRA     3036
303A:  MOV     #3D,W4
303C:  MOV     W4,234
.................... //   if(dir == 1)fprintf(GSM"1"); else     
....................    fprintf(GSM,"%3.1g",speed); 
303E:  MOV     A48,W2
3040:  MOV     A46,W1
3042:  MOV     #0,W0
3044:  CALL    2B20
3048:  MOV     #1,W9
304A:  MOV     #2,W10
304C:  CALL    2D6C
....................    fprintf(GSM,"&t="); 
3050:  BTSC.B  233.1
3052:  BRA     3050
3054:  MOV     #26,W4
3056:  MOV     W4,234
3058:  BTSC.B  233.1
305A:  BRA     3058
305C:  MOV     #74,W4
305E:  MOV     W4,234
3060:  BTSC.B  233.1
3062:  BRA     3060
3064:  MOV     #3D,W4
3066:  MOV     W4,234
....................    fprintf(GSM,"%04lu/%02u/%02u",year,month,date);    
3068:  MOV     9EE,W0
306A:  MOV     #8004,W4
306C:  CALL    2F6C
3070:  BTSC.B  233.1
3072:  BRA     3070
3074:  MOV     #2F,W4
3076:  MOV     W4,234
3078:  MOV     9EC,W0
307A:  MOV     #8002,W4
307C:  CALL    2F6C
3080:  BTSC.B  233.1
3082:  BRA     3080
3084:  MOV     #2F,W4
3086:  MOV     W4,234
3088:  MOV     9EA,W0
308A:  MOV     #8002,W4
308C:  CALL    2F6C
3090:  MOV     [--W15],W10
3092:  MOV     [--W15],W9
3094:  RETURN  
.................... } 
....................  
.................... void cip_send3() 
.................... {       
....................    fputc('%',GSM); 
3096:  MOV.B   #25,W0L
3098:  BTSC.B  233.1
309A:  BRA     3098
309C:  MOV.B   W0L,234
309E:  CLR.B   235
....................    fprintf(GSM,"20");  
30A0:  BTSC.B  233.1
30A2:  BRA     30A0
30A4:  MOV     #32,W4
30A6:  MOV     W4,234
30A8:  BTSC.B  233.1
30AA:  BRA     30A8
30AC:  MOV     #30,W4
30AE:  MOV     W4,234
....................    fprintf(GSM,"%02u:%02u:%02u",v1,new_min,new_sec);   
30B0:  MOV     9F0,W0
30B2:  MOV     #8002,W4
30B4:  CALL    2F6C
30B8:  BTSC.B  233.1
30BA:  BRA     30B8
30BC:  MOV     #3A,W4
30BE:  MOV     W4,234
30C0:  MOV     9E6,W0
30C2:  MOV     #8002,W4
30C4:  CALL    2F6C
30C8:  BTSC.B  233.1
30CA:  BRA     30C8
30CC:  MOV     #3A,W4
30CE:  MOV     W4,234
30D0:  MOV     9E8,W0
30D2:  MOV     #8002,W4
30D4:  CALL    2F6C
....................    fprintf(GSM,"&");  
30D8:  BTSC.B  233.1
30DA:  BRA     30D8
30DC:  MOV     #26,W4
30DE:  MOV     W4,234
....................    fprintf(GSM,"u=%02u",dir);   
30E0:  BTSC.B  233.1
30E2:  BRA     30E0
30E4:  MOV     #75,W4
30E6:  MOV     W4,234
30E8:  BTSC.B  233.1
30EA:  BRA     30E8
30EC:  MOV     #3D,W4
30EE:  MOV     W4,234
30F0:  MOV.B   9DA,W0L
30F2:  CLR.B   1
30F4:  MOV     #8002,W4
30F6:  CALL    2F6C
....................    fprintf(BUG,"u=%02u\n\r",dir);   
30FA:  BTSC.B  223.1
30FC:  BRA     30FA
30FE:  MOV     #75,W4
3100:  MOV     W4,224
3102:  BTSC.B  223.1
3104:  BRA     3102
3106:  MOV     #3D,W4
3108:  MOV     W4,224
310A:  MOV.B   9DA,W0L
310C:  CLR.B   1
310E:  MOV     #8002,W4
3110:  CALL    50C
3114:  BTSC.B  223.1
3116:  BRA     3114
3118:  MOV     #A,W4
311A:  MOV     W4,224
311C:  BTSC.B  223.1
311E:  BRA     311C
3120:  MOV     #D,W4
3122:  MOV     W4,224
.................... //   delay_ms(50); 
....................    fprintf(GSM,"%c",enter); 
3124:  BTSC.B  233.1
3126:  BRA     3124
3128:  MOV.B   900,W0L
312A:  MOV.B   W0L,234
312C:  CLR.B   235
....................    fprintf(GSM,"%c",lf); 
312E:  BTSC.B  233.1
3130:  BRA     312E
3132:  MOV.B   902,W0L
3134:  MOV.B   W0L,234
3136:  CLR.B   235
....................    fprintf(GSM,"%c",enter); 
3138:  BTSC.B  233.1
313A:  BRA     3138
313C:  MOV.B   900,W0L
313E:  MOV.B   W0L,234
3140:  CLR.B   235
....................    fprintf(GSM,"%c",lf); 
3142:  BTSC.B  233.1
3144:  BRA     3142
3146:  MOV.B   902,W0L
3148:  MOV.B   W0L,234
314A:  CLR.B   235
....................    fprintf(GSM,"%c",sent);   
314C:  BTSC.B  233.1
314E:  BRA     314C
3150:  MOV.B   901,W0L
3152:  MOV.B   W0L,234
3154:  CLR.B   235
3156:  RETURN  
.................... //   for(sec=0;sec<=5;sec++) 
.................... //   fprintf(BUG,"A-%c\n\r",timed_getc()); 
.................... } 
.................... void cip_close() 
.................... { 
.................... //   delay_ms(100);//100 
....................    fprintf(GSM,"AT+CIPCLOSE"); 
*
3166:  MOV     #0,W1
3168:  MOV     W1,W0
316A:  CLR.B   1
316C:  CALL    378
3170:  INC     W1,W1
3172:  BTSC.B  233.1
3174:  BRA     3172
3176:  MOV     W0,234
3178:  MOV     #A,W0
317A:  CPSGT   W1,W0
317C:  BRA     3168
....................    fprintf(GSM,"%c",enter); 
317E:  BTSC.B  233.1
3180:  BRA     317E
3182:  MOV.B   900,W0L
3184:  MOV.B   W0L,234
3186:  CLR.B   235
3188:  RETURN  
.................... }  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------// 
.................... #task(rate=500ms,max=10ms) 
.................... void boot(); 
.................... #task(rate=2000ms,max=20ms) 
.................... void process_data(); 
.................... #task(rate=10000ms,max=50ms,enabled=false) 
.................... void post_data(); 
.................... #task(rate=1500ms,max=15ms,enabled=false) 
.................... void post_data_fail(); 
.................... #task(rate=300ms,max=15ms) 
.................... void battery_fail_check(); 
.................... #task(rate=1000ms,max=50ms,enabled=false) 
.................... void gps_rx(); 
.................... //#task(rate=60s,max=30ms) 
.................... //void post_status(); 
....................  
.................... void key_scan(); 
.................... void cmd_exe(); 
.................... //void get_gps();  
.................... //void NMEA_GPRMC();  
.................... void process(); 
.................... float rad2deg(float rad); 
.................... float deg2rad(float deg); 
.................... float distance(float lat1, float lon1, float lat2, float lon2, char unit); 
.................... void conversion(int dat,int add); 
.................... float conversion2(float yyy); 
....................  
.................... void boot() 
.................... {   
....................    fprintf(BUG,"-TASK1-\n\r");     
*
09E0:  MOV     #0,W1
09E2:  MOV     W1,W0
09E4:  CLR.B   1
09E6:  CALL    390
09EA:  INC     W1,W1
09EC:  BTSC.B  223.1
09EE:  BRA     9EC
09F0:  MOV     W0,224
09F2:  MOV     #8,W0
09F4:  CPSGT   W1,W0
09F6:  BRA     9E2
....................    ack_log=init_gsm(jl);  
09F8:  MOV.B   9DB,W0L
09FA:  MOV.B   W0L,W4L
09FC:  SE      W4,W3
09FE:  MOV     W3,AC2
0A00:  CALL    75E
0A04:  MOV.B   W0L,9DE
....................    fprintf(BUG,"ACK-%u\n\r",ack_log);     
0A06:  MOV     #0,W1
0A08:  MOV     W1,W0
0A0A:  CLR.B   1
0A0C:  CALL    3A6
0A10:  INC     W1,W1
0A12:  BTSC.B  223.1
0A14:  BRA     A12
0A16:  MOV     W0,224
0A18:  MOV     #3,W0
0A1A:  CPSGT   W1,W0
0A1C:  BRA     A08
0A1E:  MOV.B   9DE,W0L
0A20:  CLR.B   1
0A22:  MOV     #0,W4
0A24:  CALL    50C
0A28:  BTSC.B  223.1
0A2A:  BRA     A28
0A2C:  MOV     #A,W4
0A2E:  MOV     W4,224
0A30:  BTSC.B  223.1
0A32:  BRA     A30
0A34:  MOV     #D,W4
0A36:  MOV     W4,224
....................    if(ack_log){jl++;} 
0A38:  CP0.B   9DE
0A3A:  BRA     Z,A3E
0A3C:  INC.B   09DB
....................    if(jl>=4){ 
0A3E:  MOV.B   9DB,W0L
0A40:  SE      W0,W0
0A42:  CP      W0,#4
0A44:  BRA     LT,A56
....................       init_var=1; 
0A46:  MOV.B   #1,W0L
0A48:  MOV.B   W0L,8BF
....................       post_var=0; 
0A4A:  CLR.B   8BE
....................       jl=1; 
0A4C:  MOV.B   #1,W0L
0A4E:  MOV.B   W0L,9DB
....................       rtos_disable(boot); 
0A50:  BSET.B  A54.7
....................       rtos_enable(gps_rx);    
0A52:  BCLR.B  AAE.7
....................       rtos_enable(post_data);    
0A54:  BCLR.B  A78.7
....................       }      
....................    ack_log = 0; 
0A56:  CLR.B   9DE
0A58:  MOV     #9E0,W0
0A5A:  MOV     W0,A5A
0A5C:  MOV     #0,W0
0A5E:  MOV     W0,A5C
0A60:  GOTO    380E
0A64:  RETURN  
.................... } 
....................     
.................... void process_data() 
.................... {   
....................     process();      
*
28E8:  CALL    2482
....................     fprintf(BUG,"*");   
28EC:  BTSC.B  223.1
28EE:  BRA     28EC
28F0:  MOV     #2A,W4
28F2:  MOV     W4,224
28F4:  MOV     #28E8,W0
28F6:  MOV     W0,A6C
28F8:  MOV     #0,W0
28FA:  MOV     W0,A6E
28FC:  GOTO    380E
2900:  RETURN  
.................... } 
....................  
.................... void gps_rx() 
.................... {     
.................... //if (post_var == 0 ){ 
....................       GET_GPS    
2902:  MOV     #0,W1
2904:  MOV     W1,W0
2906:  CLR.B   1
2908:  CALL    3BC
290C:  INC     W1,W1
290E:  BTSC.B  233.1
2910:  BRA     290E
2912:  MOV     W0,234
2914:  MOV     #9,W0
2916:  CPSGT   W1,W0
2918:  BRA     2904
291A:  BTSC.B  233.1
291C:  BRA     291A
291E:  MOV.B   900,W0L
2920:  MOV.B   W0L,234
2922:  CLR.B   235
....................       timeout_v = 400000; 
2924:  MOV     #1A80,W4
2926:  MOV     W4,A0A
2928:  MOV     #6,W4
292A:  MOV     W4,A0C
....................       timeout_error=FALSE; 
292C:  BCLR.B  8BC.0
....................       
....................       while((string3 [0] != 'C' || string3 [j] != 0x0d) && !timeout_error){ 
292E:  MOV     948,W4
2930:  XOR.B   #43,W4L
2932:  BRA     NZ,2942
2934:  MOV.B   8BD,W0L
2936:  SE      W0,W0
2938:  MOV     #948,W4
293A:  ADD     W0,W4,W0
293C:  MOV.B   [W0],W4L
293E:  CP.B    W4L,#D
2940:  BRA     Z,296C
2942:  BTSC.B  8BC.0
2944:  BRA     296C
....................       string3[j] = timed_getc(); 
2946:  MOV.B   8BD,W0L
2948:  SE      W0,W0
294A:  MOV     #948,W4
294C:  ADD     W0,W4,W5
294E:  CALL    5D0
2952:  MOV.B   W0L,[W5]
....................       if(string3 [0] == 'C' && string3 [j] != 0x0d) 
2954:  MOV     948,W4
2956:  XOR.B   #43,W4L
2958:  BRA     NZ,296A
295A:  MOV.B   8BD,W0L
295C:  SE      W0,W0
295E:  MOV     #948,W4
2960:  ADD     W0,W4,W0
2962:  MOV.B   [W0],W4L
2964:  CP.B    W4L,#D
2966:  BRA     Z,296A
....................       j++; 
2968:  INC.B   08BD
296A:  BRA     292E
....................       } 
....................       if(string3 [0] == 'C' && string3 [j] == 0x0d){ 
296C:  MOV     948,W4
296E:  XOR.B   #43,W4L
2970:  BRA     NZ,29D0
2972:  MOV.B   8BD,W0L
2974:  SE      W0,W0
2976:  MOV     #948,W4
2978:  ADD     W0,W4,W0
297A:  MOV.B   [W0],W4L
297C:  CP.B    W4L,#D
297E:  BRA     NZ,29D0
....................          timeout_error_2 = true; 
2980:  BSET.B  8BC.1
....................          fprintf(BUG,"LL-%s,%02u\n\r",string3,j);    
2982:  BTSC.B  223.1
2984:  BRA     2982
2986:  MOV     #4C,W4
2988:  MOV     W4,224
298A:  BTSC.B  223.1
298C:  BRA     298A
298E:  MOV     #4C,W4
2990:  MOV     W4,224
2992:  BTSC.B  223.1
2994:  BRA     2992
2996:  MOV     #2D,W4
2998:  MOV     W4,224
299A:  MOV     #948,W1
299C:  CP0.B   [W1]
299E:  BRA     Z,29AE
29A0:  BTSC.B  223.1
29A2:  BRA     29A0
29A4:  MOV.B   [W1+#0],W0L
29A6:  MOV.B   W0L,224
29A8:  CLR.B   225
29AA:  INC     W1,W1
29AC:  BRA     299C
29AE:  BTSC.B  223.1
29B0:  BRA     29AE
29B2:  MOV     #2C,W4
29B4:  MOV     W4,224
29B6:  MOV.B   8BD,W0L
29B8:  CLR.B   1
29BA:  MOV     #8002,W4
29BC:  CALL    50C
29C0:  BTSC.B  223.1
29C2:  BRA     29C0
29C4:  MOV     #A,W4
29C6:  MOV     W4,224
29C8:  BTSC.B  223.1
29CA:  BRA     29C8
29CC:  MOV     #D,W4
29CE:  MOV     W4,224
....................       }         
.................... //      fprintf(BUG,"LL-%s,%c\n\r",string3,string3[j]);    
.................... //   } 
....................    if(timeout_error){ 
29D0:  BTSS.B  8BC.0
29D2:  BRA     29F0
....................    j=0; 
29D4:  CLR.B   8BD
....................    string3 [0] = 0; 
29D6:  CLR.B   948
....................    fprintf(BUG,"TO\r\n"); 
29D8:  MOV     #0,W1
29DA:  MOV     W1,W0
29DC:  CLR.B   1
29DE:  CALL    3D6
29E2:  INC     W1,W1
29E4:  BTSC.B  223.1
29E6:  BRA     29E4
29E8:  MOV     W0,224
29EA:  MOV     #3,W0
29EC:  CPSGT   W1,W0
29EE:  BRA     29DA
....................    }    
29F0:  MOV     #2902,W0
29F2:  MOV     W0,AB4
29F4:  MOV     #0,W0
29F6:  MOV     W0,AB6
29F8:  GOTO    380E
29FC:  RETURN  
.................... } 
....................  
....................  
.................... void post_data() 
.................... {      
.................... //   set_timer2(0); 
....................    output_bit(fet1,0); 
*
318A:  BCLR.B  2CC.6
318C:  MOV     #FFBF,W4
318E:  MOV     W4,2C8
....................    if(post_var==1 && init_var==1){    
3190:  MOV.B   8BE,W0L
3192:  SE      W0,W0
3194:  CP      W0,#1
3196:  BRA     NZ,3272
3198:  MOV.B   8BF,W0L
319A:  SE      W0,W0
319C:  CP      W0,#1
319E:  BRA     NZ,3272
....................    ack_log1=cip_start();    
31A0:  CALL    29FE
31A4:  MOV.B   W0L,9DF
.................... //   fprintf(BUG,"PF-%u\n\r",post_fail_count);     
....................    if(ack_log1==81) 
31A6:  MOV.B   9DF,W0L
31A8:  SE      W0,W0
31AA:  MOV     #51,W4
31AC:  CP      W4,W0
31AE:  BRA     NZ,3264
....................    {   
....................       cip_send(); 
31B0:  CALL    2ADC
....................       fprintf(BUG,"Stage 1\n\r"); 
31B4:  MOV     #0,W1
31B6:  MOV     W1,W0
31B8:  CLR.B   1
31BA:  CALL    3E8
31BE:  INC     W1,W1
31C0:  BTSC.B  223.1
31C2:  BRA     31C0
31C4:  MOV     W0,224
31C6:  MOV     #8,W0
31C8:  CPSGT   W1,W0
31CA:  BRA     31B6
....................       rtos_await(ack_1('>')); 
31CC:  MOV.B   #3E,W0L
31CE:  MOV.B   W0L,C48
31D0:  CALL    2B00
31D4:  MOV.B   W0L,W5L
31D6:  MOV     #31CC,W0
31D8:  MOV     W0,A7E
31DA:  MOV     #0,W0
31DC:  MOV     W0,A80
31DE:  BSET.B  A66.3
31E0:  CP0.B   W5L
31E2:  BRA     NZ,31E8
31E4:  GOTO    3854
31E8:  BCLR.B  A66.3
....................       if(timeout_error!=TRUE){ 
31EA:  BTSC.B  8BC.0
31EC:  BRA     3244
....................       post(); 
31EE:  CALL    3158
....................       fprintf(BUG,"Stage 2\n\r"); 
31F2:  MOV     #0,W1
31F4:  MOV     W1,W0
31F6:  CLR.B   1
31F8:  CALL    3FE
31FC:  INC     W1,W1
31FE:  BTSC.B  223.1
3200:  BRA     31FE
3202:  MOV     W0,224
3204:  MOV     #8,W0
3206:  CPSGT   W1,W0
3208:  BRA     31F4
....................       rtos_await(ack_1('1')); 
320A:  MOV.B   #31,W0L
320C:  MOV.B   W0L,C48
320E:  CALL    2B00
3212:  MOV.B   W0L,W5L
3214:  MOV     #320A,W0
3216:  MOV     W0,A7E
3218:  MOV     #0,W0
321A:  MOV     W0,A80
321C:  BSET.B  A66.3
321E:  CP0.B   W5L
3220:  BRA     NZ,3226
3222:  GOTO    3854
3226:  BCLR.B  A66.3
....................       if(timeout_error!=TRUE) 
3228:  BTSC.B  8BC.0
322A:  BRA     3244
....................       fprintf(BUG,"Stage 3\n\r"); 
322C:  MOV     #0,W1
322E:  MOV     W1,W0
3230:  CLR.B   1
3232:  CALL    414
3236:  INC     W1,W1
3238:  BTSC.B  223.1
323A:  BRA     3238
323C:  MOV     W0,224
323E:  MOV     #8,W0
3240:  CPSGT   W1,W0
3242:  BRA     322E
....................       } 
....................       cip_close();   
3244:  CALL    3166
....................       old_la=new_la; 
3248:  PUSH    A3A
324A:  POP     A32
324C:  PUSH    A3C
324E:  POP     A34
....................       old_ln=new_ln; 
3250:  PUSH    A3E
3252:  POP     A36
3254:  PUSH    A40
3256:  POP     A38
....................       old_hrs=new_hrs;       
3258:  PUSH    A26
325A:  POP     A2A
325C:  PUSH    A28
325E:  POP     A2C
....................    //   output_low(led2); 
....................   //    output_high(led1); 
....................       post_fail_count=0;       
3260:  CLR     9F2
....................    }else{ 
3262:  BRA     326E
....................  //     output_low(led1); 
....................  //     output_high(led2);  
....................       cip_close(); 
3264:  CALL    3166
....................       rtos_disable(post_data);    
3268:  BSET.B  A78.7
....................       rtos_disable(gps_rx);    
326A:  BSET.B  AAE.7
....................  //     rtos_disable(post_status);    
....................       rtos_enable(post_data_fail);    
326C:  BCLR.B  A8A.7
....................    } 
....................    post_var=0; 
326E:  CLR.B   8BE
....................    ack_log1=0;       
3270:  CLR.B   9DF
....................    }// else {delay_ms(25);} 
3272:  MOV     #318A,W0
3274:  MOV     W0,A7E
3276:  MOV     #0,W0
3278:  MOV     W0,A80
327A:  GOTO    380E
327E:  RETURN  
.................... //   rtos_stats(post_data,&stats); 
.................... //   fprintf(BUG,"TASK4:%lu-%lu-%lu-%lu",stats.task_total_ticks,stats.task_min_ticks,stats.task_max_ticks,stats.hns_per_tick);  
....................    //  rtos_stats(post_data); 
.................... } 
....................  
.................... void post_data_fail() 
.................... { 
....................    ack_log1=cip_start();   
3280:  CALL    29FE
3284:  MOV.B   W0L,9DF
....................    if(ack_log1==81) 
3286:  MOV.B   9DF,W0L
3288:  SE      W0,W0
328A:  MOV     #51,W4
328C:  CP      W4,W0
328E:  BRA     NZ,329E
....................    {   
....................       post_fail_count=0; 
3290:  CLR     9F2
....................       cip_close(); 
3292:  CALL    3166
....................       rtos_disable(post_data_fail); 
3296:  BSET.B  A8A.7
....................       rtos_enable(post_data); 
3298:  BCLR.B  A78.7
....................       rtos_enable(gps_rx); 
329A:  BCLR.B  AAE.7
.................... //      rtos_enable(post_status);    
....................       } 
329C:  BRA     32C2
....................    else{ 
....................       post_fail_count+=1; 
329E:  MOV     9F2,W4
32A0:  ADD     W4,#1,W0
32A2:  MOV     W0,9F2
....................       cip_close(); 
32A4:  CALL    3166
....................       if(post_fail_count>=5){ 
32A8:  MOV     9F2,W4
32AA:  CP      W4,#5
32AC:  BRA     LT,32C2
....................       output_bit(fet1,1); 
32AE:  BSET.B  2CC.6
32B0:  MOV     #FFBF,W4
32B2:  MOV     W4,2C8
....................       post_fail_count=0; 
32B4:  CLR     9F2
....................       init_var=0; 
32B6:  CLR.B   8BF
....................       jl=1; 
32B8:  MOV.B   #1,W0L
32BA:  MOV.B   W0L,9DB
....................       rtos_disable(post_data_fail); 
32BC:  BSET.B  A8A.7
....................       rtos_enable(boot); 
32BE:  BCLR.B  A54.7
....................       rtos_enable(post_data); 
32C0:  BCLR.B  A78.7
.................... //     rtos_enable(post_status);    
....................       } 
....................    } 
32C2:  MOV     #3280,W0
32C4:  MOV     W0,A90
32C6:  MOV     #0,W0
32C8:  MOV     W0,A92
32CA:  GOTO    380E
32CE:  RETURN  
.................... } 
....................  
.................... void battery_fail_check() 
.................... { 
.................... boolean x,x1; 
....................  
....................    x = input(pin_A1); 
32D0:  BSET.B  2C0.1
32D2:  BCLR.B  C58.0
32D4:  BTSC.B  2C2.1
32D6:  BSET.B  C58.0
....................    x1 = input(pin_A4); 
32D8:  BSET.B  2C0.4
32DA:  BCLR.B  C58.1
32DC:  BTSC.B  2C2.4
32DE:  BSET.B  C58.1
....................    p_s = x; 
32E0:  BCLR.B  8BC.4
32E2:  BTSC.B  C58.0
32E4:  BSET.B  8BC.4
....................    if(x ^ last_a){    
32E6:  CLR     W0
32E8:  BTSC.B  C58.0
32EA:  INC     W0,W0
32EC:  MOV.B   W0L,W6L
32EE:  CLR     W0
32F0:  BTSC.B  8BC.2
32F2:  INC     W0,W0
32F4:  XOR.B   W6L,W0L,W0L
32F6:  CP0.B   W0L
32F8:  BRA     Z,3300
....................    p_status=1;        
32FA:  MOV.B   #1,W0L
32FC:  MOV.B   W0L,92B
....................    }else   
32FE:  BRA     3318
....................    if(x1 ^ last_a4){ 
3300:  CLR     W0
3302:  BTSC.B  C58.1
3304:  INC     W0,W0
3306:  MOV.B   W0L,W6L
3308:  CLR     W0
330A:  BTSC.B  8BC.3
330C:  INC     W0,W0
330E:  XOR.B   W6L,W0L,W0L
3310:  CP0.B   W0L
3312:  BRA     Z,3318
....................    p_status=2;        
3314:  MOV.B   #2,W0L
3316:  MOV.B   W0L,92B
....................    }   
....................    last_a = x; 
3318:  BCLR.B  8BC.2
331A:  BTSC.B  C58.0
331C:  BSET.B  8BC.2
....................    last_a4 = x1; 
331E:  BCLR.B  8BC.3
3320:  BTSC.B  C58.1
3322:  BSET.B  8BC.3
3324:  MOV     #32D0,W0
3326:  MOV     W0,AA2
3328:  MOV     #0,W0
332A:  MOV     W0,AA4
332C:  GOTO    380E
3330:  RETURN  
.................... } 
.................... /* 
.................... void post_status() 
.................... { 
....................    fprintf(BUG,"ST\n\r");  
....................    ack_log1=cip_start();       
....................    if(ack_log1==81) 
....................    {      
....................       dir = 1; 
....................       post();      
....................       dir = 0; 
....................    }else{            
....................       cip_close(); 
....................       rtos_disable(post_data);    
....................       rtos_disable(post_status);    
....................       rtos_enable(post_data_fail);    
....................    } 
.................... }*/ 
....................  
.................... void NMEA_GPRMC() 
*
1410:  MOV     W5,[W15++]
.................... { 
....................    while(ptr!=0) {   
1412:  CP0     9B6
1414:  BRA     Z,1468
....................       if(nd == 1){nd++;s_time = strtok(0, term);} 
1416:  MOV.B   8C0,W0L
1418:  SE      W0,W0
141A:  CP      W0,#1
141C:  BRA     NZ,142C
141E:  INC.B   08C0
1420:  CLR     B5C
1422:  MOV     #9B8,W4
1424:  MOV     W4,B5E
1426:  CALL    AFC
142A:  MOV     W0,9BE
....................       if(nd == 2){nd++;lat = strtok(0, term);} 
142C:  MOV.B   8C0,W0L
142E:  SE      W0,W0
1430:  CP      W0,#2
1432:  BRA     NZ,1442
1434:  INC.B   08C0
1436:  CLR     B5C
1438:  MOV     #9B8,W4
143A:  MOV     W4,B5E
143C:  CALL    AFC
1440:  MOV     W0,9BA
....................       if(nd == 3){nd++;lon = strtok(0, term);} 
1442:  MOV.B   8C0,W0L
1444:  SE      W0,W0
1446:  CP      W0,#3
1448:  BRA     NZ,1458
144A:  INC.B   08C0
144C:  CLR     B5C
144E:  MOV     #9B8,W4
1450:  MOV     W4,B5E
1452:  CALL    AFC
1456:  MOV     W0,9BC
....................  //     if(nd == 7){nd++;s_date = strtok(0, term);} 
....................  //     if(nd == 8){nd++;s_date1 = strtok(0, term);} 
....................       ptr = strtok(0, term);   
1458:  CLR     B5C
145A:  MOV     #9B8,W4
145C:  MOV     W4,B5E
145E:  CALL    AFC
1462:  MOV     W0,9B6
....................       nd++; 
1464:  INC.B   08C0
1466:  BRA     1412
....................       } 
....................       f_lat = atof48(lat); 
1468:  PUSH    9BA
146A:  POP     B5C
146C:  CLR     B5E
146E:  CALL    F46
1472:  MOV     W1,A1E
1474:  MOV     W2,A20
....................       f_lon = atof48(lon);       
1476:  PUSH    9BC
1478:  POP     B5C
147A:  CLR     B5E
147C:  CALL    F46
1480:  MOV     W1,A22
1482:  MOV     W2,A24
....................       s_date_time = atoi48(s_time); 
1484:  PUSH    9BE
1486:  POP     B5C
1488:  CALL    10EA
148C:  MOV     W0,A00
148E:  MOV     W1,A02
1490:  MOV     W2,A04
....................       i_date = s_date_time / 1000000; 
1492:  BCLR.B  43.0
1494:  MOV     A00,W0
1496:  MOV     A02,W1
1498:  MOV     A04,W2
149A:  MOV     #4240,W3
149C:  MOV     #F,W4
149E:  MOV     #0,W5
14A0:  CALL    136E
14A4:  MOV     W0,9FC
14A6:  MOV     W1,9FE
....................       f_time = s_date_time % 1000000; 
14A8:  BSET.B  43.0
14AA:  MOV     A00,W0
14AC:  MOV     A02,W1
14AE:  MOV     A04,W2
14B0:  MOV     #4240,W3
14B2:  MOV     #F,W4
14B4:  MOV     #0,W5
14B6:  CALL    136E
14BA:  MOV     W0,9F8
14BC:  MOV     W1,9FA
....................        
.................... //      if(i_date < 500) 
.................... //      i_date = atoi32(s_date1); 
....................       fprintf(BUG,"GC-%s,%s,%s\n\r",s_time,lat,lon);  
14BE:  BTSC.B  223.1
14C0:  BRA     14BE
14C2:  MOV     #47,W4
14C4:  MOV     W4,224
14C6:  BTSC.B  223.1
14C8:  BRA     14C6
14CA:  MOV     #43,W4
14CC:  MOV     W4,224
14CE:  BTSC.B  223.1
14D0:  BRA     14CE
14D2:  MOV     #2D,W4
14D4:  MOV     W4,224
14D6:  MOV     9BE,W1
14D8:  CP0.B   [W1]
14DA:  BRA     Z,14EA
14DC:  BTSC.B  223.1
14DE:  BRA     14DC
14E0:  MOV.B   [W1+#0],W0L
14E2:  MOV.B   W0L,224
14E4:  CLR.B   225
14E6:  INC     W1,W1
14E8:  BRA     14D8
14EA:  BTSC.B  223.1
14EC:  BRA     14EA
14EE:  MOV     #2C,W4
14F0:  MOV     W4,224
14F2:  MOV     9BA,W1
14F4:  CP0.B   [W1]
14F6:  BRA     Z,1506
14F8:  BTSC.B  223.1
14FA:  BRA     14F8
14FC:  MOV.B   [W1+#0],W0L
14FE:  MOV.B   W0L,224
1500:  CLR.B   225
1502:  INC     W1,W1
1504:  BRA     14F4
1506:  BTSC.B  223.1
1508:  BRA     1506
150A:  MOV     #2C,W4
150C:  MOV     W4,224
150E:  MOV     9BC,W1
1510:  CP0.B   [W1]
1512:  BRA     Z,1522
1514:  BTSC.B  223.1
1516:  BRA     1514
1518:  MOV.B   [W1+#0],W0L
151A:  MOV.B   W0L,224
151C:  CLR.B   225
151E:  INC     W1,W1
1520:  BRA     1510
1522:  BTSC.B  223.1
1524:  BRA     1522
1526:  MOV     #A,W4
1528:  MOV     W4,224
152A:  BTSC.B  223.1
152C:  BRA     152A
152E:  MOV     #D,W4
1530:  MOV     W4,224
1532:  MOV     [--W15],W5
1534:  RETURN  
.................... } 
....................  
.................... void NMEA_GPVTG() 
.................... { 
....................    while(ptr!=0) {   
*
1862:  CP0     9B6
1864:  BRA     Z,188C
....................       if(nd == 4){nd++;speed_k = strtok(0, term);}          
1866:  MOV.B   8C0,W0L
1868:  SE      W0,W0
186A:  CP      W0,#4
186C:  BRA     NZ,187C
186E:  INC.B   08C0
1870:  CLR     B5C
1872:  MOV     #9B8,W4
1874:  MOV     W4,B5E
1876:  CALL    AFC
187A:  MOV     W0,9C4
....................       ptr = strtok(0, term);   
187C:  CLR     B5C
187E:  MOV     #9B8,W4
1880:  MOV     W4,B5E
1882:  CALL    AFC
1886:  MOV     W0,9B6
....................       nd++; 
1888:  INC.B   08C0
188A:  BRA     1862
....................       } 
188C:  RETURN  
.................... //      fprintf(BUG,"GV-%s\n\r",speed_k);    
.................... } 
....................  
.................... void NMEA_GPGLL() 
.................... { 
....................    while(ptr!=0) {   
*
1762:  CP0     9B6
1764:  BRA     Z,17B8
....................       if(nd == 0){nd++;lat = strtok(0, term);} 
1766:  MOV.B   8C0,W0L
1768:  SE      W0,W0
176A:  CP0     W0
176C:  BRA     NZ,177C
176E:  INC.B   08C0
1770:  CLR     B5C
1772:  MOV     #9B8,W4
1774:  MOV     W4,B5E
1776:  CALL    AFC
177A:  MOV     W0,9BA
....................       if(nd == 2){nd++;lon = strtok(0, term);} 
177C:  MOV.B   8C0,W0L
177E:  SE      W0,W0
1780:  CP      W0,#2
1782:  BRA     NZ,1792
1784:  INC.B   08C0
1786:  CLR     B5C
1788:  MOV     #9B8,W4
178A:  MOV     W4,B5E
178C:  CALL    AFC
1790:  MOV     W0,9BC
....................       if(nd == 4){nd++;s_time = strtok(0, term);}       
1792:  MOV.B   8C0,W0L
1794:  SE      W0,W0
1796:  CP      W0,#4
1798:  BRA     NZ,17A8
179A:  INC.B   08C0
179C:  CLR     B5C
179E:  MOV     #9B8,W4
17A0:  MOV     W4,B5E
17A2:  CALL    AFC
17A6:  MOV     W0,9BE
....................       ptr = strtok(0, term);   
17A8:  CLR     B5C
17AA:  MOV     #9B8,W4
17AC:  MOV     W4,B5E
17AE:  CALL    AFC
17B2:  MOV     W0,9B6
....................       nd++; 
17B4:  INC.B   08C0
17B6:  BRA     1762
....................       } 
....................       f_lat = atof48(lat); 
17B8:  PUSH    9BA
17BA:  POP     B5C
17BC:  CLR     B5E
17BE:  CALL    F46
17C2:  MOV     W1,A1E
17C4:  MOV     W2,A20
....................       f_lon = atof48(lon); 
17C6:  PUSH    9BC
17C8:  POP     B5C
17CA:  CLR     B5E
17CC:  CALL    F46
17D0:  MOV     W1,A22
17D2:  MOV     W2,A24
....................       f_time = atoi32(s_time); 
17D4:  PUSH    9BE
17D6:  POP     B5C
17D8:  CALL    1578
17DC:  MOV     W0,9F8
17DE:  MOV     W1,9FA
17E0:  RETURN  
.................... //      fprintf(BUG,"GL-%s,%s,%s\n\r",time,lat,lon);     
.................... } 
....................  
.................... void NMEA_GPGGA() 
.................... { 
....................    while(ptr!=0) {   
17E2:  CP0     9B6
17E4:  BRA     Z,1838
....................       if(nd == 0){nd++;s_time = strtok(0, term);} 
17E6:  MOV.B   8C0,W0L
17E8:  SE      W0,W0
17EA:  CP0     W0
17EC:  BRA     NZ,17FC
17EE:  INC.B   08C0
17F0:  CLR     B5C
17F2:  MOV     #9B8,W4
17F4:  MOV     W4,B5E
17F6:  CALL    AFC
17FA:  MOV     W0,9BE
....................       if(nd == 1){nd++;lat = strtok(0, term);} 
17FC:  MOV.B   8C0,W0L
17FE:  SE      W0,W0
1800:  CP      W0,#1
1802:  BRA     NZ,1812
1804:  INC.B   08C0
1806:  CLR     B5C
1808:  MOV     #9B8,W4
180A:  MOV     W4,B5E
180C:  CALL    AFC
1810:  MOV     W0,9BA
....................       if(nd == 3){nd++;lon = strtok(0, term);} 
1812:  MOV.B   8C0,W0L
1814:  SE      W0,W0
1816:  CP      W0,#3
1818:  BRA     NZ,1828
181A:  INC.B   08C0
181C:  CLR     B5C
181E:  MOV     #9B8,W4
1820:  MOV     W4,B5E
1822:  CALL    AFC
1826:  MOV     W0,9BC
....................       ptr = strtok(0, term);   
1828:  CLR     B5C
182A:  MOV     #9B8,W4
182C:  MOV     W4,B5E
182E:  CALL    AFC
1832:  MOV     W0,9B6
....................       nd++; 
1834:  INC.B   08C0
1836:  BRA     17E2
....................       } 
....................       f_lat = atof48(lat); 
1838:  PUSH    9BA
183A:  POP     B5C
183C:  CLR     B5E
183E:  CALL    F46
1842:  MOV     W1,A1E
1844:  MOV     W2,A20
....................       f_lon = atof48(lon); 
1846:  PUSH    9BC
1848:  POP     B5C
184A:  CLR     B5E
184C:  CALL    F46
1850:  MOV     W1,A22
1852:  MOV     W2,A24
....................       f_time = atoi32(s_time); 
1854:  PUSH    9BE
1856:  POP     B5C
1858:  CALL    1578
185C:  MOV     W0,9F8
185E:  MOV     W1,9FA
1860:  RETURN  
.................... //      fprintf(BUG,"GA-%s,%s,%s\n\r",s_time,lat,lon);    
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... void main ( ) 
*
33F0:  MOV     #2700,W15
33F2:  MOV     #27FF,W0
33F4:  MOV     W0,20
33F6:  NOP     
33F8:  MOV     #4444,W0
33FA:  MOV     W0,A8
33FC:  MOV     #4444,W0
33FE:  MOV     W0,AC
3400:  BSET.B  81.7
3402:  DISI    #6
3404:  MOV     #742,W1
3406:  MOV     #46,W2
3408:  MOV     #57,W3
340A:  MOV.B   W2L,[W1]
340C:  MOV.B   W3L,[W1]
340E:  BCLR.B  742.6
3410:  MOV     #3F0F,W0
3412:  MOV     W0,6A4
3414:  MOV     #3F05,W0
3416:  MOV     W0,6A6
3418:  MOV     #5,W0
341A:  MOV     W0,6C4
341C:  MOV     #3,W0
341E:  MOV     W0,6CE
3420:  DISI    #6
3422:  MOV     #742,W1
3424:  MOV     #46,W2
3426:  MOV     #57,W3
3428:  MOV.B   W2L,[W1]
342A:  MOV.B   W3L,[W1]
342C:  BSET.B  742.6
342E:  MOV     #3,W4
3430:  MOV     W4,802
3432:  CLR     8BA
3434:  MOV     #8000,W4
3436:  MOV     W4,220
3438:  MOV     #400,W4
343A:  MOV     W4,222
343C:  BSET.B  220.3
343E:  MOV     #22,W4
3440:  MOV     W4,228
3442:  MOV     #8000,W4
3444:  MOV     W4,230
3446:  MOV     #400,W4
3448:  MOV     W4,232
344A:  BSET.B  230.3
344C:  MOV     #22,W4
344E:  MOV     W4,238
3450:  BCLR.B  8BC.0
3452:  BCLR.B  8BC.1
3454:  BCLR.B  8BC.2
3456:  BCLR.B  8BC.3
3458:  BCLR.B  8BC.4
345A:  CLR.B   8BD
345C:  CLR.B   8BE
345E:  CLR.B   8BF
3460:  CLR.B   8C0
3462:  CLR.B   8C1
3464:  CLR.B   8FE
3466:  MOV.B   #22,W0L
3468:  MOV.B   W0L,8FF
346A:  MOV.B   #D,W0L
346C:  MOV.B   W0L,900
346E:  MOV.B   #1A,W0L
3470:  MOV.B   W0L,901
3472:  MOV.B   #A,W0L
3474:  MOV.B   W0L,902
3476:  CLR     9B6
3478:  CLR     9BA
347A:  CLR     9BC
347C:  CLR     9BE
347E:  CLR     9C0
3480:  CLR     9C2
3482:  CLR.B   903
3484:  CLR.B   92B
3486:  CLR.B   9DA
3488:  MOV.B   #1,W0L
348A:  MOV.B   W0L,9DB
348C:  MOV.B   #1,W0L
348E:  MOV.B   W0L,9DC
3490:  MOV.B   #5,W0L
3492:  MOV.B   W0L,9DD
3494:  CLR.B   9DE
3496:  CLR.B   9DF
3498:  CLR     9E2
349A:  CLR     9E4
349C:  CLR     9E6
349E:  CLR     9E8
34A0:  CLR     9EA
34A2:  CLR     9EC
34A4:  CLR     9EE
34A6:  CLR     9F0
34A8:  CLR     9F2
34AA:  CLR     9F4
34AC:  CLR     9F6
34AE:  CLR     9F8
34B0:  CLR     9FA
34B2:  CLR     9FC
34B4:  CLR     9FE
34B6:  CLR     A0E
34B8:  CLR     A10
34BA:  CLR     A12
34BC:  CLR     A14
34BE:  CLR     A16
34C0:  CLR     A18
34C2:  CLR     A1A
34C4:  CLR     A1C
34C6:  CLR     A1E
34C8:  CLR     A20
34CA:  CLR     A22
34CC:  CLR     A24
34CE:  CLR     A26
34D0:  CLR     A28
34D2:  CLR     A2A
34D4:  CLR     A2C
34D6:  CLR     A2E
34D8:  CLR     A30
34DA:  CLR     A32
34DC:  CLR     A34
34DE:  CLR     A36
34E0:  CLR     A38
34E2:  CLR     A42
34E4:  CLR     A44
34E6:  CLR     A46
34E8:  CLR     A48
34EA:  CLR     AC0
34EC:  SETM    32C
34EE:  BRA     35C0
34F0:  DATA    C0,08,08
34F2:  DATA    04,00,00
34F4:  DATA    4B,F0,3F
34F6:  DATA    5C,0A,58
34F8:  DATA    F6,3B,8F
34FA:  DATA    00,C0,3C
34FC:  DATA    8B,28,AC
34FE:  DATA    3C,BE,F6
3500:  DATA    3F,D2,D5
3502:  DATA    44,16,8C
3504:  DATA    15,D7,BF
3506:  DATA    69,00,5A
3508:  DATA    2E,1B,87
350A:  DATA    99,3F,9A
350C:  DATA    5F,AD,4B
350E:  DATA    91,E4,01
3510:  DATA    C0,5D,11
3512:  DATA    2F,92,E4
3514:  DATA    81,FB,3F
3516:  DATA    38,DA,91
3518:  DATA    80,9D,C5
351A:  DATA    E0,BF,6F
351C:  DATA    12,C0,B4
351E:  DATA    C3,09,AB
3520:  DATA    3F,6B,C1
3522:  DATA    03,4E,C1
3524:  DATA    B5,45,BF
3526:  DATA    F7,40,05
3528:  DATA    FF,00,5A
352A:  DATA    EF,3F,F3
352C:  DATA    A3,E2,F7
352E:  DATA    D7,FF,01
3530:  DATA    40,C0,B4
3532:  DATA    FF,05,3C
3534:  DATA    58,FC,3F
3536:  DATA    3B,D3,C0
3538:  DATA    B5,BA,8C
353A:  DATA    E2,3F,39
353C:  DATA    D3,C7,3D
353E:  DATA    41,79,B2
3540:  DATA    3F,87,0D
3542:  DATA    3C,50,D0
3544:  DATA    AF,62,3F
3546:  DATA    30,4B,8D
3548:  DATA    A2,82,AA
354A:  DATA    04,40,09
354C:  DATA    A0,40,4A
354E:  DATA    05,76,03
3550:  DATA    40,EC,9E
3552:  DATA    37,88,A6
3554:  DATA    44,F0,3F
3556:  DATA    8F,12,8D
3558:  DATA    29,9A,5B
355A:  DATA    C7,3F,0E
355C:  DATA    E0,80,7C
355E:  DATA    A1,D8,86
3560:  DATA    3F,29,4B
3562:  DATA    FB,95,C2
3564:  DATA    37,1A,3F
3566:  DATA    C0,3C,08
3568:  DATA    C2,00,80
356A:  DATA    03,09,04
356C:  DATA    4F,4B,00
356E:  DATA    80,23,09
3570:  DATA    08,43,53
3572:  DATA    54,54,61
3574:  DATA    69,72,74
3576:  DATA    65,6C,67
3578:  DATA    70,72,73
357A:  DATA    63,6F,6D
357C:  DATA    00,4F,4B
357E:  DATA    53,54,41
3580:  DATA    54,45,49
3582:  DATA    50,49,4E
3584:  DATA    49,54,49
3586:  DATA    41,4C,00
3588:  DATA    80,1B,09
358A:  DATA    2C,4F,4B
358C:  DATA    43,4F,4E
358E:  DATA    4E,45,43
3590:  DATA    54,4F,4B
3592:  DATA    00,43,47
3594:  DATA    52,45,47
3596:  DATA    30,31,00
3598:  DATA    43,47,52
359A:  DATA    45,47,30
359C:  DATA    35,40,6F
359E:  DATA    00,C0,14
35A0:  DATA    09,C6,00
35A2:  DATA    00,00,00
35A4:  INC     W2,W2
35A6:  CP      W2,#1
35A8:  BRA     NZ,35B2
35AA:  TBLRDL  [W1],W3
35AC:  TBLRDH  [W1++],W4
35AE:  MOV.B   6,W0L
35B0:  RETURN  
35B2:  CP      W2,#2
35B4:  BRA     NZ,35BA
35B6:  MOV.B   7,W0L
35B8:  RETURN  
35BA:  MOV.B   8,W0L
35BC:  CLR     W2
35BE:  RETURN  
35C0:  MOV     #0,W6
35C2:  MOV     #0,W0
35C4:  MOV     W0,32
35C6:  MOV     #34F0,W0
35C8:  MOV     W0,W1
35CA:  CLR     W2
35CC:  CALL    35A4
35D0:  MOV.B   W0L,B
35D2:  CALL    35A4
35D6:  MOV.B   W0L,A
35D8:  CP0     W5
35DA:  BRA     Z,360E
35DC:  BTSS    W5.F
35DE:  BRA     35EE
35E0:  CALL    35A4
35E4:  MOV.B   W0L,D
35E6:  CALL    35A4
35EA:  MOV.B   W0L,C
35EC:  BCLR    W5.F
35EE:  BTSS    W5.E
35F0:  BRA     3602
35F2:  BCLR    W5.E
35F4:  DEC     W5,W5
35F6:  CALL    35A4
35FA:  MOV.B   W0L,W7L
35FC:  REPEAT  W5
35FE:  MOV.B   W7L,[W6++]
3600:  BRA     35CC
3602:  CALL    35A4
3606:  MOV.B   W0L,[W6++]
3608:  DEC     W5,W5
360A:  BRA     NZ,3602
360C:  BRA     35CC
.................... { 
.................... //   setup_oscillator(OSC_INTERNAL);       
.................... //   set_tris_b( 0x00 ); 
....................    set_pullup(true,pin_b6); 
360E:  BSET.B  6B.0
.................... //   set_pullup(false,pin_b15);  
....................    last_a = input_state(pin_A1); 
3610:  BCLR.B  8BC.2
3612:  BTSC.B  2C2.1
3614:  BSET.B  8BC.2
....................    last_a4 = input_state(pin_A4); 
3616:  BCLR.B  8BC.3
3618:  BTSC.B  2C2.4
361A:  BSET.B  8BC.3
....................     
....................    delay_ms(2000); 
361C:  MOV     #7D0,W0
361E:  CALL    33E0
.................... //   enable_interrupts(global); 
.................... //   enable_interrupts(INT_CNI); 
.................... //   enable_interrupts(INTR_CN_PIN | PIN_A1); 
.................... //   enable_interrupts(int_rda); 
.................... //   disable_interrupts(int_rda2); 
....................  //  setup_timer2(TMR_INTERNAL | TMR_DIV_BY_64); 
.................... //   set_timer2(0);  
....................     
.................... //   setup_adc_ports( sAN0 ); 
.................... //   setup_adc(ADC_CLOCK_INTERNAL ); 
.................... //   set_adc_channel( 0 ); 
....................  
.................... //   port_b_pullups(true);     
....................    output_high(fet1); 
3622:  MOV     #FFBF,W4
3624:  MOV     W4,2C8
3626:  BSET.B  2CC.6
....................    delay_ms(1000); 
3628:  MOV     #3E8,W0
362A:  CALL    33E0
....................    output_low(fet1); 
362E:  MOV     #FFBF,W4
3630:  MOV     W4,2C8
3632:  BCLR.B  2CC.6
.................... //   output_low(led1);output_high(led2); 
.................... //   output_low(led4);output_high(led3); 
....................   // fprintf(GPS"Hello World"); 
....................  
....................    switch ( restart_cause() ) { 
3634:  MOV     #C0D3,W0
3636:  AND     740,W0
3638:  MOV     W0,W1
363A:  MOV     #FFFF,W0
363C:  INC     W0,W0
363E:  LSR     W1,W1
3640:  BSET.B  3.7
3642:  BTSS.B  42.0
3644:  BRA     363C
3646:  MOV     W0,W1
3648:  MOV     #3D20,W0
364A:  AND     740
364C:  MOV     W1,W0
364E:  XOR     #0,W0
3650:  BRA     Z,366C
3652:  XOR     #1,W0
3654:  BRA     Z,3696
3656:  XOR     #5,W0
3658:  BRA     Z,36B0
365A:  XOR     #2,W0
365C:  BRA     Z,36CA
365E:  XOR     #1,W0
3660:  BRA     Z,36E4
3662:  XOR     #9,W0
3664:  BRA     Z,36FE
3666:  XOR     #1,W0
3668:  BRA     Z,3718
366A:  BRA     3732
....................    case RESTART_POWER_UP:delay_ms(10000);  
366C:  MOV     #2710,W0
366E:  CALL    33E0
.................... //                        if(init_gsm_1(1))init_gsm_1(2);                         
....................                         fprintf(GSM,"ATE0%c",enter); 
3672:  MOV     #0,W1
3674:  MOV     W1,W0
3676:  CLR.B   1
3678:  CALL    200
367C:  INC     W1,W1
367E:  BTSC.B  233.1
3680:  BRA     367E
3682:  MOV     W0,234
3684:  MOV     #3,W0
3686:  CPSGT   W1,W0
3688:  BRA     3674
368A:  BTSC.B  233.1
368C:  BRA     368A
368E:  MOV.B   900,W0L
3690:  MOV.B   W0L,234
3692:  CLR.B   235
.................... //                        init_gsm_1(2); 
.................... //                        delay_ms(10); 
.................... //                        fprintf(GSM,"AT+CGREG=1%c",enter); 
.................... //                        delay_ms(10); 
.................... //                        reset_cpu(); 
....................                         break;  
3694:  BRA     3732
....................    case RESTART_BROWNOUT:fprintf(BUG,"BOOT 1\n\r"); 
3696:  MOV     #0,W1
3698:  MOV     W1,W0
369A:  CLR.B   1
369C:  CALL    42A
36A0:  INC     W1,W1
36A2:  BTSC.B  223.1
36A4:  BRA     36A2
36A6:  MOV     W0,224
36A8:  MOV     #7,W0
36AA:  CPSGT   W1,W0
36AC:  BRA     3698
....................                         break;  
36AE:  BRA     3732
....................    case RESTART_WATCHDOG:fprintf(BUG,"BOOT 2\n\r");   
36B0:  MOV     #0,W1
36B2:  MOV     W1,W0
36B4:  CLR.B   1
36B6:  CALL    440
36BA:  INC     W1,W1
36BC:  BTSC.B  223.1
36BE:  BRA     36BC
36C0:  MOV     W0,224
36C2:  MOV     #7,W0
36C4:  CPSGT   W1,W0
36C6:  BRA     36B2
....................                         break;  
36C8:  BRA     3732
....................    case RESTART_SOFTWARE:fprintf(BUG,"BOOT 3\n\r"); 
36CA:  MOV     #0,W1
36CC:  MOV     W1,W0
36CE:  CLR.B   1
36D0:  CALL    456
36D4:  INC     W1,W1
36D6:  BTSC.B  223.1
36D8:  BRA     36D6
36DA:  MOV     W0,224
36DC:  MOV     #7,W0
36DE:  CPSGT   W1,W0
36E0:  BRA     36CC
....................                         break;  
36E2:  BRA     3732
....................    case RESTART_MCLR :  fprintf(BUG,"BOOT 4\n\r"); 
36E4:  MOV     #0,W1
36E6:  MOV     W1,W0
36E8:  CLR.B   1
36EA:  CALL    46C
36EE:  INC     W1,W1
36F0:  BTSC.B  223.1
36F2:  BRA     36F0
36F4:  MOV     W0,224
36F6:  MOV     #7,W0
36F8:  CPSGT   W1,W0
36FA:  BRA     36E6
....................                         break;    
36FC:  BRA     3732
....................    case RESTART_ILLEGAL_OP:fprintf(BUG,"BOOT 5\n\r"); 
36FE:  MOV     #0,W1
3700:  MOV     W1,W0
3702:  CLR.B   1
3704:  CALL    482
3708:  INC     W1,W1
370A:  BTSC.B  223.1
370C:  BRA     370A
370E:  MOV     W0,224
3710:  MOV     #7,W0
3712:  CPSGT   W1,W0
3714:  BRA     3700
....................                         break; 
3716:  BRA     3732
....................    case RESTART_TRAP_CONFLICT:fprintf(BUG,"BOOT 6\n\r"); 
3718:  MOV     #0,W1
371A:  MOV     W1,W0
371C:  CLR.B   1
371E:  CALL    498
3722:  INC     W1,W1
3724:  BTSC.B  223.1
3726:  BRA     3724
3728:  MOV     W0,224
372A:  MOV     #7,W0
372C:  CPSGT   W1,W0
372E:  BRA     371A
....................                         break; 
3730:  BRA     3732
....................    }   
.................... //   output_low(led1); 
.................... //   output_low(led2); 
.................... //   output_low(led3); 
.................... //   output_low(led4);       
....................       
....................    rtos_run(); 
3732:  CLR     A54
3734:  MOV     #5,W4
3736:  MOV     W4,A56
3738:  CLR     A58
373A:  CLR     A5E
373C:  CLR     A60
373E:  SETM    A62
3740:  CLR     A64
3742:  MOV     #9E0,W0
3744:  MOV     W0,A5A
3746:  MOV     #0,W0
3748:  MOV     W0,A5C
374A:  CLR     A66
374C:  MOV     #14,W4
374E:  MOV     W4,A68
3750:  CLR     A6A
3752:  CLR     A70
3754:  CLR     A72
3756:  SETM    A74
3758:  CLR     A76
375A:  MOV     #28E8,W0
375C:  MOV     W0,A6C
375E:  MOV     #0,W0
3760:  MOV     W0,A6E
3762:  MOV     #80,W4
3764:  MOV     W4,A78
3766:  MOV     #64,W4
3768:  MOV     W4,A7A
376A:  CLR     A7C
376C:  CLR     A82
376E:  CLR     A84
3770:  SETM    A86
3772:  CLR     A88
3774:  MOV     #318A,W0
3776:  MOV     W0,A7E
3778:  MOV     #0,W0
377A:  MOV     W0,A80
377C:  MOV     #80,W4
377E:  MOV     W4,A8A
3780:  MOV     #F,W4
3782:  MOV     W4,A8C
3784:  CLR     A8E
3786:  CLR     A94
3788:  CLR     A96
378A:  SETM    A98
378C:  CLR     A9A
378E:  MOV     #3280,W0
3790:  MOV     W0,A90
3792:  MOV     #0,W0
3794:  MOV     W0,A92
3796:  CLR     A9C
3798:  MOV     #3,W4
379A:  MOV     W4,A9E
379C:  CLR     AA0
379E:  CLR     AA6
37A0:  CLR     AA8
37A2:  SETM    AAA
37A4:  CLR     AAC
37A6:  MOV     #32D0,W0
37A8:  MOV     W0,AA2
37AA:  MOV     #0,W0
37AC:  MOV     W0,AA4
37AE:  MOV     #80,W4
37B0:  MOV     W4,AAE
37B2:  MOV     #A,W4
37B4:  MOV     W4,AB0
37B6:  CLR     AB2
37B8:  CLR     AB8
37BA:  CLR     ABA
37BC:  SETM    ABC
37BE:  CLR     ABE
37C0:  MOV     #2902,W0
37C2:  MOV     W0,AB4
37C4:  MOV     #0,W0
37C6:  MOV     W0,AB6
37C8:  CLR     800
37CA:  CLR     104
37CC:  MOV     #30D4,W4
37CE:  MOV     W4,102
37D0:  MOV     #A020,W4
37D2:  MOV     W4,104
37D4:  CLR     100
37D6:  BCLR.B  84.3
37D8:  MOV     #1,W4
37DA:  MOV     W4,802
37DC:  MOV     800,W1
37DE:  SL      W1,#1,W1
37E0:  MOV     W1,W0
37E2:  CALL    4AE
37E6:  MOV.B   W0L,W2L
37E8:  ADD.B   W1L,#1,W0L
37EA:  CALL    4AE
37EE:  MOV.B   W0L,5
37F0:  MOV     W2,W6
37F2:  MOV     [W6++],W1
37F4:  MOV     [W6],W2
37F6:  INC     [++W6],[W6]
37F8:  MOV     [W6],W0
37FA:  SUB     W0,W2,W0
37FC:  BTSS.B  42.1
37FE:  BRA     3854
3800:  CLR     [W6++]
3802:  BTSC    W1.7
3804:  BRA     3854
3806:  MOV     [W6++],[W15++]
3808:  MOV     #0,W0
380A:  MOV     W0,[W15++]
380C:  RETURN  
380E:  MOV     800,W1
3810:  SL      W1,#1,W1
3812:  MOV     W1,W0
3814:  CALL    4AE
3818:  MOV.B   W0L,W2L
381A:  ADD.B   W1L,#1,W0L
381C:  CALL    4AE
3820:  MOV.B   W0L,5
3822:  MOV     W2,W6
3824:  BCLR    [W6].4
3826:  BTSC.B  84.3
3828:  BSET    [W6].4
382A:  MOV     100,W0
382C:  BTSS.B  84.3
382E:  BRA     3834
3830:  MOV     #30D4,W1
3832:  ADD     W0,W1,W0
3834:  MOV     W0,W1
3836:  ADD     W6,#A,W6
3838:  MOV     [W6],W4
383A:  ADD     W4,W0,[W6++]
383C:  BTSC.B  42.0
383E:  INC     [W6],[W6]
3840:  INC2    W6,W6
3842:  MOV     [W6],W0
3844:  SUB     W0,W1,W0
3846:  BTSC.B  42.0
3848:  MOV     W1,[W6]
384A:  INC2    W6,W6
384C:  MOV     [W6],W0
384E:  SUB     W0,W1,W0
3850:  BTSS.B  42.0
3852:  MOV     W1,[W6]
3854:  INC     0800
3856:  MOV     #6,W0
3858:  SUB     800,W0
385A:  BTSS.B  42.1
385C:  BRA     37DC
385E:  CLR     800
3860:  MOV     100,W0
3862:  BTSC.B  84.3
3864:  BRA     37D4
3866:  BRA     3860
3868:  SETM    800
.................... }    
.................... //------------------------------------------------------------------------------ 
386A:  PWRSAV  #0
....................  
.................... void process() 
*
2482:  MOV     W5,[W15++]
2484:  MOV     W6,[W15++]
.................... {   
.................... p_hrs = 5; 
2486:  MOV.B   #5,W0L
2488:  MOV.B   W0L,9DD
.................... int8 clng=0,ip=0; 
.................... char sstring[110]={},nmea[8]="CGNSINF",nmea1[7]="$GPGLL",nmea2[7]="$GPGGA",nmea3[7]="$GPVTG"; 
248A:  CLR.B   ACC
248C:  CLR.B   ACD
248E:  CLR     ACE
2490:  CLR     AD0
2492:  CLR     AD2
2494:  CLR     AD4
2496:  CLR     AD6
2498:  CLR     AD8
249A:  CLR     ADA
249C:  CLR     ADC
249E:  CLR     ADE
24A0:  CLR     AE0
24A2:  CLR     AE2
24A4:  CLR     AE4
24A6:  CLR     AE6
24A8:  CLR     AE8
24AA:  CLR     AEA
24AC:  CLR     AEC
24AE:  CLR     AEE
24B0:  CLR     AF0
24B2:  CLR     AF2
24B4:  CLR     AF4
24B6:  CLR     AF6
24B8:  CLR     AF8
24BA:  CLR     AFA
24BC:  CLR     AFC
24BE:  CLR     AFE
24C0:  CLR     B00
24C2:  CLR     B02
24C4:  CLR     B04
24C6:  CLR     B06
24C8:  CLR     B08
24CA:  CLR     B0A
24CC:  CLR     B0C
24CE:  CLR     B0E
24D0:  CLR     B10
24D2:  CLR     B12
24D4:  CLR     B14
24D6:  CLR     B16
24D8:  CLR     B18
24DA:  CLR     B1A
24DC:  CLR     B1C
24DE:  CLR     B1E
24E0:  CLR     B20
24E2:  CLR     B22
24E4:  CLR     B24
24E6:  CLR     B26
24E8:  CLR     B28
24EA:  CLR     B2A
24EC:  CLR     B2C
24EE:  CLR     B2E
24F0:  CLR     B30
24F2:  CLR     B32
24F4:  CLR     B34
24F6:  CLR     B36
24F8:  CLR     B38
24FA:  CLR     B3A
24FC:  MOV     #4743,W4
24FE:  MOV     W4,B3C
2500:  MOV     #534E,W4
2502:  MOV     W4,B3E
2504:  MOV     #4E49,W4
2506:  MOV     W4,B40
2508:  MOV     #46,W4
250A:  MOV     W4,B42
250C:  MOV     #4724,W4
250E:  MOV     W4,B44
2510:  MOV     #4750,W4
2512:  MOV     W4,B46
2514:  MOV     #4C4C,W4
2516:  MOV     W4,B48
2518:  CLR.B   B4A
251A:  MOV     #4724,W4
251C:  MOV     W4,B4C
251E:  MOV     #4750,W4
2520:  MOV     W4,B4E
2522:  MOV     #4147,W4
2524:  MOV     W4,B50
2526:  CLR.B   B52
2528:  MOV     #4724,W4
252A:  MOV     W4,B54
252C:  MOV     #5650,W4
252E:  MOV     W4,B56
2530:  MOV     #4754,W4
2532:  MOV     W4,B58
2534:  CLR.B   B5A
....................    nd=0; 
2536:  CLR.B   8C0
.................... //   strcpy(string3,"$GPRMC,073004.00,A,1120.62884,N,07743.04195,E,0.009,,070815,,,A*7E");    
....................    strcpy(term,","); 
2538:  MOV     #0,W2
253A:  MOV     #9B8,W1
253C:  MOV     W2,W0
253E:  CALL    4C6
2542:  MOV.B   W0L,[W1++]
2544:  INC     W2,W2
2546:  CP0.B   W0L
2548:  BTSS.B  42.1
254A:  BRA     253C
....................    if(timeout_error_2 == true){  
254C:  BTSS.B  8BC.1
254E:  BRA     265C
....................    clng = strlen(string3); 
2550:  MOV     #948,W4
2552:  MOV     W4,B66
2554:  CALL    A66
2558:  MOV.B   W0L,ACC
....................    strcpy(sstring,string3);   
255A:  MOV     #ACE,W1
255C:  MOV     #948,W2
255E:  MOV.B   [W2++],[W1]
2560:  CP0.B   [W1++]
2562:  BTSS.B  42.1
2564:  BRA     255E
....................    fprintf(BUG,"L-%s>%u\n\r",sstring,clng);                                          //&& string3[strlen (string3)] == 0x0a 
2566:  BTSC.B  223.1
2568:  BRA     2566
256A:  MOV     #4C,W4
256C:  MOV     W4,224
256E:  BTSC.B  223.1
2570:  BRA     256E
2572:  MOV     #2D,W4
2574:  MOV     W4,224
2576:  MOV     #ACE,W1
2578:  CP0.B   [W1]
257A:  BRA     Z,258A
257C:  BTSC.B  223.1
257E:  BRA     257C
2580:  MOV.B   [W1+#0],W0L
2582:  MOV.B   W0L,224
2584:  CLR.B   225
2586:  INC     W1,W1
2588:  BRA     2578
258A:  BTSC.B  223.1
258C:  BRA     258A
258E:  MOV     #3E,W4
2590:  MOV     W4,224
2592:  MOV.B   ACC,W0L
2594:  CLR.B   1
2596:  MOV     #0,W4
2598:  CALL    50C
259C:  BTSC.B  223.1
259E:  BRA     259C
25A0:  MOV     #A,W4
25A2:  MOV     W4,224
25A4:  BTSC.B  223.1
25A6:  BRA     25A4
25A8:  MOV     #D,W4
25AA:  MOV     W4,224
....................    ptr = strtok(sstring, term); 
25AC:  MOV     #ACE,W4
25AE:  MOV     W4,B5C
25B0:  MOV     #9B8,W4
25B2:  MOV     W4,B5E
25B4:  CALL    AFC
25B8:  MOV     W0,9B6
....................    if(!strncmp(sstring,nmea,7) && clng >= 62)NMEA_GPRMC();    
25BA:  MOV     #ACE,W4
25BC:  MOV     W4,C54
25BE:  MOV     #B3C,W4
25C0:  MOV     W4,C56
25C2:  MOV     #7,W4
25C4:  MOV     W4,C58
25C6:  CALL    60C
25CA:  CP0.B   W0L
25CC:  BRA     NZ,25DC
25CE:  MOV.B   ACC,W0L
25D0:  SE      W0,W0
25D2:  MOV     #3E,W4
25D4:  CP      W4,W0
25D6:  BRA     GT,25DC
25D8:  CALL    1410
....................    if(!strncmp(sstring,nmea1,6) && clng >= 30)NMEA_GPGLL();    
25DC:  MOV     #ACE,W4
25DE:  MOV     W4,C54
25E0:  MOV     #B44,W4
25E2:  MOV     W4,C56
25E4:  MOV     #6,W4
25E6:  MOV     W4,C58
25E8:  CALL    60C
25EC:  CP0.B   W0L
25EE:  BRA     NZ,25FC
25F0:  MOV.B   ACC,W0L
25F2:  SE      W0,W0
25F4:  CP      W0,#1E
25F6:  BRA     LT,25FC
25F8:  CALL    1762
....................    if(!strncmp(sstring,nmea2,6) && clng >= 50)NMEA_GPGGA();    
25FC:  MOV     #ACE,W4
25FE:  MOV     W4,C54
2600:  MOV     #B4C,W4
2602:  MOV     W4,C56
2604:  MOV     #6,W4
2606:  MOV     W4,C58
2608:  CALL    60C
260C:  CP0.B   W0L
260E:  BRA     NZ,261E
2610:  MOV.B   ACC,W0L
2612:  SE      W0,W0
2614:  MOV     #32,W4
2616:  CP      W4,W0
2618:  BRA     GT,261E
261A:  CALL    17E2
....................    if(!strncmp(sstring,nmea3,6) && clng >= 30)NMEA_GPVTG();  
261E:  MOV     #ACE,W4
2620:  MOV     W4,C54
2622:  MOV     #B54,W4
2624:  MOV     W4,C56
2626:  MOV     #6,W4
2628:  MOV     W4,C58
262A:  CALL    60C
262E:  CP0.B   W0L
2630:  BRA     NZ,263E
2632:  MOV.B   ACC,W0L
2634:  SE      W0,W0
2636:  CP      W0,#1E
2638:  BRA     LT,263E
263A:  CALL    1862
....................  
.................... for(ip=0;ip<=j;ip++)  
263E:  CLR.B   ACD
2640:  MOV.B   ACD,W0L
2642:  MOV     8BC,W4
2644:  LSR     W4,#8,W4
2646:  CP.B    W4L,W0L
2648:  BRA     LT,2658
....................       string3[ip]=0; 
264A:  MOV.B   ACD,W0L
264C:  SE      W0,W0
264E:  MOV     #948,W4
2650:  ADD     W0,W4,W5
2652:  CLR.B   [W5]
2654:  INC.B   0ACD
2656:  BRA     2640
....................       j=0;       
2658:  CLR.B   8BD
....................       timeout_error_2 = false;      
265A:  BCLR.B  8BC.1
....................    } 
.................... //   new_la = conversion2(f_lat); 
.................... //   new_ln = conversion2(f_lon); 
....................    new_la = f_lat; 
265C:  PUSH    A1E
265E:  POP     A3A
2660:  PUSH    A20
2662:  POP     A3C
....................    new_ln = f_lon; 
2664:  PUSH    A22
2666:  POP     A3E
2668:  PUSH    A24
266A:  POP     A40
.................... //   fprintf(BUG,"GC-%lu,%lu,%2.5f,%2.5f\n\r",f_time,i_date,new_la,new_ln);     
.................... //---------------- TIME  ------------------------------------------------------             
....................   new_sec = f_time % 100;             
266C:  BSET.B  43.0
266E:  MOV     9F8,W0
2670:  MOV     9FA,W1
2672:  MOV     #64,W2
2674:  MOV     #0,W3
2676:  CALL    188E
267A:  MOV     W0,9E8
....................        v1 = f_time / 10000;             
267C:  BCLR.B  43.0
267E:  MOV     9F8,W0
2680:  MOV     9FA,W1
2682:  MOV     #2710,W2
2684:  MOV     #0,W3
2686:  CALL    188E
268A:  MOV     W0,9F0
....................   new_min = (f_time % 10000) / 100; 
268C:  BSET.B  43.0
268E:  MOV     9F8,W0
2690:  MOV     9FA,W1
2692:  MOV     #2710,W2
2694:  MOV     #0,W3
2696:  CALL    188E
269A:  MOV     W0,W5
269C:  MOV     W1,W6
269E:  BCLR.B  43.0
26A0:  MOV     W5,W0
26A2:  MOV     W6,W1
26A4:  MOV     #64,W2
26A6:  MOV     #0,W3
26A8:  CALL    188E
26AC:  MOV     W0,9E6
....................        v4 = (new_min * 60) + new_sec; 
26AE:  MOV     9E6,W4
26B0:  MOV     #3C,W3
26B2:  MUL.SS  W4,W3,W0
26B4:  MOV     W0,W5
26B6:  MOV     W5,W0
26B8:  ADD     9E8,W0
26BA:  CALL    190C
26BE:  MOV     W0,A16
26C0:  MOV     W1,A18
....................   new_hrs = v1 + (  v4 / 3600 ); 
26C2:  MOV     A16,W0
26C4:  MOV     A18,W1
26C6:  MOV     #0,W2
26C8:  MOV     #4561,W3
26CA:  CALL    1956
26CE:  MOV     W0,W5
26D0:  MOV     W1,W6
26D2:  MOV     9F0,W0
26D4:  CALL    190C
26D8:  BCLR.B  43.0
26DA:  MOV     W5,W2
26DC:  MOV     W6,W3
26DE:  CALL    1A20
26E2:  MOV     W0,A26
26E4:  MOV     W1,A28
....................   fprintf(BUG,"%02u:%02u:%02u\n\r",v1,new_min,new_sec);       
26E6:  MOV     9F0,W0
26E8:  MOV     #8002,W4
26EA:  CALL    50C
26EE:  BTSC.B  223.1
26F0:  BRA     26EE
26F2:  MOV     #3A,W4
26F4:  MOV     W4,224
26F6:  MOV     9E6,W0
26F8:  MOV     #8002,W4
26FA:  CALL    50C
26FE:  BTSC.B  223.1
2700:  BRA     26FE
2702:  MOV     #3A,W4
2704:  MOV     W4,224
2706:  MOV     9E8,W0
2708:  MOV     #8002,W4
270A:  CALL    50C
270E:  BTSC.B  223.1
2710:  BRA     270E
2712:  MOV     #A,W4
2714:  MOV     W4,224
2716:  BTSC.B  223.1
2718:  BRA     2716
271A:  MOV     #D,W4
271C:  MOV     W4,224
.................... //  fprintf(BUG,"GT-%f\n\r",v4);  
.................... //-----------------DATE -------------------------------------------------------             
....................   date = i_date % 100;             
271E:  BSET.B  43.0
2720:  MOV     9FC,W0
2722:  MOV     9FE,W1
2724:  MOV     #64,W2
2726:  MOV     #0,W3
2728:  CALL    188E
272C:  MOV     W0,9EA
....................   year = i_date / 10000;             
272E:  BCLR.B  43.0
2730:  MOV     9FC,W0
2732:  MOV     9FE,W1
2734:  MOV     #2710,W2
2736:  MOV     #0,W3
2738:  CALL    188E
273C:  MOV     W0,9EE
....................   month = (i_date % 10000) / 100;        
273E:  BSET.B  43.0
2740:  MOV     9FC,W0
2742:  MOV     9FE,W1
2744:  MOV     #2710,W2
2746:  MOV     #0,W3
2748:  CALL    188E
274C:  MOV     W0,W5
274E:  MOV     W1,W6
2750:  BCLR.B  43.0
2752:  MOV     W5,W0
2754:  MOV     W6,W1
2756:  MOV     #64,W2
2758:  MOV     #0,W3
275A:  CALL    188E
275E:  MOV     W0,9EC
....................   fprintf(BUG,"%04lu/%02u/%02u\n\r",year,month,date);  
2760:  MOV     9EE,W0
2762:  MOV     #8004,W4
2764:  CALL    50C
2768:  BTSC.B  223.1
276A:  BRA     2768
276C:  MOV     #2F,W4
276E:  MOV     W4,224
2770:  MOV     9EC,W0
2772:  MOV     #8002,W4
2774:  CALL    50C
2778:  BTSC.B  223.1
277A:  BRA     2778
277C:  MOV     #2F,W4
277E:  MOV     W4,224
2780:  MOV     9EA,W0
2782:  MOV     #8002,W4
2784:  CALL    50C
2788:  BTSC.B  223.1
278A:  BRA     2788
278C:  MOV     #A,W4
278E:  MOV     W4,224
2790:  BTSC.B  223.1
2792:  BRA     2790
2794:  MOV     #D,W4
2796:  MOV     W4,224
.................... //----------------INIT DATE/TME------------------------------------------------             
....................   if(old_hrs == null) 
2798:  MOV     A2A,W0
279A:  MOV     A2C,W1
279C:  MOV     #0,W2
279E:  MOV     #0,W3
27A0:  CALL    1BCA
27A4:  BRA     NZ,27AE
....................   old_hrs = new_hrs; 
27A6:  PUSH    A26
27A8:  POP     A2A
27AA:  PUSH    A28
27AC:  POP     A2C
....................   if(old_la == null && old_ln == null){ 
27AE:  MOV     A32,W0
27B0:  MOV     A34,W1
27B2:  MOV     #0,W2
27B4:  MOV     #0,W3
27B6:  CALL    1BCA
27BA:  BRA     NZ,27DA
27BC:  MOV     A36,W0
27BE:  MOV     A38,W1
27C0:  MOV     #0,W2
27C2:  MOV     #0,W3
27C4:  CALL    1BCA
27C8:  BRA     NZ,27DA
....................     old_la = new_la; 
27CA:  PUSH    A3A
27CC:  POP     A32
27CE:  PUSH    A3C
27D0:  POP     A34
....................     old_ln = new_ln; 
27D2:  PUSH    A3E
27D4:  POP     A36
27D6:  PUSH    A40
27D8:  POP     A38
....................     }         
.................... //------------------------------------------------------------------------------      
....................     if(abs(old_la - new_la) >= 0.0001 || abs(old_ln-new_ln) >= 0.0001){ 
27DA:  BSET.B  43.0
27DC:  MOV     A32,W0
27DE:  MOV     A34,W1
27E0:  MOV     A3A,W2
27E2:  MOV     A3C,W3
27E4:  CALL    1A20
27E8:  MOV     W0,W5
27EA:  MOV     W1,W6
27EC:  MOV     W5,W0
27EE:  MOV     W6,W1
27F0:  BCLR    W1.F
27F2:  MOV     W0,W5
27F4:  MOV     W1,W6
27F6:  MOV     #B717,W0
27F8:  MOV     #38D1,W1
27FA:  MOV     W5,W2
27FC:  MOV     W6,W3
27FE:  CALL    1BCA
2802:  BRA     C,2832
2804:  BRA     Z,2832
2806:  BSET.B  43.0
2808:  MOV     A36,W0
280A:  MOV     A38,W1
280C:  MOV     A3E,W2
280E:  MOV     A40,W3
2810:  CALL    1A20
2814:  MOV     W0,W5
2816:  MOV     W1,W6
2818:  MOV     W5,W0
281A:  MOV     W6,W1
281C:  BCLR    W1.F
281E:  MOV     W0,W5
2820:  MOV     W1,W6
2822:  MOV     #B717,W0
2824:  MOV     #38D1,W1
2826:  MOV     W5,W2
2828:  MOV     W6,W3
282A:  CALL    1BCA
282E:  BRA     C,2832
2830:  BRA     NZ,28C2
....................     post_var = 1;  
2832:  MOV.B   #1,W0L
2834:  MOV.B   W0L,8BE
....................     dir = 1; 
2836:  MOV.B   #1,W0L
2838:  MOV.B   W0L,9DA
....................     distt = distance(old_la,old_ln,new_la,new_ln,'K');   
283A:  MOV.B   #4B,W0L
283C:  MOV.B   W0L,B6C
283E:  PUSH    A32
2840:  POP     B5C
2842:  PUSH    A34
2844:  POP     B5E
2846:  PUSH    A36
2848:  POP     B60
284A:  PUSH    A38
284C:  POP     B62
284E:  PUSH    A3A
2850:  POP     B64
2852:  PUSH    A3C
2854:  POP     B66
2856:  PUSH    A3E
2858:  POP     B68
285A:  PUSH    A40
285C:  POP     B6A
285E:  CALL    22D0
2862:  MOV     W0,A42
2864:  MOV     W1,A44
....................     if(old_hrs > new_hrs){                
2866:  MOV     A26,W0
2868:  MOV     A28,W1
286A:  MOV     A2A,W2
286C:  MOV     A2C,W3
286E:  CALL    1BCA
2872:  BRA     NC,28A2
....................        speed = distt / (24 - (old_hrs - new_hrs));     
2874:  BSET.B  43.0
2876:  MOV     A2A,W0
2878:  MOV     A2C,W1
287A:  MOV     A26,W2
287C:  MOV     A28,W3
287E:  CALL    1A20
2882:  BSET.B  43.0
2884:  MOV     W0,W2
2886:  MOV     W1,W3
2888:  MOV     #0,W0
288A:  MOV     #41C0,W1
288C:  CALL    1A20
2890:  MOV     W0,W2
2892:  MOV     W1,W3
2894:  MOV     A42,W0
2896:  MOV     A44,W1
2898:  CALL    1956
289C:  MOV     W0,A46
289E:  MOV     W1,A48
....................           }else { 
28A0:  BRA     28C0
....................            speed = distt / (new_hrs - old_hrs); 
28A2:  BSET.B  43.0
28A4:  MOV     A26,W0
28A6:  MOV     A28,W1
28A8:  MOV     A2A,W2
28AA:  MOV     A2C,W3
28AC:  CALL    1A20
28B0:  MOV     W0,W2
28B2:  MOV     W1,W3
28B4:  MOV     A42,W0
28B6:  MOV     A44,W1
28B8:  CALL    1956
28BC:  MOV     W0,A46
28BE:  MOV     W1,A48
....................           }     
.................... //    fprintf(BUG,"Di-%0.5f,%0.5f\n\r",abs(old_la-new_la),old_ln-new_ln); 
....................     }else if(old_hrs != new_hrs && year >= 2016){ 
28C0:  BRA     28E2
28C2:  MOV     A2A,W0
28C4:  MOV     A2C,W1
28C6:  MOV     A26,W2
28C8:  MOV     A28,W3
28CA:  CALL    1BCA
28CE:  BRA     Z,28E2
28D0:  MOV     9EE,W4
28D2:  MOV     #7E0,W3
28D4:  CP      W3,W4
28D6:  BRA     GT,28E2
....................     post_var = 1;  
28D8:  MOV.B   #1,W0L
28DA:  MOV.B   W0L,8BE
....................     dir = 0; 
28DC:  CLR.B   9DA
....................     speed = 0; 
28DE:  CLR     A46
28E0:  CLR     A48
....................     } 
28E2:  MOV     [--W15],W6
28E4:  MOV     [--W15],W5
28E6:  RETURN  
....................  
....................  /*            
....................    p_min = min + 30; 
....................    if(p_min>59){ 
....................       p_min -= 60 ; 
....................       p_hrs+=1; 
....................       } 
....................       p_hrs += hrss; 
....................       if(p_hrs>23){ 
....................       p_hrs -=24; 
....................       } 
....................       if(p_hrs > 12){am_pm="PM"; 
....................          p_hrs -= 12; 
....................       }else am_pm="AM"; 
....................       if(p_hrs == 0) 
....................       p_hrs = 12; 
....................       */ 
.................... } 
....................  
.................... float distance(float lat1, float lon1, float lat2, float lon2, char unit) { 
*
22D0:  MOV     W5,[W15++]
22D2:  MOV     #C,W5
22D4:  REPEAT  #4
22D6:  MOV     [W5++],[W15++]
22D8:  MOV     #18E3,W4
22DA:  MOV     W4,B82
....................  
....................     float dlat,dlon,a,c,d; 
....................     int16 R = 6371; 
....................  
....................    dlat = (lat2-lat1) * 0.0174532925;  
22DC:  BSET.B  43.0
22DE:  MOV     B64,W0
22E0:  MOV     B66,W1
22E2:  MOV     B5C,W2
22E4:  MOV     B5E,W3
22E6:  CALL    1A20
22EA:  MOV     W0,W5
22EC:  MOV     W1,W6
22EE:  MOV     W5,W0
22F0:  MOV     W6,W1
22F2:  MOV     #FA35,W2
22F4:  MOV     #3C8E,W3
22F6:  CALL    1C32
22FA:  MOV     W0,B6E
22FC:  MOV     W1,B70
....................    dlon = (lon2-lon1) * 0.0174532925; 
22FE:  BSET.B  43.0
2300:  MOV     B68,W0
2302:  MOV     B6A,W1
2304:  MOV     B60,W2
2306:  MOV     B62,W3
2308:  CALL    1A20
230C:  MOV     W0,W5
230E:  MOV     W1,W6
2310:  MOV     W5,W0
2312:  MOV     W6,W1
2314:  MOV     #FA35,W2
2316:  MOV     #3C8E,W3
2318:  CALL    1C32
231C:  MOV     W0,B72
231E:  MOV     W1,B74
....................  
....................     a = sin(dlat/2) * sin(dlat/2) + 
....................             cos((lat1 * 0.0174532925)) * cos((lat2 * 0.0174532925)) * 
....................             sin(dlon/2) * sin(dlon/2); 
2320:  MOV     B6E,W0
2322:  MOV     B70,W1
2324:  MOV     #0,W2
2326:  MOV     #4000,W3
2328:  CALL    1956
232C:  MOV     W0,W5
232E:  MOV     W1,W6
2330:  MOV     W5,B90
2332:  MOV     W6,B92
2334:  CALL    1ED0
2338:  MOV     W0,W5
233A:  MOV     W1,W6
233C:  MOV     B6E,W0
233E:  MOV     B70,W1
2340:  MOV     #0,W2
2342:  MOV     #4000,W3
2344:  CALL    1956
2348:  MOV     W0,W7
234A:  MOV     W1,W8
234C:  MOV     W7,B90
234E:  MOV     W8,B92
2350:  CALL    1ED0
2354:  MOV     W0,W2
2356:  MOV     W1,W3
2358:  MOV     W5,W0
235A:  MOV     W6,W1
235C:  CALL    1C32
2360:  MOV     W0,W5
2362:  MOV     W1,W6
2364:  MOV     B5C,W0
2366:  MOV     B5E,W1
2368:  MOV     #FA35,W2
236A:  MOV     #3C8E,W3
236C:  CALL    1C32
2370:  MOV     W0,W7
2372:  MOV     W1,W8
2374:  MOV     W7,B98
2376:  MOV     W8,B9A
2378:  CALL    1D5C
237C:  MOV     W0,W7
237E:  MOV     W1,W8
2380:  MOV     B64,W0
2382:  MOV     B66,W1
2384:  MOV     #FA35,W2
2386:  MOV     #3C8E,W3
2388:  CALL    1C32
238C:  MOV     W0,W9
238E:  MOV     W1,W10
2390:  MOV     W9,B98
2392:  MOV     W10,B9A
2394:  CALL    1D5C
2398:  MOV     W0,W2
239A:  MOV     W1,W3
239C:  MOV     W7,W0
239E:  MOV     W8,W1
23A0:  CALL    1C32
23A4:  MOV     W0,W7
23A6:  MOV     W1,W8
23A8:  MOV     B72,W0
23AA:  MOV     B74,W1
23AC:  MOV     #0,W2
23AE:  MOV     #4000,W3
23B0:  CALL    1956
23B4:  MOV     W0,W9
23B6:  MOV     W1,W10
23B8:  MOV     W9,B90
23BA:  MOV     W10,B92
23BC:  CALL    1ED0
23C0:  MOV     W0,W2
23C2:  MOV     W1,W3
23C4:  MOV     W7,W0
23C6:  MOV     W8,W1
23C8:  CALL    1C32
23CC:  MOV     W0,W7
23CE:  MOV     W1,W8
23D0:  MOV     B72,W0
23D2:  MOV     B74,W1
23D4:  MOV     #0,W2
23D6:  MOV     #4000,W3
23D8:  CALL    1956
23DC:  MOV     W0,W9
23DE:  MOV     W1,W10
23E0:  MOV     W9,B90
23E2:  MOV     W10,B92
23E4:  CALL    1ED0
23E8:  MOV     W0,W2
23EA:  MOV     W1,W3
23EC:  MOV     W7,W0
23EE:  MOV     W8,W1
23F0:  CALL    1C32
23F4:  BCLR.B  43.0
23F6:  MOV     W0,W2
23F8:  MOV     W1,W3
23FA:  MOV     W5,W0
23FC:  MOV     W6,W1
23FE:  CALL    1A20
2402:  MOV     W0,B76
2404:  MOV     W1,B78
....................              
....................     c = 2 * atan2(sqrt(a),sqrt(1-a)); 
2406:  PUSH    B76
2408:  POP     B8C
240A:  PUSH    B78
240C:  POP     B8E
240E:  CALL    1EF6
2412:  MOV     W0,W5
2414:  MOV     W1,W6
2416:  BSET.B  43.0
2418:  MOV     #0,W0
241A:  MOV     #3F80,W1
241C:  MOV     B76,W2
241E:  MOV     B78,W3
2420:  CALL    1A20
2424:  MOV     W0,W7
2426:  MOV     W1,W8
2428:  MOV     W7,B8C
242A:  MOV     W8,B8E
242C:  CALL    1EF6
2430:  MOV     W0,W7
2432:  MOV     W1,W8
2434:  MOV     W5,B8C
2436:  MOV     W6,B8E
2438:  MOV     W7,B90
243A:  MOV     W8,B92
243C:  CALL    218E
2440:  MOV     W0,W2
2442:  MOV     W1,W3
2444:  MOV     #0,W0
2446:  MOV     #4000,W1
2448:  CALL    1C32
244C:  MOV     W0,B7A
244E:  MOV     W1,B7C
....................     d = R * c;     
2450:  MOV     B82,W0
2452:  CALL    190C
2456:  MOV     B7A,W2
2458:  MOV     B7C,W3
245A:  CALL    1C32
245E:  MOV     W0,B7E
2460:  MOV     W1,B80
....................     d = d - 0.00144974;  
2462:  BSET.B  43.0
2464:  MOV     B7E,W0
2466:  MOV     B80,W1
2468:  MOV     #534,W2
246A:  MOV     #3ABE,W3
246C:  CALL    1A20
2470:  MOV     W0,B7E
2472:  MOV     W1,B80
....................     return d; 
2474:  MOV     B7E,W0
2476:  MOV     B80,W1
2478:  MOV     #14,W5
247A:  REPEAT  #4
247C:  MOV     [--W15],[W5--]
247E:  MOV     [--W15],W5
2480:  RETURN  
.................... } 
....................  
.................... float conversion2(float yyy) 
.................... { 
....................    v4 = modf(yyy,&v5); 
....................    v1 = v5; 
....................    yy = v1 /100; 
....................    v5 = v1 % 100; 
.................... //   v4 = v2; 
.................... //   v2 = v4 / 10000; 
....................    v4 = (v5 + v4) / 60;        
....................    v6 = yy; 
.................... //   v6 = v6 + v5;   
....................    return v6 + v4;   
.................... } 
....................  
.................... /* 
.................... void conversion(int dat,int add) 
.................... { 
....................    int i,j,k; 
....................    i=dat/100; 
....................    j=dat%100; 
....................    k=j%10; 
....................    j=j/10; 
....................    i=i|0x30; 
....................    j=j|0x30; 
....................    k=k|0x30; 
....................    lcd_com(add); 
....................   // lcd_data(i); 
....................    lcd_data(j); 
....................    lcd_data(k); 
.................... }*/ 
....................  
.................... #INT_RDA 
.................... void rda_isp() 
*
3332:  PUSH    42
3334:  PUSH    36
3336:  PUSH    32
3338:  MOV     W0,[W15++]
333A:  MOV     #2,W0
333C:  REPEAT  #C
333E:  MOV     [W0++],[W15++]
.................... { 
....................    unsigned char vv3;   
....................     
....................  //  if(string3[j] != 0x0d)string3[j] = getch(GPS);    
....................    if(string3[j] == 0x0d){ 
3340:  MOV.B   8BD,W0L
3342:  SE      W0,W0
3344:  MOV     #948,W4
3346:  ADD     W0,W4,W0
3348:  MOV.B   [W0],W4L
334A:  CP.B    W4L,#D
334C:  BRA     NZ,3366
....................       if(string3[0] != 'C') 
334E:  MOV     948,W4
3350:  XOR.B   #43,W4L
3352:  BRA     Z,3362
....................       { 
....................       string3[j]=0; 
3354:  MOV.B   8BD,W0L
3356:  SE      W0,W0
3358:  MOV     #948,W4
335A:  ADD     W0,W4,W5
335C:  CLR.B   [W5]
....................       j=0; 
335E:  CLR.B   8BD
....................       } 
3360:  BRA     3364
....................       else{ 
.................... //      vv3 = getch(GPS); 
....................       timeout_error_2 = true; 
3362:  BSET.B  8BC.1
....................       } 
....................    } 
3364:  BRA     337C
....................    else 
....................    if(string3[0] == 'C' && string3[j] != 0x0d){ 
3366:  MOV     948,W4
3368:  XOR.B   #43,W4L
336A:  BRA     NZ,337C
336C:  MOV.B   8BD,W0L
336E:  SE      W0,W0
3370:  MOV     #948,W4
3372:  ADD     W0,W4,W0
3374:  MOV.B   [W0],W4L
3376:  CP.B    W4L,#D
3378:  BRA     Z,337C
....................    j++; 
337A:  INC.B   08BD
....................    } 
.................... } 
....................  
337C:  BCLR.B  85.3
337E:  MOV     #1A,W0
3380:  REPEAT  #C
3382:  MOV     [--W15],[W0--]
3384:  MOV     [--W15],W0
3386:  POP     32
3388:  POP     36
338A:  POP     42
338C:  RETFIE  
.................... #INT_ADDRERR  
.................... void default_isr() { 
338E:  PUSH    42
3390:  PUSH    36
3392:  PUSH    32
3394:  MOV     W0,[W15++]
3396:  MOV     #2,W0
3398:  REPEAT  #C
339A:  MOV     [W0++],[W15++]
....................  
.................... //   printf("Unexplained interrupt\r\n"); 
.................... } 
....................  
339C:  BCLR.B  80.3
339E:  MOV     #1A,W0
33A0:  REPEAT  #C
33A2:  MOV     [--W15],[W0--]
33A4:  MOV     [--W15],W0
33A6:  POP     32
33A8:  POP     36
33AA:  POP     42
33AC:  RETFIE  
.................... #INT_CNI 
.................... void cni_isr() { 
33AE:  PUSH    42
33B0:  PUSH    36
33B2:  PUSH    32
33B4:  MOV     W0,[W15++]
33B6:  MOV     #2,W0
33B8:  REPEAT  #C
33BA:  MOV     [W0++],[W15++]
....................  
....................    if((!input(pin_A1)) && (last_a)){ 
33BC:  BSET.B  2C0.1
33BE:  BTSC.B  2C2.1
33C0:  BRA     33CE
33C2:  BTSS.B  8BC.2
33C4:  BRA     33CE
....................    p_status=1;  
33C6:  MOV.B   #1,W0L
33C8:  MOV.B   W0L,92B
....................    last_a = 0; 
33CA:  BCLR.B  8BC.2
....................    disable_interrupts(INT_CNI); 
33CC:  BCLR.B  96.3
....................    }   
.................... //   clear_interrupt(INT_CNI); 
.................... //   clear_interrupt(INTR_CN_PIN | PIN_A1); 
33CE:  BCLR.B  86.3
33D0:  MOV     #1A,W0
33D2:  REPEAT  #C
33D4:  MOV     [--W15],[W0--]
33D6:  MOV     [--W15],W0
33D8:  POP     32
33DA:  POP     36
33DC:  POP     42
33DE:  RETFIE  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1L: 1F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT PROTECT NOJTAG
          H: 0000  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: 0000  
