CCS PCD C Compiler, Version 5.074d, 1               07-Aug-17 15:44
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   F:\products\gps tracker\traces\Traces-v1\tracking_11_808.lst

               ROM used:   14726 bytes (33%)
                           Largest free fragment is 29302
               RAM used:   865 (11%) at main() level
                           1303 (16%) worst case
               Stack used: 70 locations (20 in main + 50 for interrupts)
               Stack size: 160

*
0000:  GOTO    34F6
*
0008:  DATA    BC,33,00
*
002A:  DATA    60,33,00
*
003A:  DATA    DC,33,00
....................  
.................... #include <24fj64ga002.h> 
.................... //////////// Standard Header file for the PIC24FJ64GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ64GA002 
*
0200:  CLR     32
0202:  MOV     #20C,W3
0204:  ADD     W3,W0,W0
0206:  TBLRDL.B[W0],W0L
0208:  CLR.B   1
020A:  RETURN  
020C:  DATA    41,54,00
020E:  DATA    2B,49,00
0210:  DATA    50,52,00
0212:  DATA    3D,35,00
0214:  DATA    37,36,00
0216:  DATA    30,30,00
0218:  DATA    25,63,00
021A:  DATA    00,00,00
021C:  CLR     32
021E:  MOV     #228,W3
0220:  ADD     W3,W0,W0
0222:  TBLRDL.B[W0],W0L
0224:  CLR.B   1
0226:  RETURN  
0228:  DATA    41,54,00
022A:  DATA    45,30,00
022C:  DATA    25,63,00
022E:  DATA    00,00,00
0230:  CLR     32
0232:  MOV     #23C,W3
0234:  ADD     W3,W0,W0
0236:  TBLRDL.B[W0],W0L
0238:  CLR.B   1
023A:  RETURN  
023C:  DATA    41,54,00
023E:  DATA    2B,43,00
0240:  DATA    47,52,00
0242:  DATA    45,47,00
0244:  DATA    3F,25,00
0246:  DATA    63,00,00
0248:  CLR     32
024A:  MOV     #254,W3
024C:  ADD     W3,W0,W0
024E:  TBLRDL.B[W0],W0L
0250:  CLR.B   1
0252:  RETURN  
0254:  DATA    41,54,00
0256:  DATA    2B,47,00
0258:  DATA    50,53,00
025A:  DATA    3D,31,00
025C:  DATA    0A,0D,00
025E:  DATA    00,00,00
0260:  CLR     32
0262:  MOV     #26C,W3
0264:  ADD     W3,W0,W0
0266:  TBLRDL.B[W0],W0L
0268:  CLR.B   1
026A:  RETURN  
026C:  DATA    41,54,00
026E:  DATA    2B,43,00
0270:  DATA    47,4E,00
0272:  DATA    53,50,00
0274:  DATA    57,52,00
0276:  DATA    3D,31,00
0278:  DATA    25,63,00
027A:  DATA    00,00,00
027C:  CLR     32
027E:  MOV     #288,W3
0280:  ADD     W3,W0,W0
0282:  TBLRDL.B[W0],W0L
0284:  CLR.B   1
0286:  RETURN  
0288:  DATA    41,54,00
028A:  DATA    2B,45,00
028C:  DATA    43,48,00
028E:  DATA    41,52,00
0290:  DATA    47,45,00
0292:  DATA    3D,31,00
0294:  DATA    0A,0D,00
0296:  DATA    00,00,00
0298:  CLR     32
029A:  MOV     #2A4,W3
029C:  ADD     W3,W0,W0
029E:  TBLRDL.B[W0],W0L
02A0:  CLR.B   1
02A2:  RETURN  
02A4:  DATA    41,54,00
02A6:  DATA    2B,45,00
02A8:  DATA    43,48,00
02AA:  DATA    41,52,00
02AC:  DATA    47,45,00
02AE:  DATA    3D,31,00
02B0:  DATA    25,63,00
02B2:  DATA    00,00,00
02B4:  CLR     32
02B6:  MOV     #2C0,W3
02B8:  ADD     W3,W0,W0
02BA:  TBLRDL.B[W0],W0L
02BC:  CLR.B   1
02BE:  RETURN  
02C0:  DATA    41,54,00
02C2:  DATA    2B,52,00
02C4:  DATA    47,50,00
02C6:  DATA    53,3D,00
02C8:  DATA    31,0A,00
02CA:  DATA    0D,00,00
02CC:  CLR     32
02CE:  MOV     #2D8,W3
02D0:  ADD     W3,W0,W0
02D2:  TBLRDL.B[W0],W0L
02D4:  CLR.B   1
02D6:  RETURN  
02D8:  DATA    41,54,00
02DA:  DATA    2B,43,00
02DC:  DATA    47,4E,00
02DE:  DATA    53,52,00
02E0:  DATA    53,54,00
02E2:  DATA    3D,30,00
02E4:  DATA    25,63,00
02E6:  DATA    00,00,00
02E8:  CLR     32
02EA:  MOV     #2F4,W3
02EC:  ADD     W3,W0,W0
02EE:  TBLRDL.B[W0],W0L
02F0:  CLR.B   1
02F2:  RETURN  
02F4:  DATA    43,41,00
02F6:  DATA    53,45,00
02F8:  DATA    2D,25,00
02FA:  DATA    75,0A,00
02FC:  DATA    0D,00,00
02FE:  CLR     32
0300:  MOV     #22,W3
0302:  SUB     W0,W3,W3
0304:  BRA     C,310
0306:  MOV     #31A,W3
0308:  ADD     W3,W0,W0
030A:  TBLRDL.B[W0],W0L
030C:  CLR.B   1
030E:  RETURN  
0310:  MOV     #31A,W0
0312:  ADD     W3,W3,W3
0314:  ADD     W3,W0,W3
0316:  TBLRDH  [W3],W0
0318:  RETURN  
031A:  DATA    41,54,73
031C:  DATA    2B,43,2E
031E:  DATA    49,50,63
0320:  DATA    53,54,6F
0322:  DATA    41,52,6D
0324:  DATA    54,3D,25
0326:  DATA    25,63,63
0328:  DATA    54,43,2C
032A:  DATA    50,25,25
032C:  DATA    63,2C,63
032E:  DATA    25,63,38
0330:  DATA    77,77,30
0332:  DATA    77,2E,25
0334:  DATA    67,70,63
0336:  DATA    73,74,25
0338:  DATA    72,61,63
033A:  DATA    63,65,00
033C:  CLR     32
033E:  MOV     #348,W3
0340:  ADD     W3,W0,W0
0342:  TBLRDL.B[W0],W0L
0344:  CLR.B   1
0346:  RETURN  
0348:  DATA    41,54,00
034A:  DATA    2B,43,00
034C:  DATA    49,50,00
034E:  DATA    53,45,00
0350:  DATA    4E,44,00
0352:  DATA    00,00,00
0354:  CLR     32
0356:  MOV     #24,W3
0358:  SUB     W0,W3,W3
035A:  BRA     C,366
035C:  MOV     #370,W3
035E:  ADD     W3,W0,W0
0360:  TBLRDL.B[W0],W0L
0362:  CLR.B   1
0364:  RETURN  
0366:  MOV     #370,W0
0368:  ADD     W3,W3,W3
036A:  ADD     W3,W0,W3
036C:  TBLRDH  [W3],W0
036E:  RETURN  
0370:  DATA    47,45,36
0372:  DATA    54,20,35
0374:  DATA    68,74,30
0376:  DATA    74,70,36
0378:  DATA    3A,2F,37
037A:  DATA    2F,77,30
037C:  DATA    77,77,32
037E:  DATA    2E,67,32
0380:  DATA    70,73,34
0382:  DATA    74,72,33
0384:  DATA    61,63,35
0386:  DATA    65,73,37
0388:  DATA    2E,63,30
038A:  DATA    6F,6D,38
038C:  DATA    2F,75,26
038E:  DATA    2F,75,00
0390:  DATA    3F,69,00
0392:  DATA    3D,38,00
0394:  CLR     32
0396:  MOV     #3A0,W3
0398:  ADD     W3,W0,W0
039A:  TBLRDL.B[W0],W0L
039C:  CLR.B   1
039E:  RETURN  
03A0:  DATA    41,54,00
03A2:  DATA    2B,43,00
03A4:  DATA    49,50,00
03A6:  DATA    43,4C,00
03A8:  DATA    4F,53,00
03AA:  DATA    45,00,00
03AC:  CLR     32
03AE:  MOV     #3B8,W3
03B0:  ADD     W3,W0,W0
03B2:  TBLRDL.B[W0],W0L
03B4:  CLR.B   1
03B6:  RETURN  
03B8:  DATA    2D,54,00
03BA:  DATA    41,53,00
03BC:  DATA    4B,31,00
03BE:  DATA    2D,0A,00
03C0:  DATA    0D,00,00
03C2:  CLR     32
03C4:  MOV     #3CE,W3
03C6:  ADD     W3,W0,W0
03C8:  TBLRDL.B[W0],W0L
03CA:  CLR.B   1
03CC:  RETURN  
03CE:  DATA    41,43,00
03D0:  DATA    4B,2D,00
03D2:  DATA    25,75,00
03D4:  DATA    0A,0D,00
03D6:  DATA    00,00,00
03D8:  CLR     32
03DA:  MOV     #3E4,W3
03DC:  ADD     W3,W0,W0
03DE:  TBLRDL.B[W0],W0L
03E0:  CLR.B   1
03E2:  RETURN  
03E4:  DATA    41,54,00
03E6:  DATA    2B,43,00
03E8:  DATA    47,4E,00
03EA:  DATA    53,49,00
03EC:  DATA    4E,46,00
03EE:  DATA    25,63,00
03F0:  DATA    00,00,00
03F2:  CLR     32
03F4:  MOV     #3FE,W3
03F6:  ADD     W3,W0,W0
03F8:  TBLRDL.B[W0],W0L
03FA:  CLR.B   1
03FC:  RETURN  
03FE:  DATA    54,4F,00
0400:  DATA    0D,0A,00
0402:  DATA    00,00,00
0404:  CLR     32
0406:  MOV     #410,W3
0408:  ADD     W3,W0,W0
040A:  TBLRDL.B[W0],W0L
040C:  CLR.B   1
040E:  RETURN  
0410:  DATA    53,74,00
0412:  DATA    61,67,00
0414:  DATA    65,20,00
0416:  DATA    31,0A,00
0418:  DATA    0D,00,00
041A:  CLR     32
041C:  MOV     #426,W3
041E:  ADD     W3,W0,W0
0420:  TBLRDL.B[W0],W0L
0422:  CLR.B   1
0424:  RETURN  
0426:  DATA    53,74,00
0428:  DATA    61,67,00
042A:  DATA    65,20,00
042C:  DATA    32,0A,00
042E:  DATA    0D,00,00
0430:  CLR     32
0432:  MOV     #43C,W3
0434:  ADD     W3,W0,W0
0436:  TBLRDL.B[W0],W0L
0438:  CLR.B   1
043A:  RETURN  
043C:  DATA    53,74,00
043E:  DATA    61,67,00
0440:  DATA    65,20,00
0442:  DATA    33,0A,00
0444:  DATA    0D,00,00
0446:  CLR     32
0448:  MOV     #452,W3
044A:  ADD     W3,W0,W0
044C:  TBLRDL.B[W0],W0L
044E:  CLR.B   1
0450:  RETURN  
0452:  DATA    42,4F,00
0454:  DATA    4F,54,00
0456:  DATA    20,31,00
0458:  DATA    0A,0D,00
045A:  DATA    00,00,00
045C:  CLR     32
045E:  MOV     #468,W3
0460:  ADD     W3,W0,W0
0462:  TBLRDL.B[W0],W0L
0464:  CLR.B   1
0466:  RETURN  
0468:  DATA    42,4F,00
046A:  DATA    4F,54,00
046C:  DATA    20,32,00
046E:  DATA    0A,0D,00
0470:  DATA    00,00,00
0472:  CLR     32
0474:  MOV     #47E,W3
0476:  ADD     W3,W0,W0
0478:  TBLRDL.B[W0],W0L
047A:  CLR.B   1
047C:  RETURN  
047E:  DATA    42,4F,00
0480:  DATA    4F,54,00
0482:  DATA    20,33,00
0484:  DATA    0A,0D,00
0486:  DATA    00,00,00
0488:  CLR     32
048A:  MOV     #494,W3
048C:  ADD     W3,W0,W0
048E:  TBLRDL.B[W0],W0L
0490:  CLR.B   1
0492:  RETURN  
0494:  DATA    42,4F,00
0496:  DATA    4F,54,00
0498:  DATA    20,34,00
049A:  DATA    0A,0D,00
049C:  DATA    00,00,00
049E:  CLR     32
04A0:  MOV     #4AA,W3
04A2:  ADD     W3,W0,W0
04A4:  TBLRDL.B[W0],W0L
04A6:  CLR.B   1
04A8:  RETURN  
04AA:  DATA    42,4F,00
04AC:  DATA    4F,54,00
04AE:  DATA    20,35,00
04B0:  DATA    0A,0D,00
04B2:  DATA    00,00,00
04B4:  CLR     32
04B6:  MOV     #4C0,W3
04B8:  ADD     W3,W0,W0
04BA:  TBLRDL.B[W0],W0L
04BC:  CLR.B   1
04BE:  RETURN  
04C0:  DATA    42,4F,00
04C2:  DATA    4F,54,00
04C4:  DATA    20,36,00
04C6:  DATA    0A,0D,00
04C8:  DATA    00,00,00
04CA:  CLR     32
04CC:  MOV     #4D6,W3
04CE:  ADD     W3,W0,W0
04D0:  TBLRDL.B[W0],W0L
04D2:  CLR.B   1
04D4:  RETURN  
04D6:  DATA    AE,0A,00
04D8:  DATA    C0,0A,00
04DA:  DATA    D2,0A,00
04DC:  DATA    E4,0A,00
04DE:  DATA    F6,0A,00
04E0:  DATA    08,0B,00
04E2:  CLR     32
04E4:  MOV     #4EE,W3
04E6:  ADD     W3,W0,W0
04E8:  TBLRDL.B[W0],W0L
04EA:  CLR.B   1
04EC:  RETURN  
04EE:  DATA    2C,00,00
*
0528:  MOV     W5,[W15++]
052A:  MOV     #C,W5
052C:  REPEAT  #3
052E:  MOV     [W5++],[W15++]
0530:  MOV     W0,W7
0532:  MOV     W4,W9
0534:  BCLR    W4.F
0536:  CP0     W4
0538:  BRA     NZ,546
053A:  BTSC    W9.F
053C:  BRA     542
053E:  MOV     #0,W5
0540:  BRA     564
0542:  MOV     #0,W5
0544:  BRA     564
0546:  SUB.B   W4L,#6,W5L
0548:  BRA     NC,562
054A:  MOV     #30,W0
054C:  BTSS    W9.F
054E:  MOV     #20,W0
0550:  MOV     W0,[W15++]
0552:  BTSC.B  223.1
0554:  BRA     552
0556:  MOV     W0,224
0558:  MOV     [--W15],W0
055A:  DEC     W5,W5
055C:  BRA     NN,550
055E:  MOV     #5,W5
0560:  BRA     564
0562:  MOV     W4,W5
0564:  MOV     #6,W4
0566:  BSET    W5.E
0568:  BTSC    W9.F
056A:  BSET    W5.F
056C:  MOV     #2710,W8
056E:  REPEAT  #11
0570:  DIV.U   W7,W8
0572:  CALL    5A6
0576:  MOV     W1,W7
0578:  MOV     #3E8,W8
057A:  REPEAT  #11
057C:  DIV.U   W7,W8
057E:  CALL    5A6
0582:  MOV     W1,W7
0584:  MOV     #64,W8
0586:  REPEAT  #11
0588:  DIV.U   W7,W8
058A:  CALL    5A6
058E:  MOV     W1,W7
0590:  MOV     #A,W8
0592:  REPEAT  #11
0594:  DIV.U   W7,W8
0596:  CALL    5A6
059A:  MOV     #30,W0
059C:  ADD.B   W1L,W0L,W0L
059E:  BTSC.B  223.1
05A0:  BRA     59E
05A2:  MOV     W0,224
05A4:  BRA     5D4
05A6:  MOV     #30,W6
05A8:  CP0     W0
05AA:  BRA     NZ,5C8
05AC:  BTSS    W5.E
05AE:  BRA     5CA
05B0:  DEC     W4,W4
05B2:  CP.B    W4L,W5L
05B4:  BRA     Z,5BA
05B6:  BTSC.B  42.0
05B8:  RETURN  
05BA:  CP0     W0
05BC:  BRA     NZ,5C8
05BE:  BTSS    W5.E
05C0:  BRA     5CA
05C2:  BTSS    W5.F
05C4:  MOV     #20,W6
05C6:  BRA     5CA
05C8:  BCLR    W5.E
05CA:  ADD.B   W6L,W0L,W0L
05CC:  BTSC.B  223.1
05CE:  BRA     5CC
05D0:  MOV     W0,224
05D2:  RETURN  
05D4:  MOV     #12,W5
05D6:  REPEAT  #3
05D8:  MOV     [--W15],[W5--]
05DA:  MOV     [--W15],W5
05DC:  RETURN  
*
0B8A:  MOV     W6,[W15++]
0B8C:  MOV     #E,W6
0B8E:  REPEAT  #6
0B90:  MOV     [W6++],[W15++]
0B92:  MOV     W2,W6
0B94:  MOV     W5,W7
0B96:  BCLR.B  42.0
0B98:  BCLR.B  42.1
0B9A:  RLC     W2,W2
0B9C:  SWAP    W2
0B9E:  AND     #FF,W2
0BA0:  CP0     W2
0BA2:  BRA     Z,C48
0BA4:  BCLR.B  42.0
0BA6:  BCLR.B  42.1
0BA8:  RLC     W5,W5
0BAA:  SWAP    W5
0BAC:  AND     #FF,W5
0BAE:  CP0     W5
0BB0:  BRA     Z,C48
0BB2:  ADD.B   W2L,W5L,W5L
0BB4:  BRA     C,BBE
0BB6:  SUB     #7F,W5
0BB8:  BRA     Z,C48
0BBA:  BRA     NC,C48
0BBC:  BRA     BC2
0BBE:  ADD.B   #81,W5L
0BC0:  BRA     C,C48
0BC2:  XOR     W6,W7,W2
0BC4:  BCLR.B  42.0
0BC6:  BCLR.B  42.1
0BC8:  AND     #FF,W6
0BCA:  BSET    W6.7
0BCC:  CLR     0
0BCE:  AND     #FF,W7
0BD0:  BSET    W7.7
0BD2:  MUL.UU  W3,W0,W8
0BD4:  MUL.UU  W3,W1,W10
0BD6:  ADDC    W9,W10,W10
0BD8:  ADDC    #0,W11
0BDA:  MUL.UU  W3,W6,W8
0BDC:  ADD     W8,W11,W11
0BDE:  MOV     W9,W12
0BE0:  MUL.UU  W4,W0,W8
0BE2:  ADD     W8,W10,W10
0BE4:  ADDC    W9,W11,W11
0BE6:  MUL.UU  W4,W1,W8
0BE8:  ADD     W8,W11,W11
0BEA:  ADDC    W9,W12,W12
0BEC:  MUL.UU  W4,W6,W8
0BEE:  ADD     W8,W12,W12
0BF0:  ADDC    #0,W9
0BF2:  MOV     W9,W13
0BF4:  MUL.UU  W7,W0,W8
0BF6:  ADD     W8,W11,W11
0BF8:  ADDC    W9,W12,W12
0BFA:  MUL.UU  W7,W1,W8
0BFC:  ADD     W8,W12,W12
0BFE:  ADDC    W9,W13,W13
0C00:  MUL.UU  W7,W6,W8
0C02:  ADD     W8,W13,W13
0C04:  MOV     W2,W8
0C06:  INC     W5,W2
0C08:  CLR     W0
0C0A:  CLR     W1
0C0C:  IOR      W13,  W12,W6
0C0E:  BRA     Z,C12
0C10:  BRA     C16
0C12:  IOR      W11,  W10,W6
0C14:  BRA     Z,C22
0C16:  BTSC    W13.F
0C18:  BRA     C22
0C1A:  RLC     W11,W11
0C1C:  RLC     W12,W12
0C1E:  RLC     W13,W13
0C20:  DEC     W2,W2
0C22:  BCLR    W13.F
0C24:  SWAP    W2
0C26:  BCLR.B  42.0
0C28:  BCLR.B  42.1
0C2A:  RRC     W2,W2
0C2C:  BCLR    W2.F
0C2E:  BTSC    W8.F
0C30:  BSET    W2.F
0C32:  MOV.B   W13L,W1L
0C34:  SWAP    W13
0C36:  SWAP    W1
0C38:  XOR.B   W13L,W2L,W2L
0C3A:  MOV.B   W12L,W0L
0C3C:  SWAP    W0
0C3E:  SWAP    W12
0C40:  MOV.B   W12L,W1L
0C42:  SWAP    W11
0C44:  MOV.B   W11L,W0L
0C46:  BRA     C4E
0C48:  MUL.UU  W0,#0,W0
0C4A:  MOV     #0,W2
0C4C:  BRA     C4E
0C4E:  MOV     #1A,W6
0C50:  REPEAT  #6
0C52:  MOV     [--W15],[W6--]
0C54:  MOV     [--W15],W6
0C56:  RETURN  
0C58:  MOV     W5,[W15++]
0C5A:  MOV     #C,W5
0C5C:  REPEAT  #3
0C5E:  MOV     [W5++],[W15++]
0C60:  MOV     W0,W4
0C62:  MOV     W1,W5
0C64:  MOV     W2,W6
0C66:  MOV     W3,W7
0C68:  CLR     W0
0C6A:  CLR     W1
0C6C:  CLR     W2
0C6E:  CLR     W3
0C70:  BCLR    W10.0
0C72:  BTSS    W7.F
0C74:  BRA     C86
0C76:  BSET    W10.0
0C78:  COM     W7,W7
0C7A:  COM     W6,W6
0C7C:  COM     W5,W5
0C7E:  NEG     W4,W4
0C80:  ADDC    W5,#0,W5
0C82:  ADDC    W6,#0,W6
0C84:  ADDC    W7,#0,W7
0C86:  IOR      W4,  W5,W9
0C88:  BRA     NZ,C8E
0C8A:  IOR      W6,  W7,W9
0C8C:  BRA     Z,CB8
0C8E:  MOV     #E6,W9
0C90:  BTSC    W2.7
0C92:  BRA     CA8
0C94:  BCLR.B  42.0
0C96:  RLC     W4,W4
0C98:  RLC     W5,W5
0C9A:  RLC     W6,W6
0C9C:  RLC     W7,W7
0C9E:  RLC     W0,W0
0CA0:  RLC     W1,W1
0CA2:  RLC     W2,W2
0CA4:  DEC     W9,W9
0CA6:  BRA     NZ,C90
0CA8:  SWAP    W9
0CAA:  BCLR.B  42.0
0CAC:  RRC     W9,W9
0CAE:  BCLR    W9.F
0CB0:  BCLR    W2.7
0CB2:  XOR     W9,W2,W2
0CB4:  BTSC    W10.0
0CB6:  BSET    W2.F
0CB8:  MOV     #12,W5
0CBA:  REPEAT  #3
0CBC:  MOV     [--W15],[W5--]
0CBE:  MOV     [--W15],W5
0CC0:  RETURN  
0CC2:  MOV     W6,[W15++]
0CC4:  MOV     #E,W6
0CC6:  REPEAT  #6
0CC8:  MOV     [W6++],[W15++]
0CCA:  XOR     W2,W5,W9
0CCC:  MOV     W2,W6
0CCE:  MOV     W5,W7
0CD0:  RLC     W6,W6
0CD2:  SWAP    W6
0CD4:  ZE      W6,W6
0CD6:  CP0     W6
0CD8:  BRA     Z,D88
0CDA:  RLC     W7,W7
0CDC:  SWAP    W7
0CDE:  ZE      W7,W7
0CE0:  CP0     W7
0CE2:  BRA     Z,D88
0CE4:  CLR     W10
0CE6:  SUB.B   W6L,W7L,W10L
0CE8:  BRA     NC,CF0
0CEA:  ADD.B   #7F,W10L
0CEC:  BRA     C,D88
0CEE:  BRA     CF6
0CF0:  SUB.B   #81,W10L
0CF2:  BRA     NC,D88
0CF4:  BRA     Z,D88
0CF6:  CLR     W6
0CF8:  CLR     W7
0CFA:  CLR     W8
0CFC:  AND     #FF,W2
0CFE:  BSET    W2.7
0D00:  AND     #FF,W5
0D02:  BSET    W5.7
0D04:  MOV     #29,W11
0D06:  SUB     W0,W3,W0
0D08:  SUBB    W1,W4,W1
0D0A:  SUBB    W2,W5,W2
0D0C:  BRA     N,D12
0D0E:  BRA     C,D1A
0D10:  BRA     NZ,D1C
0D12:  ADD     W0,W3,W0
0D14:  ADDC    W1,W4,W1
0D16:  ADDC    W2,W5,W2
0D18:  BRA     D1C
0D1A:  BSET    W6.0
0D1C:  DEC     W11,W11
0D1E:  BRA     Z,D32
0D20:  BCLR.B  42.0
0D22:  RLC     W0,W0
0D24:  RLC     W1,W1
0D26:  RLC     W2,W2
0D28:  BCLR.B  42.0
0D2A:  RLC     W6,W6
0D2C:  RLC     W7,W7
0D2E:  RLC     W8,W8
0D30:  BRA     D06
0D32:  BTSC    W8.8
0D34:  BRA     D38
0D36:  BRA     D6E
0D38:  BCLR.B  42.0
0D3A:  RRC     W8,W8
0D3C:  BCLR    W8.7
0D3E:  RRC     W7,W7
0D40:  RRC     W6,W6
0D42:  RRC     W11,W11
0D44:  BRA     D4A
0D46:  DEC     W10,W10
0D48:  BRA     Z,D88
0D4A:  BTSC    W11.F
0D4C:  BRA     D5C
0D4E:  RLC     W0,W0
0D50:  RLC     W1,W1
0D52:  RLC     W2,W2
0D54:  SUB     W0,W3,W3
0D56:  SUBB    W1,W4,W4
0D58:  SUBB    W2,W5,W5
0D5A:  BRA     NC,D72
0D5C:  INC     W6,W6
0D5E:  BRA     NZ,D72
0D60:  INC     W7,W7
0D62:  BRA     NZ,D72
0D64:  INC     W8,W8
0D66:  BRA     NZ,D72
0D68:  INC     W10,W10
0D6A:  BRA     Z,D88
0D6C:  BRA     D72
0D6E:  DEC     W10,W10
0D70:  BRA     Z,D88
0D72:  SWAP    W10
0D74:  BCLR.B  42.0
0D76:  RRC     W10,W2
0D78:  BSET    W2.F
0D7A:  BTSS    W9.F
0D7C:  BCLR    W2.F
0D7E:  BCLR    W8.7
0D80:  XOR.B   W8L,W2L,W2L
0D82:  MOV     W7,W1
0D84:  MOV     W6,W0
0D86:  BRA     D8E
0D88:  MUL.UU  W0,#0,W0
0D8A:  MOV     #0,W2
0D8C:  BRA     D8E
0D8E:  MOV     #1A,W6
0D90:  REPEAT  #6
0D92:  MOV     [--W15],[W6--]
0D94:  MOV     [--W15],W6
0D96:  RETURN  
0D98:  MOV     W6,[W15++]
0D9A:  MOV     #E,W6
0D9C:  REPEAT  #6
0D9E:  MOV     [W6++],[W15++]
0DA0:  CLR     W9
0DA2:  MOV     #8000,W8
0DA4:  BTSC.B  43.0
0DA6:  XOR     W8,W5,W5
0DA8:  CP0     W0
0DAA:  BRA     NZ,DB6
0DAC:  CP0     W1
0DAE:  BRA     NZ,DB6
0DB0:  MOV     #7FFF,W10
0DB2:  AND     W2,W10,W10
0DB4:  BTSS.B  42.1
0DB6:  MOV     W2,W10
0DB8:  XOR     W5,W10,W11
0DBA:  MOV     W2,W6
0DBC:  MOV     W5,W7
0DBE:  MOV     W5,W12
0DC0:  BCLR.B  42.1
0DC2:  BCLR.B  42.0
0DC4:  RLC     W6,W6
0DC6:  SWAP    W6
0DC8:  AND     #FF,W6
0DCA:  CP0     W6
0DCC:  BRA     Z,F3C
0DCE:  BCLR.B  42.1
0DD0:  BCLR.B  42.0
0DD2:  RLC     W7,W7
0DD4:  SWAP    W7
0DD6:  AND     #FF,W7
0DD8:  CP0     W7
0DDA:  BRA     Z,F48
0DDC:  BCLR.B  42.1
0DDE:  BCLR.B  42.0
0DE0:  CP      W7,W6
0DE2:  BRA     Z,F4A
0DE4:  BRA     N,F5A
0DE6:  BCLR    W9.0
0DE8:  BSET    W9.1
0DEA:  SUB     W7,W6,W8
0DEC:  MOV     W7,W6
0DEE:  AND     #FF,W2
0DF0:  BSET    W2.7
0DF2:  AND     #FF,W5
0DF4:  BSET    W5.7
0DF6:  MOV     #28,W7
0DF8:  CP      W7,W8
0DFA:  BRA     N,E22
0DFC:  BCLR.B  42.1
0DFE:  BCLR.B  42.0
0E00:  RRC     W2,W2
0E02:  RRC     W1,W1
0E04:  RRC     W0,W0
0E06:  DEC     W8,W8
0E08:  BRA     NZ,DFC
0E0A:  BRA     E30
0E0C:  MOV     #28,W7
0E0E:  CP      W7,W8
0E10:  BRA     N,E2A
0E12:  BCLR.B  42.1
0E14:  BCLR.B  42.0
0E16:  RRC     W5,W5
0E18:  RRC     W4,W4
0E1A:  RRC     W3,W3
0E1C:  DEC     W8,W8
0E1E:  BRA     NZ,E12
0E20:  BRA     E4E
0E22:  MOV     W3,W0
0E24:  MOV     W4,W1
0E26:  MOV     W5,W2
0E28:  XOR     W11,W12,W12
0E2A:  BTSC    W12.F
0E2C:  BTG     W11.F
0E2E:  BRA     F1A
0E30:  BTSS    W11.F
0E32:  BRA     E62
0E34:  BTSC    W9.4
0E36:  MOV     W12,W11
0E38:  COM     W0,W0
0E3A:  COM     W1,W1
0E3C:  COM.B   W2L,W2L
0E3E:  INC     W0,W0
0E40:  BRA     NZ,E48
0E42:  INC     W1,W1
0E44:  BRA     NZ,E48
0E46:  INC.B   W2L,W2L
0E48:  BTSC    W9.4
0E4A:  BRA     EAA
0E4C:  BRA     E62
0E4E:  BTSS    W11.F
0E50:  BRA     E62
0E52:  COM     W3,W3
0E54:  COM     W4,W4
0E56:  COM.B   W5L,W5L
0E58:  INC     W3,W3
0E5A:  BRA     NZ,E62
0E5C:  INC     W4,W4
0E5E:  BRA     NZ,E62
0E60:  INC.B   W5L,W5L
0E62:  AND     #FF,W5
0E64:  BCLR.B  42.1
0E66:  BCLR.B  42.0
0E68:  ADD     W0,W3,W0
0E6A:  ADDC    W1,W4,W1
0E6C:  ADDC.B  W2L,W5L,W2L
0E6E:  BTSC.B  42.0
0E70:  BSET    W9.3
0E72:  BTSC    W9.0
0E74:  BRA     E88
0E76:  BTSC    W9.1
0E78:  BRA     E7C
0E7A:  BRA     E92
0E7C:  BTSC    W11.F
0E7E:  BRA     EAA
0E80:  BTSC    W9.3
0E82:  BRA     EDC
0E84:  BSET    W9.6
0E86:  BRA     ECA
0E88:  BTSC    W11.F
0E8A:  BRA     EAA
0E8C:  BTSC    W9.3
0E8E:  BRA     EDC
0E90:  BRA     ECA
0E92:  BCLR    W9.2
0E94:  BTSC    W11.F
0E96:  BRA     EA0
0E98:  MOV     W10,W11
0E9A:  BTSC    W9.3
0E9C:  BRA     EDC
0E9E:  BRA     F1A
0EA0:  BSET    W9.4
0EA2:  XOR.B   #80,W2L
0EA4:  BTSC    W2.7
0EA6:  BRA     E34
0EA8:  MOV     W10,W11
0EAA:  AND     #FF,W2
0EAC:  IOR      W2,  W1,W7
0EAE:  BRA     NZ,EB4
0EB0:  CP0     W0
0EB2:  BRA     Z,ECA
0EB4:  BTSC    W2.7
0EB6:  BRA     ECA
0EB8:  BCLR.B  42.1
0EBA:  BCLR.B  42.0
0EBC:  RLC     W0,W0
0EBE:  RLC     W1,W1
0EC0:  RLC     W2,W2
0EC2:  DEC     W6,W6
0EC4:  BTSC.B  42.1
0EC6:  BRA     F36
0EC8:  BRA     EB4
0ECA:  BTSC    W9.0
0ECC:  MOV     W10,W11
0ECE:  BTSC    W9.1
0ED0:  MOV     W12,W11
0ED2:  BTSS    W9.5
0ED4:  BRA     F12
0ED6:  BTSC    W10.F
0ED8:  BSET    W0.8
0EDA:  BRA     F1A
0EDC:  BSET.B  42.0
0EDE:  RRC.B   W2L,W2L
0EE0:  RRC     W1,W1
0EE2:  RRC     W0,W0
0EE4:  BTSC.B  42.0
0EE6:  BSET    W9.5
0EE8:  INC     W6,W6
0EEA:  BRA     Z,F36
0EEC:  BTSS    W9.5
0EEE:  BRA     F06
0EF0:  INC     W0,W0
0EF2:  BRA     NZ,F06
0EF4:  INC     W1,W1
0EF6:  BRA     NZ,F06
0EF8:  INC.B   W2L,W2L
0EFA:  BRA     NZ,F06
0EFC:  RRC.B   W2L,W2L
0EFE:  RRC     W1,W1
0F00:  RRC     W0,W0
0F02:  INC     W6,W6
0F04:  BRA     Z,F36
0F06:  BTSC    W9.0
0F08:  MOV     W10,W11
0F0A:  BTSC    W9.1
0F0C:  MOV     W12,W11
0F0E:  BTSC.B  42.1
0F10:  BRA     F36
0F12:  BTSC    W9.6
0F14:  MOV     W10,W11
0F16:  BTSC    W9.7
0F18:  MOV     W12,W11
0F1A:  IOR      W0,  W1,W4
0F1C:  BRA     NZ,F22
0F1E:  IOR      W2,  W4,W4
0F20:  BRA     Z,F6A
0F22:  BCLR    W2.7
0F24:  SWAP    W6
0F26:  BCLR.B  42.1
0F28:  BCLR.B  42.0
0F2A:  RRC     W6,W6
0F2C:  XOR     W6,W2,W2
0F2E:  BSET    W2.F
0F30:  BTSS    W11.F
0F32:  BCLR    W2.F
0F34:  BRA     F6A
0F36:  MUL.UU  W0,#0,W0
0F38:  MOV     #0,W2
0F3A:  BRA     F6A
0F3C:  BTSC    W10.F
0F3E:  XOR     W8,W5,W5
0F40:  MOV     W5,W2
0F42:  MOV     W4,W1
0F44:  MOV     W3,W0
0F46:  BRA     F6A
0F48:  BRA     F6A
0F4A:  AND     #FF,W5
0F4C:  BSET    W5.7
0F4E:  AND     #FF,W2
0F50:  BSET    W2.7
0F52:  BTSC    W11.F
0F54:  BCLR    W5.7
0F56:  BSET    W9.2
0F58:  BRA     E4E
0F5A:  SUB     W6,W7,W8
0F5C:  AND     #FF,W2
0F5E:  BSET    W2.7
0F60:  AND     #FF,W5
0F62:  BSET    W5.7
0F64:  BCLR    W9.1
0F66:  BSET    W9.0
0F68:  BRA     E0C
0F6A:  MOV     #1A,W6
0F6C:  REPEAT  #6
0F6E:  MOV     [--W15],[W6--]
0F70:  MOV     [--W15],W6
0F72:  RETURN  
*
139C:  MOV     W6,[W15++]
139E:  MOV     W7,[W15++]
13A0:  MOV     W8,[W15++]
13A2:  MOV     W9,[W15++]
13A4:  MOV     #0,W9
13A6:  BTSC.B  43.0
13A8:  MOV     #1,W9
13AA:  MOV     W9,[W15++]
13AC:  CLR     W6
13AE:  CLR     W7
13B0:  CLR     W8
13B2:  CLR     W9
13B4:  CLR     W10
13B6:  CLR     W11
13B8:  XOR     W3,W4,W13
13BA:  BRA     NZ,13C0
13BC:  XOR     W13,W5,W13
13BE:  BRA     Z,1410
13C0:  CLR     W13
13C2:  BTSS    W2.F
13C4:  BRA     13D2
13C6:  BSET    W13.F
13C8:  COM     W2,W2
13CA:  COM     W1,W1
13CC:  NEG     W0,W0
13CE:  ADDC    W1,#0,W1
13D0:  ADDC    W2,#0,W2
13D2:  BTSS    W5.F
13D4:  BRA     13E2
13D6:  BTG     W13.F
13D8:  COM     W5,W5
13DA:  COM     W4,W4
13DC:  NEG     W3,W3
13DE:  ADDC    W4,#0,W4
13E0:  ADDC    W5,#0,W5
13E2:  MOV     #30,W12
13E4:  BCLR.B  42.0
13E6:  RLC     W0,W0
13E8:  RLC     W1,W1
13EA:  RLC     W2,W2
13EC:  RLC     W6,W6
13EE:  RLC     W7,W7
13F0:  RLC     W8,W8
13F2:  CP      W8,W5
13F4:  BRA     NZ,13FC
13F6:  CPB     W7,W4
13F8:  BRA     NZ,13FC
13FA:  CPB     W6,W3
13FC:  BRA     NC,1406
13FE:  SUB     W6,W3,W6
1400:  SUBB    W7,W4,W7
1402:  SUBB    W8,W5,W8
1404:  BSET.B  42.0
1406:  RLC     W9,W9
1408:  RLC     W10,W10
140A:  RLC     W11,W11
140C:  DEC     W12,W12
140E:  BRA     NZ,13E4
1410:  MOV     W11,W2
1412:  MOV     W10,W1
1414:  MOV     W9,W0
1416:  BTSS    W13.F
1418:  BRA     1428
141A:  COM     W3,W3
141C:  COM     W2,W2
141E:  COM     W1,W1
1420:  NEG     W0,W0
1422:  ADDC    W1,#0,W1
1424:  ADDC    W2,#0,W2
1426:  ADDC    W3,#0,W3
1428:  MOV     [--W15],W9
142A:  CP0     W9
142C:  BRA     Z,1434
142E:  MOV     W6,W0
1430:  MOV     W7,W1
1432:  MOV     W8,W2
1434:  MOV     [--W15],W9
1436:  MOV     [--W15],W8
1438:  MOV     [--W15],W7
143A:  MOV     [--W15],W6
143C:  RETURN  
*
1564:  MOV     W5,[W15++]
1566:  MOV     #C,W5
1568:  REPEAT  #3
156A:  MOV     [W5++],[W15++]
156C:  MUL.UU  W0,W2,W4
156E:  BTSS    W3.F
1570:  BRA     1576
1572:  MUL.SS  W0,W3,W6
1574:  BRA     1578
1576:  MUL.UU  W0,W3,W6
1578:  BCLR.B  42.0
157A:  ADD     W6,W5,W5
157C:  ADDC    W7,#0,W8
157E:  BTSS    W1.F
1580:  BRA     1586
1582:  MUL.SS  W1,W2,W6
1584:  BRA     1588
1586:  MUL.UU  W1,W2,W6
1588:  ADDC    W6,W5,W5
158A:  ADDC    W7,W8,W8
158C:  ADDC    #0,W9
158E:  MUL.SS  W1,W3,W6
1590:  ADDC    W6,W8,W8
1592:  ADDC    W9,W7,W7
1594:  MOV     W7,W3
1596:  MOV     W8,W2
1598:  MOV     W5,W1
159A:  MOV     W4,W0
159C:  MOV     #12,W5
159E:  REPEAT  #3
15A0:  MOV     [--W15],[W5--]
15A2:  MOV     [--W15],W5
15A4:  RETURN  
*
18BC:  MOV     W5,[W15++]
18BE:  MOV     #C,W5
18C0:  REPEAT  #3
18C2:  MOV     [W5++],[W15++]
18C4:  MOV     #0,W9
18C6:  BTSC.B  43.0
18C8:  MOV     #1,W9
18CA:  MOV     W9,[W15++]
18CC:  XOR     W1,W3,W9
18CE:  BTSS    W1.F
18D0:  BRA     18D8
18D2:  COM     W1,W1
18D4:  NEG     W0,W0
18D6:  ADDC    W1,#0,W1
18D8:  BTSS    W3.F
18DA:  BRA     18E2
18DC:  COM     W3,W3
18DE:  NEG     W2,W2
18E0:  ADDC    W3,#0,W3
18E2:  XOR     W2,W3,W4
18E4:  BRA     Z,1910
18E6:  CLR     W4
18E8:  CLR     W5
18EA:  CLR     W6
18EC:  CLR     W7
18EE:  MOV     #20,W8
18F0:  BCLR.B  42.0
18F2:  RLC     W0,W0
18F4:  RLC     W1,W1
18F6:  RLC     W4,W4
18F8:  RLC     W5,W5
18FA:  CP      W5,W3
18FC:  BRA     NZ,1900
18FE:  CPB     W4,W2
1900:  BRA     NC,1908
1902:  SUB     W4,W2,W4
1904:  SUBB    W5,W3,W5
1906:  BSET.B  42.0
1908:  RLC     W6,W6
190A:  RLC     W7,W7
190C:  DEC     W8,W8
190E:  BRA     NZ,18F0
1910:  BTSS    W9.F
1912:  BRA     1922
1914:  NEG     W6,W0
1916:  BRA     Z,191A
1918:  BRA     NZ,191E
191A:  NEG     W7,W1
191C:  BRA     1928
191E:  COM     W7,W1
1920:  BRA     1928
1922:  MOV     W7,W1
1924:  MOV     W6,W0
1926:  BRA     1928
1928:  MOV     [--W15],W9
192A:  CP0     W9
192C:  BRA     Z,1930
192E:  MOV.D   W4,W0
1930:  MOV     #12,W5
1932:  REPEAT  #3
1934:  MOV     [--W15],[W5--]
1936:  MOV     [--W15],W5
1938:  RETURN  
193A:  MOV     W5,[W15++]
193C:  MOV     W6,[W15++]
193E:  MOV     #8E,W1
1940:  BCLR    W6.0
1942:  BTSS    W0.F
1944:  BRA     194C
1946:  BSET    W6.0
1948:  NEG     W0,W0
194A:  BRA     194C
194C:  CP0     W0
194E:  BRA     Z,1978
1950:  BTSC    W0.F
1952:  BRA     195C
1954:  BCLR.B  42.0
1956:  RLC     W0,W0
1958:  DEC     W1,W1
195A:  BRA     1950
195C:  SWAP    W1
195E:  BCLR.B  42.0
1960:  RRC     W1,W1
1962:  BCLR    W0.F
1964:  SWAP    W0
1966:  XOR.B   W0L,W1L,W1L
1968:  AND.B   #0,W0L
196A:  BTSC    W6.0
196C:  BSET    W1.F
196E:  BRA     197E
1970:  MOV.B   W1L,W0L
1972:  BSET    W1.7
1974:  AND.B   #0,W1L
1976:  BRA     197E
1978:  CLR     W0
197A:  CLR     W1
197C:  BRA     197E
197E:  MOV     [--W15],W6
1980:  MOV     [--W15],W5
1982:  RETURN  
1984:  MOV     W5,[W15++]
1986:  MOV     #C,W5
1988:  REPEAT  #4
198A:  MOV     [W5++],[W15++]
198C:  CLR     W9
198E:  XOR     W1,W3,W9
1990:  MOV     W1,W6
1992:  MOV     W0,W5
1994:  MOV     W3,W8
1996:  MOV     W2,W7
1998:  RLC     W1,W1
199A:  SWAP    W1
199C:  ZE      W1,W1
199E:  CP0     W1
19A0:  BRA     Z,1A3E
19A2:  RLC     W3,W3
19A4:  SWAP    W3
19A6:  ZE      W3,W3
19A8:  CP0     W3
19AA:  BRA     Z,1A3E
19AC:  CLR     W0
19AE:  SUB.B   W1L,W3L,W0L
19B0:  BRA     NC,19B8
19B2:  ADD.B   #7F,W0L
19B4:  BRA     C,1A3E
19B6:  BRA     19BE
19B8:  SUB.B   #81,W0L
19BA:  BRA     NC,1A3E
19BC:  BRA     Z,1A3E
19BE:  MOV     W5,W1
19C0:  MOV     W6,W2
19C2:  BSET    W2.7
19C4:  AND     #FF,W2
19C6:  AND     #FF,W8
19C8:  BSET    W8.7
19CA:  MOV     #19,W10
19CC:  CLR     W3
19CE:  CLR     W4
19D0:  SUB     W1,W7,W1
19D2:  SUBB    W2,W8,W2
19D4:  BRA     N,19DA
19D6:  BRA     C,19E0
19D8:  BRA     NZ,19E2
19DA:  ADD     W1,W7,W1
19DC:  ADDC    W2,W8,W2
19DE:  BRA     19E2
19E0:  BSET    W4.0
19E2:  DEC     W10,W10
19E4:  BRA     Z,19F4
19E6:  BCLR.B  42.0
19E8:  RLC     W1,W1
19EA:  RLC     W2,W2
19EC:  BCLR.B  42.0
19EE:  RLC     W4,W4
19F0:  RLC     W3,W3
19F2:  BRA     19D0
19F4:  CLR     W10
19F6:  BTSC    W3.8
19F8:  BRA     19FC
19FA:  BRA     1A08
19FC:  BCLR.B  42.0
19FE:  RRC     W3,W3
1A00:  BCLR    W3.7
1A02:  RRC     W4,W4
1A04:  RLC     W10,W10
1A06:  BRA     1A0C
1A08:  DEC     W0,W0
1A0A:  BRA     Z,1A3E
1A0C:  BTSC    W10.F
1A0E:  BRA     NC,1A1A
1A10:  RLC     W1,W1
1A12:  RLC     W2,W2
1A14:  SUB     W1,W7,W1
1A16:  SUBB    W2,W8,W2
1A18:  BRA     NC,1A2C
1A1A:  INC     W4,W4
1A1C:  BRA     NZ,1A2C
1A1E:  INC     W3,W3
1A20:  BRA     NZ,1A2C
1A22:  INC     W0,W0
1A24:  BRA     Z,1A3E
1A26:  BRA     1A2C
1A28:  DEC     W0,W0
1A2A:  BRA     Z,1A3E
1A2C:  SWAP    W0
1A2E:  RRC     W0,W1
1A30:  BSET    W1.F
1A32:  BTSS    W9.F
1A34:  BCLR    W1.F
1A36:  BCLR    W3.7
1A38:  XOR.B   W3L,W1L,W1L
1A3A:  MOV     W4,W0
1A3C:  BRA     1A44
1A3E:  MOV     #0,W0
1A40:  MOV     #0,W1
1A42:  BRA     1A44
1A44:  MOV     #14,W5
1A46:  REPEAT  #4
1A48:  MOV     [--W15],[W5--]
1A4A:  MOV     [--W15],W5
1A4C:  RETURN  
1A4E:  MOV     W5,[W15++]
1A50:  MOV     #C,W5
1A52:  REPEAT  #3
1A54:  MOV     [W5++],[W15++]
1A56:  CLR     W9
1A58:  MOV     #8000,W8
1A5A:  BTSC.B  43.0
1A5C:  XOR     W8,W3,W3
1A5E:  CP0     W0
1A60:  BRA     NZ,1A68
1A62:  MOV     #7FFF,W10
1A64:  AND     W1,W10,W10
1A66:  BTSS.B  42.1
1A68:  MOV     W1,W10
1A6A:  XOR     W3,W10,W11
1A6C:  MOV     W1,W6
1A6E:  MOV     W3,W7
1A70:  MOV     W3,W12
1A72:  BCLR.B  42.1
1A74:  BCLR.B  42.0
1A76:  RLC     W6,W6
1A78:  SWAP    W6
1A7A:  AND     #FF,W6
1A7C:  CP0     W6
1A7E:  BRA     Z,1BC2
1A80:  BCLR.B  42.1
1A82:  BCLR.B  42.0
1A84:  RLC     W7,W7
1A86:  SWAP    W7
1A88:  AND     #FF,W7
1A8A:  CP0     W7
1A8C:  BRA     Z,1BCC
1A8E:  BCLR.B  42.1
1A90:  BCLR.B  42.0
1A92:  CP      W7,W6
1A94:  BRA     Z,1BCE
1A96:  BRA     N,1BDE
1A98:  BCLR    W9.0
1A9A:  BSET    W9.1
1A9C:  SUB     W7,W6,W8
1A9E:  MOV     W7,W6
1AA0:  AND     #FF,W1
1AA2:  BSET    W1.7
1AA4:  AND     #FF,W3
1AA6:  BSET    W3.7
1AA8:  MOV     #28,W7
1AAA:  CP      W7,W8
1AAC:  BRA     N,1AD0
1AAE:  BCLR.B  42.1
1AB0:  BCLR.B  42.0
1AB2:  RRC     W1,W1
1AB4:  RRC     W0,W0
1AB6:  DEC     W8,W8
1AB8:  BRA     NZ,1AAE
1ABA:  BRA     1AD6
1ABC:  MOV     #28,W7
1ABE:  CP      W7,W8
1AC0:  BRA     N,1AD4
1AC2:  BCLR.B  42.1
1AC4:  BCLR.B  42.0
1AC6:  RRC     W3,W3
1AC8:  RRC     W2,W2
1ACA:  DEC     W8,W8
1ACC:  BRA     NZ,1AC2
1ACE:  BRA     1AEE
1AD0:  MOV     W2,W0
1AD2:  MOV     W3,W1
1AD4:  BRA     1B5C
1AD6:  BTSS    W11.F
1AD8:  BRA     1AFC
1ADA:  BTSC    W9.4
1ADC:  MOV     W12,W11
1ADE:  NEG     W0,W0
1AE0:  BRA     Z,1AE6
1AE2:  COM.B   W1L,W1L
1AE4:  BRA     1AE8
1AE6:  NEG     W1,W1
1AE8:  BTSC    W9.4
1AEA:  BRA     1B42
1AEC:  BRA     1AFC
1AEE:  BTSS    W11.F
1AF0:  BRA     1AFC
1AF2:  NEG     W2,W2
1AF4:  BRA     Z,1AFA
1AF6:  COM.B   W3L,W3L
1AF8:  BRA     1AFC
1AFA:  NEG     W3,W3
1AFC:  AND     #FF,W5
1AFE:  BCLR.B  42.1
1B00:  BCLR.B  42.0
1B02:  ADD     W0,W2,W0
1B04:  ADDC.B  W1L,W3L,W1L
1B06:  BTSC.B  42.0
1B08:  BSET    W9.3
1B0A:  BTSC    W9.0
1B0C:  BRA     1B20
1B0E:  BTSC    W9.1
1B10:  BRA     1B14
1B12:  BRA     1B2A
1B14:  BTSC    W11.F
1B16:  BRA     1B42
1B18:  BTSC    W9.3
1B1A:  BRA     1B6E
1B1C:  BSET    W9.6
1B1E:  BRA     1B5C
1B20:  BTSC    W11.F
1B22:  BRA     1B42
1B24:  BTSC    W9.3
1B26:  BRA     1B6E
1B28:  BRA     1B5C
1B2A:  BCLR    W9.2
1B2C:  BTSC    W11.F
1B2E:  BRA     1B38
1B30:  MOV     W10,W11
1B32:  BTSC    W9.3
1B34:  BRA     1B6E
1B36:  BRA     1BA4
1B38:  BSET    W9.4
1B3A:  XOR.B   #80,W1L
1B3C:  BTSC    W1.7
1B3E:  BRA     1ADA
1B40:  MOV     W10,W11
1B42:  AND     #FF,W1
1B44:  IOR      W0,  W1,W7
1B46:  BRA     Z,1B5C
1B48:  BTSC    W1.7
1B4A:  BRA     1B5C
1B4C:  BCLR.B  42.1
1B4E:  BCLR.B  42.0
1B50:  RLC     W0,W0
1B52:  RLC     W1,W1
1B54:  DEC     W6,W6
1B56:  BTSC.B  42.1
1B58:  BRA     1BBC
1B5A:  BRA     1B48
1B5C:  BTSC    W9.0
1B5E:  MOV     W10,W11
1B60:  BTSC    W9.1
1B62:  MOV     W12,W11
1B64:  BTSS    W9.5
1B66:  BRA     1B9C
1B68:  BTSC    W10.F
1B6A:  BSET    W0.8
1B6C:  BRA     1BA4
1B6E:  BSET.B  42.0
1B70:  RRC.B   W1L,W1L
1B72:  RRC     W0,W0
1B74:  BTSC.B  42.0
1B76:  BSET    W9.5
1B78:  INC     W6,W6
1B7A:  BRA     Z,1BBC
1B7C:  BTSS    W9.5
1B7E:  BRA     1B90
1B80:  INC     W0,W0
1B82:  BRA     NZ,1B90
1B84:  INC.B   W1L,W1L
1B86:  BRA     NZ,1B90
1B88:  RRC.B   W1L,W1L
1B8A:  RRC     W0,W0
1B8C:  INC     W6,W6
1B8E:  BRA     Z,1BBC
1B90:  BTSC    W9.0
1B92:  MOV     W10,W11
1B94:  BTSC    W9.1
1B96:  MOV     W12,W11
1B98:  BTSC.B  42.1
1B9A:  BRA     1BBC
1B9C:  BTSC    W9.6
1B9E:  MOV     W10,W11
1BA0:  BTSC    W9.7
1BA2:  MOV     W12,W11
1BA4:  IOR      W0,  W1,W2
1BA6:  BRA     Z,1BEE
1BA8:  BCLR    W1.7
1BAA:  SWAP    W6
1BAC:  BCLR.B  42.1
1BAE:  BCLR.B  42.0
1BB0:  RRC     W6,W6
1BB2:  XOR     W6,W1,W1
1BB4:  BSET    W1.F
1BB6:  BTSS    W11.F
1BB8:  BCLR    W1.F
1BBA:  BRA     1BEE
1BBC:  MOV     #0,W0
1BBE:  MOV     #0,W1
1BC0:  BRA     1BEE
1BC2:  BTSC    W10.F
1BC4:  XOR     W8,W3,W3
1BC6:  MOV     W2,W0
1BC8:  MOV     W3,W1
1BCA:  BRA     1BEE
1BCC:  BRA     1BEE
1BCE:  AND     #FF,W3
1BD0:  BSET    W3.7
1BD2:  AND     #FF,W1
1BD4:  BSET    W1.7
1BD6:  BTSC    W11.F
1BD8:  BCLR    W3.7
1BDA:  BSET    W9.2
1BDC:  BRA     1AEE
1BDE:  SUB     W6,W7,W8
1BE0:  AND     #FF,W1
1BE2:  BSET    W1.7
1BE4:  AND     #FF,W3
1BE6:  BSET    W3.7
1BE8:  BCLR    W9.1
1BEA:  BSET    W9.0
1BEC:  BRA     1ABC
1BEE:  MOV     #12,W5
1BF0:  REPEAT  #3
1BF2:  MOV     [--W15],[W5--]
1BF4:  MOV     [--W15],W5
1BF6:  RETURN  
1BF8:  MOV     W5,[W15++]
1BFA:  MOV     W6,[W15++]
1BFC:  MOV     W7,[W15++]
1BFE:  XOR     W1,W3,W4
1C00:  BTSS    W4.F
1C02:  BRA     1C10
1C04:  BCLR.B  42.0
1C06:  BCLR.B  42.1
1C08:  BTSS    W1.F
1C0A:  BRA     1C58
1C0C:  BSET.B  42.0
1C0E:  BRA     1C58
1C10:  MOV     W1,W4
1C12:  MOV     W0,W5
1C14:  MOV     W3,W6
1C16:  MOV     W2,W7
1C18:  RLC     W1,W1
1C1A:  SWAP    W1
1C1C:  RLC     W3,W3
1C1E:  SWAP    W3
1C20:  SUB.B   W3L,W1L,W1L
1C22:  BRA     Z,1C2E
1C24:  BTSS    W4.F
1C26:  BRA     1C58
1C28:  MOV     #1,W0
1C2A:  XOR.B   42
1C2C:  BRA     1C58
1C2E:  MOV.B   W4L,W1L
1C30:  MOV.B   W6L,W3L
1C32:  BCLR    W1.7
1C34:  BCLR    W3.7
1C36:  SUB.B   W3L,W1L,W1L
1C38:  BRA     Z,1C44
1C3A:  BTSS    W4.F
1C3C:  BRA     1C58
1C3E:  MOV     #1,W0
1C40:  XOR.B   42
1C42:  BRA     1C58
1C44:  SUB     W7,W5,W1
1C46:  BRA     Z,1C52
1C48:  BTSS    W4.F
1C4A:  BRA     1C58
1C4C:  MOV     #1,W0
1C4E:  XOR.B   42
1C50:  BRA     1C58
1C52:  BCLR.B  42.0
1C54:  BRA     1C58
1C56:  BRA     1C58
1C58:  MOV     [--W15],W7
1C5A:  MOV     [--W15],W6
1C5C:  MOV     [--W15],W5
1C5E:  RETURN  
1C60:  MOV     W5,[W15++]
1C62:  MOV     #C,W5
1C64:  REPEAT  #4
1C66:  MOV     [W5++],[W15++]
1C68:  MOV     W0,W4
1C6A:  MOV     W1,W5
1C6C:  MOV     W3,W7
1C6E:  MOV     W2,W6
1C70:  BCLR.B  42.0
1C72:  BCLR.B  42.1
1C74:  RLC     W1,W1
1C76:  SWAP    W1
1C78:  AND     #FF,W1
1C7A:  CP0     W1
1C7C:  BRA     Z,1D14
1C7E:  BCLR.B  42.0
1C80:  BCLR.B  42.1
1C82:  RLC     W3,W3
1C84:  SWAP    W3
1C86:  AND     #FF,W3
1C88:  CP0     W3
1C8A:  BRA     Z,1D14
1C8C:  ZE      W0,W0
1C8E:  ADD.B   W3L,W1L,W0L
1C90:  BRA     C,1C9A
1C92:  SUB     #7F,W0
1C94:  BRA     Z,1D14
1C96:  BRA     NC,1D14
1C98:  BRA     1C9E
1C9A:  ADD.B   #81,W0L
1C9C:  BRA     C,1D14
1C9E:  XOR     W5,W7,W10
1CA0:  BCLR.B  42.0
1CA2:  BCLR.B  42.1
1CA4:  AND     #FF,W5
1CA6:  BSET    W5.7
1CA8:  BCLR.B  42.0
1CAA:  AND     #FF,W7
1CAC:  BSET    W7.7
1CAE:  MUL.UU  W4,W6,W2
1CB0:  MUL.UU  W5,W6,W8
1CB2:  ADDC    W8,W3,W3
1CB4:  MOV     W9,W1
1CB6:  BTSC.B  42.0
1CB8:  INC     W1,W1
1CBA:  BCLR.B  42.0
1CBC:  MUL.UU  W7,W4,W8
1CBE:  ADDC    W8,W3,W3
1CC0:  ADDC    W9,W1,W1
1CC2:  MUL.UU  W5,W7,W8
1CC4:  ADDC    W8,W1,W1
1CC6:  INC     W0,W0
1CC8:  CP0     W1
1CCA:  BTSC.B  42.1
1CCC:  BRA     1CD0
1CCE:  BRA     1CD6
1CD0:  CP0     W3
1CD2:  BTSC.B  42.1
1CD4:  BRA     1CE0
1CD6:  BTSC    W1.F
1CD8:  BRA     1CE0
1CDA:  RLC     W3,W3
1CDC:  RLC     W1,W1
1CDE:  DEC     W0,W0
1CE0:  MOV     W1,W2
1CE2:  BCLR.B  42.0
1CE4:  BTSS    W3.7
1CE6:  BRA     1CFA
1CE8:  MOV     #FF00,W7
1CEA:  AND     W3,W7,W3
1CEC:  ADD     #100,W3
1CEE:  ADDC    W2,#0,W2
1CF0:  CP0     W2
1CF2:  BRA     NZ,1CFA
1CF4:  CP0     W3
1CF6:  BRA     NZ,1CFA
1CF8:  INC     W0,W0
1CFA:  SWAP    W0
1CFC:  BCLR.B  42.0
1CFE:  BCLR.B  42.1
1D00:  RRC     W0,W1
1D02:  BTSC    W10.F
1D04:  BSET    W1.F
1D06:  BCLR    W2.F
1D08:  SWAP    W2
1D0A:  XOR.B   W2L,W1L,W1L
1D0C:  SWAP    W3
1D0E:  MOV.B   W3L,W2L
1D10:  MOV     W2,W0
1D12:  BRA     1D1A
1D14:  MOV     #0,W0
1D16:  MOV     #0,W1
1D18:  BRA     1D1A
1D1A:  MOV     #14,W5
1D1C:  REPEAT  #4
1D1E:  MOV     [--W15],[W5--]
1D20:  MOV     [--W15],W5
1D22:  RETURN  
1D24:  MOV     W0,W2
1D26:  MOV     W1,W3
1D28:  MOV.B   W1L,W0L
1D2A:  SWAP    W0
1D2C:  BSET    W0.F
1D2E:  RLC     W1,W1
1D30:  SWAP    W1
1D32:  ZE      W1,W1
1D34:  MOV     #8E,W4
1D36:  SUB.B   W4L,W1L,W1L
1D38:  BRA     Z,1D46
1D3A:  CP0     W0
1D3C:  BRA     Z,1D46
1D3E:  BCLR.B  42.0
1D40:  RRC     W0,W0
1D42:  DEC     W1,W1
1D44:  BRA     NZ,1D3A
1D46:  BTSS    W3.F
1D48:  BRA     1D4E
1D4A:  NEG     W0,W0
1D4C:  BRA     1D4E
1D4E:  RETURN  
1D50:  MOV     W5,[W15++]
1D52:  MOV     W6,[W15++]
1D54:  MOV     #8E,W1
1D56:  CP0     W0
1D58:  BRA     Z,1D7E
1D5A:  BTSC    W0.F
1D5C:  BRA     1D66
1D5E:  BCLR.B  42.0
1D60:  RLC     W0,W0
1D62:  DEC     W1,W1
1D64:  BRA     1D5A
1D66:  SWAP    W1
1D68:  BCLR.B  42.0
1D6A:  RRC     W1,W1
1D6C:  BCLR    W0.F
1D6E:  SWAP    W0
1D70:  XOR.B   W0L,W1L,W1L
1D72:  AND.B   #0,W0L
1D74:  BRA     1D84
1D76:  MOV.B   W1L,W0L
1D78:  BSET    W1.7
1D7A:  AND.B   #0,W1L
1D7C:  BRA     1D84
1D7E:  CLR     W0
1D80:  CLR     W1
1D82:  BRA     1D84
1D84:  MOV     [--W15],W6
1D86:  MOV     [--W15],W5
1D88:  RETURN  
*
2B4E:  MOV     W5,[W15++]
2B50:  MOV     W6,[W15++]
2B52:  MOV     W2,W3
2B54:  MOV     W2,W5
2B56:  BCLR.B  42.0
2B58:  RLC     W3,W3
2B5A:  SWAP    W3
2B5C:  AND     #FF,W3
2B5E:  BRA     NZ,2B66
2B60:  MUL.UU  W0,#0,W0
2B62:  MUL.UU  W2,#0,W2
2B64:  BRA     2B92
2B66:  ADD     #380,W3
2B68:  AND     #7F,W2
2B6A:  MOV     #3,W6
2B6C:  CLR     W4
2B6E:  BCLR.B  42.0
2B70:  RRC     W2,W2
2B72:  RRC     W1,W1
2B74:  RRC     W0,W0
2B76:  BTSC.B  42.0
2B78:  INC     W4,W4
2B7A:  DEC     W6,W6
2B7C:  BRA     NZ,2B6E
2B7E:  BCLR    W2.7
2B80:  SL      W3,#4,W3
2B82:  BCLR    W3.F
2B84:  BTSC    W5.F
2B86:  BSET    W3.F
2B88:  XOR     W2,W3,W3
2B8A:  MOV     W1,W2
2B8C:  MOV     W0,W1
2B8E:  ADD     W4,W1,W1
2B90:  CLR     W0
2B92:  MOV     [--W15],W6
2B94:  MOV     [--W15],W5
2B96:  RETURN  
2B98:  MOV     W8,[W15++]
2B9A:  MOV     #12,W8
2B9C:  REPEAT  #4
2B9E:  MOV     [W8++],[W15++]
2BA0:  CLR     W11
2BA2:  MUL.UU  W12,#0,W12
2BA4:  MOV     W3,W8
2BA6:  MOV     W7,W9
2BA8:  MOV     #7FF,W10
2BAA:  BCLR.B  42.0
2BAC:  BCLR.B  42.1
2BAE:  ASR     W8,#4,W8
2BB0:  AND     W10,W8,W8
2BB2:  CP0     W8
2BB4:  BRA     Z,2C98
2BB6:  BCLR.B  42.0
2BB8:  BCLR.B  42.1
2BBA:  ASR     W9,#4,W9
2BBC:  AND     W10,W9,W9
2BBE:  CP0     W9
2BC0:  BRA     Z,2C98
2BC2:  ADD     W9,W8,W8
2BC4:  BTSC    W9.B
2BC6:  BRA     2BD0
2BC8:  SUB     #3FF,W8
2BCA:  BRA     Z,2C98
2BCC:  BRA     NC,2C98
2BCE:  BRA     2BD6
2BD0:  MOV     #401,W10
2BD2:  ADD.B   W10L,W5L,W5L
2BD4:  BRA     C,2C98
2BD6:  XOR     W3,W7,W13
2BD8:  BCLR.B  42.0
2BDA:  BCLR.B  42.1
2BDC:  AND     #F,W3
2BDE:  BSET    W3.4
2BE0:  AND     #F,W7
2BE2:  BSET    W7.4
2BE4:  MOV     W8,[W15++]
2BE6:  MUL.UU  W4,W1,W8
2BE8:  MUL.UU  W5,W0,W10
2BEA:  ADD     W8,W10,W10
2BEC:  ADDC    W9,W11,W11
2BEE:  ADDC    #0,W12
2BF0:  MUL.UU  W4,W2,W8
2BF2:  ADD     W8,W11,W11
2BF4:  ADDC    W9,W12,W12
2BF6:  MUL.UU  W5,W1,W8
2BF8:  CLR     W10
2BFA:  ADD     W8,W11,W11
2BFC:  ADDC    W9,W12,W12
2BFE:  ADDC    #0,W10
2C00:  MUL.UU  W6,W0,W8
2C02:  ADD     W8,W11,W11
2C04:  ADDC    W9,W12,W12
2C06:  ADDC    #0,W10
2C08:  CLR     W11
2C0A:  MUL.UU  W4,W3,W8
2C0C:  ADD     W8,W12,W12
2C0E:  ADDC    W9,W10,W10
2C10:  ADDC    #0,W11
2C12:  MUL.UU  W5,W2,W8
2C14:  ADD     W8,W12,W12
2C16:  ADDC    W9,W10,W10
2C18:  ADDC    #0,W11
2C1A:  MUL.UU  W6,W1,W8
2C1C:  ADD     W8,W12,W12
2C1E:  ADDC    W9,W10,W10
2C20:  ADDC    #0,W11
2C22:  MUL.UU  W7,W0,W8
2C24:  ADD     W8,W12,W12
2C26:  ADDC    W9,W10,W10
2C28:  ADDC    #0,W11
2C2A:  MOV     W12,W0
2C2C:  CLR     W12
2C2E:  MUL.UU  W5,W3,W8
2C30:  ADD     W8,W10,W10
2C32:  ADDC    W9,W11,W11
2C34:  ADDC    #0,W12
2C36:  MUL.UU  W6,W2,W8
2C38:  ADD     W8,W10,W10
2C3A:  ADDC    W9,W11,W11
2C3C:  ADDC    #0,W12
2C3E:  MUL.UU  W6,W3,W8
2C40:  ADD     W8,W11,W11
2C42:  ADDC    W9,W12,W12
2C44:  MUL.UU  W7,W1,W8
2C46:  ADD     W8,W10,W10
2C48:  ADDC    W9,W11,W11
2C4A:  ADDC    #0,W12
2C4C:  MUL.UU  W7,W2,W8
2C4E:  ADD     W8,W11,W11
2C50:  ADDC    W9,W12,W12
2C52:  MUL.UU  W7,W3,W8
2C54:  ADD     W8,W12,W12
2C56:  MOV     W10,W1
2C58:  MOV     W11,W2
2C5A:  MOV     W12,W3
2C5C:  MOV     #5,W4
2C5E:  BCLR.B  42.0
2C60:  RRC     W3,W3
2C62:  RRC     W2,W2
2C64:  RRC     W1,W1
2C66:  RRC     W0,W0
2C68:  DEC     W4,W4
2C6A:  BRA     NZ,2C5E
2C6C:  MOV     [--W15],W8
2C6E:  INC     W8,W8
2C70:  IOR      W0,  W1,W6
2C72:  BRA     Z,2C76
2C74:  BRA     2C7A
2C76:  IOR      W2,  W3,W6
2C78:  BRA     Z,2C8A
2C7A:  BTSC    W3.4
2C7C:  BRA     2C8A
2C7E:  BCLR.B  42.0
2C80:  RLC     W0,W0
2C82:  RLC     W1,W1
2C84:  RLC     W2,W2
2C86:  RLC     W3,W3
2C88:  DEC     W8,W8
2C8A:  SL      W8,#4,W8
2C8C:  BCLR    W3.F
2C8E:  BTSC    W13.F
2C90:  BSET    W3.F
2C92:  BCLR    W3.4
2C94:  XOR     W8,W3,W3
2C96:  BRA     2C9E
2C98:  MUL.UU  W0,#0,W0
2C9A:  MUL.UU  W0,#0,W2
2C9C:  BRA     2C9E
2C9E:  MOV     #1A,W8
2CA0:  REPEAT  #4
2CA2:  MOV     [--W15],[W8--]
2CA4:  MOV     [--W15],W8
2CA6:  RETURN  
2CA8:  MOV     W5,[W15++]
2CAA:  MOV     #C,W5
2CAC:  REPEAT  #5
2CAE:  MOV     [W5++],[W15++]
2CB0:  MOV     W3,W8
2CB2:  MOV     W2,W7
2CB4:  MOV     W1,W6
2CB6:  MOV     W0,W5
2CB8:  MOV     W3,W9
2CBA:  MOV     #473,W11
2CBC:  ASR     W3,#4,W3
2CBE:  MOV     #7FF,W10
2CC0:  AND     W10,W3,W3
2CC2:  SUB     W11,W3,W11
2CC4:  AND     #1F,W8
2CC6:  BSET    W8.4
2CC8:  CLR     W0
2CCA:  CLR     W1
2CCC:  CLR     W2
2CCE:  CLR     W3
2CD0:  BCLR.B  42.0
2CD2:  RRC     W8,W8
2CD4:  RRC     W7,W7
2CD6:  RRC     W6,W6
2CD8:  RRC     W5,W5
2CDA:  RRC     W3,W3
2CDC:  RRC     W2,W2
2CDE:  RRC     W1,W1
2CE0:  RRC     W0,W0
2CE2:  DEC     W11,W11
2CE4:  BRA     NZ,2CD0
2CE6:  BTSS    W9.F
2CE8:  BRA     2CFC
2CEA:  COM     W0,W0
2CEC:  COM     W1,W1
2CEE:  COM     W2,W2
2CF0:  COM     W3,W3
2CF2:  INC     W0,W0
2CF4:  ADDC    #0,W1
2CF6:  ADDC    #0,W2
2CF8:  ADDC    #0,W3
2CFA:  BRA     2CFC
2CFC:  MOV     #16,W5
2CFE:  REPEAT  #5
2D00:  MOV     [--W15],[W5--]
2D02:  MOV     [--W15],W5
2D04:  RETURN  
2D06:  MOV     W12,[W15++]
2D08:  MOV     W13,[W15++]
2D0A:  CLR     W8
2D0C:  CLR     W9
2D0E:  CLR     W10
2D10:  CLR     W11
2D12:  CLR     W12
2D14:  CLR     W13
2D16:  MOV     #E,W8
2D18:  MOV     #0,W9
2D1A:  LNK     #10
2D1C:  MOV     W12,[W14+W8]
2D1E:  DEC2    W8,W8
2D20:  BRA     NN,2D1C
2D22:  XOR     W4,W5,W8
2D24:  BRA     NZ,2D2A
2D26:  XOR     W6,W7,W8
2D28:  BRA     Z,2D88
2D2A:  CLR     W8
2D2C:  MOV     #40,W13
2D2E:  MOV     #40,W13
2D30:  BCLR.B  42.0
2D32:  RLC     W0,W0
2D34:  RLC     W1,W1
2D36:  RLC     W2,W2
2D38:  RLC     W3,W3
2D3A:  RLC     W8,W8
2D3C:  RLC     W9,W9
2D3E:  RLC     W10,W10
2D40:  RLC     W11,W11
2D42:  CP      W11,W7
2D44:  BRA     NZ,2D50
2D46:  CPB     W10,W6
2D48:  BRA     NZ,2D50
2D4A:  CPB     W9,W5
2D4C:  BRA     NZ,2D50
2D4E:  CPB     W8,W4
2D50:  BRA     NC,2D5C
2D52:  SUB     W8,W4,W8
2D54:  SUBB    W9,W5,W9
2D56:  SUBB    W10,W6,W10
2D58:  SUBB    W11,W7,W11
2D5A:  BSET.B  42.0
2D5C:  MOV     W8,[W14]
2D5E:  MOV     W9,[W14+#2]
2D60:  MOV     W10,[W14+#4]
2D62:  MOV     W11,[W14+#6]
2D64:  MOV     [W14+#8],W8
2D66:  MOV     [W14+#A],W9
2D68:  MOV     [W14+#C],W10
2D6A:  MOV     [W14+#E],W11
2D6C:  RLC     W8,W8
2D6E:  RLC     W9,W9
2D70:  RLC     W10,W10
2D72:  RLC     W11,W11
2D74:  MOV     W8,[W14+#8]
2D76:  MOV     W9,[W14+#A]
2D78:  MOV     W10,[W14+#C]
2D7A:  MOV     W11,[W14+#E]
2D7C:  MOV     [W14],W8
2D7E:  MOV     [W14+#2],W9
2D80:  MOV     [W14+#4],W10
2D82:  MOV     [W14+#6],W11
2D84:  DEC     W13,W13
2D86:  BRA     NZ,2D30
2D88:  MOV     [W14+#8],W0
2D8A:  MOV     [W14+#A],W1
2D8C:  MOV     [W14+#C],W2
2D8E:  MOV     [W14+#E],W3
2D90:  ULNK    
2D92:  BRA     2D94
2D94:  MOV     [--W15],W13
2D96:  MOV     [--W15],W12
2D98:  RETURN  
2D9A:  MOV     W5,[W15++]
2D9C:  MOV     #C,W5
2D9E:  REPEAT  #7
2DA0:  MOV     [W5++],[W15++]
2DA2:  LNK     #2A
2DA4:  MOV     #28,W8
2DA6:  CLR     W12
2DA8:  MOV     W12,[W14+W8]
2DAA:  DEC2    W8,W8
2DAC:  BRA     NN,2DA8
2DAE:  MOV     W10,[W14+#28]
2DB0:  CP0     W9
2DB2:  BRA     Z,2DCE
2DB4:  MOV     W9,[W14+#26]
2DB6:  MOV     #4024,W7
2DB8:  CLR     W6
2DBA:  MUL.UU  W4,#0,W4
2DBC:  MOV     W9,[W14+#24]
2DBE:  MOV     #4024,W7
2DC0:  CLR     W6
2DC2:  MUL.UU  W4,#0,W4
2DC4:  CALL    2B98
2DC8:  MOV     [W14+#24],W9
2DCA:  DEC     W9,W9
2DCC:  BRA     NZ,2DBC
2DCE:  MOV     [W14+#26],W9
2DD0:  MOV     #14,W8
2DD2:  MOV     W8,[W14+#24]
2DD4:  MOV     #41CD,W7
2DD6:  MOV     #CD65,W6
2DD8:  MUL.UU  W4,#0,W4
2DDA:  MOV     W0,[W14+#10]
2DDC:  MOV     W1,[W14+#12]
2DDE:  MOV     W2,[W14+#14]
2DE0:  MOV     W3,[W14+#16]
2DE2:  MOV     #14,W8
2DE4:  MOV     W8,[W14+#20]
2DE6:  MOV     #0,W4
2DE8:  MOV     #89E8,W5
2DEA:  MOV     #2304,W6
2DEC:  MOV     #8AC7,W7
2DEE:  MOV     W4,[W14+#18]
2DF0:  MOV     W5,[W14+#1A]
2DF2:  MOV     W6,[W14+#1C]
2DF4:  MOV     W7,[W14+#1E]
2DF6:  BTSS    W3.F
2DF8:  BRA     2E02
2DFA:  MOV     [W14+#28],W8
2DFC:  DEC     W8,W8
2DFE:  BSET    W8.D
2E00:  MOV     W8,[W14+#28]
2E02:  BCLR    W3.F
2E04:  CALL    2CA8
2E08:  MOV     [W14+#28],W8
2E0A:  MOV     [W14+#26],W9
2E0C:  CP0     W9
2E0E:  BTSC.B  42.1
2E10:  INC.B   W8L,W8L
2E12:  MOV     W8,[W14+#28]
2E14:  MOV     [W14+#22],W9
2E16:  CLR     W9
2E18:  MOV     W9,[W14+#22]
2E1A:  MOV     [W14+#18],W4
2E1C:  MOV     [W14+#1A],W5
2E1E:  MOV     [W14+#1C],W6
2E20:  MOV     [W14+#1E],W7
2E22:  CALL    2D06
2E26:  MOV     [W14+#22],W13
2E28:  BTSC    W13.0
2E2A:  BRA     2EF0
2E2C:  MOV     W8,[W14+#10]
2E2E:  MOV     W9,[W14+#12]
2E30:  MOV     W10,[W14+#14]
2E32:  MOV     W11,[W14+#16]
2E34:  MOV     [W14+#22],W13
2E36:  BTG     W13.0
2E38:  MOV     W13,[W14+#22]
2E3A:  CP0     W0
2E3C:  BRA     NZ,2E62
2E3E:  MOV     [W14+#26],W9
2E40:  INC     W9,W9
2E42:  MOV     [W14+#24],W10
2E44:  SUB     W10,W9,W8
2E46:  BRA     Z,2E62
2E48:  MOV     [W14+#28],W11
2E4A:  CP0     W11
2E4C:  BRA     Z,2E6A
2E4E:  AND     W11,#1F,W8
2E50:  SUB     W10,W8,W8
2E52:  BRA     Z,2E56
2E54:  BRA     C,2ED8
2E56:  BTSC    W11.F
2E58:  BRA     2ED8
2E5A:  BTSC    W11.E
2E5C:  BRA     2E6A
2E5E:  MOV     #20,W0
2E60:  BRA     2ED0
2E62:  MOV     [W14+#28],W11
2E64:  MOV     #2000,W12
2E66:  AND     W12,W11,W11
2E68:  MOV     W11,[W14+#28]
2E6A:  MOV     [W14+#28],W11
2E6C:  BTSS    W11.D
2E6E:  BRA     2E8E
2E70:  BCLR    W11.D
2E72:  MOV     [W14+#26],W9
2E74:  CP0     W9
2E76:  BTSS.B  42.1
2E78:  DEC     W11,W11
2E7A:  CLR     W11
2E7C:  MOV     W11,[W14+#28]
2E7E:  MOV     W0,W10
2E80:  BTSC.B  233.1
2E82:  BRA     2E80
2E84:  MOV     #2D,W4
2E86:  MOV     W4,234
2E88:  MOV     W10,W0
2E8A:  CLR     W11
2E8C:  MOV     W11,[W14+#28]
2E8E:  MOV     [W14+#26],W9
2E90:  MOV     [W14+#24],W10
2E92:  SUB     W10,W9,W8
2E94:  BRA     NZ,2EAE
2E96:  CLR     W11
2E98:  MOV     W11,[W14+#28]
2E9A:  MOV     W0,W10
2E9C:  BTSC.B  233.1
2E9E:  BRA     2E9C
2EA0:  MOV     #2E,W4
2EA2:  MOV     W4,234
2EA4:  MOV     [W14+#28],W11
2EA6:  MOV     #2000,W12
2EA8:  AND     W12,W11,W11
2EAA:  MOV     W11,[W14+#28]
2EAC:  MOV     W10,W0
2EAE:  MOV     #30,W1
2EB0:  MOV     [W14+#28],W11
2EB2:  BTSS    W11.D
2EB4:  BRA     2ED0
2EB6:  BCLR    W11.D
2EB8:  MOV     [W14+#26],W9
2EBA:  CP0     W9
2EBC:  BTSS.B  42.1
2EBE:  DEC     W11,W11
2EC0:  CLR     W11
2EC2:  MOV     W11,[W14+#28]
2EC4:  BTSC.B  233.1
2EC6:  BRA     2EC4
2EC8:  MOV     #2D,W4
2ECA:  MOV     W4,234
2ECC:  CLR     W0
2ECE:  MOV     #30,W1
2ED0:  ADD     W1,W0,W0
2ED2:  BTSC.B  233.1
2ED4:  BRA     2ED2
2ED6:  MOV     W0,234
2ED8:  MOV     [W14+#24],W13
2EDA:  DEC     W13,W13
2EDC:  BRA     Z,2F10
2EDE:  MOV     W13,[W14+#24]
2EE0:  MOV     [W14+#18],W0
2EE2:  MOV     [W14+#1A],W1
2EE4:  MOV     [W14+#1C],W2
2EE6:  MOV     [W14+#1E],W3
2EE8:  MOV     #A,W4
2EEA:  CLR     W5
2EEC:  MUL.UU  W6,#0,W6
2EEE:  BRA     2E22
2EF0:  MOV     W0,[W14+#18]
2EF2:  MOV     W1,[W14+#1A]
2EF4:  MOV     W2,[W14+#1C]
2EF6:  MOV     W3,[W14+#1E]
2EF8:  MOV     W0,W4
2EFA:  MOV     W1,W5
2EFC:  MOV     W2,W6
2EFE:  MOV     W3,W7
2F00:  MOV     [W14+#10],W0
2F02:  MOV     [W14+#12],W1
2F04:  MOV     [W14+#14],W2
2F06:  MOV     [W14+#16],W3
2F08:  MOV     [W14+#22],W13
2F0A:  BTG     W13.0
2F0C:  MOV     W13,[W14+#22]
2F0E:  BRA     2E22
2F10:  ULNK    
2F12:  MOV     #1A,W5
2F14:  REPEAT  #7
2F16:  MOV     [--W15],[W5--]
2F18:  MOV     [--W15],W5
2F1A:  RETURN  
*
2F9A:  MOV     W5,[W15++]
2F9C:  MOV     #C,W5
2F9E:  REPEAT  #3
2FA0:  MOV     [W5++],[W15++]
2FA2:  MOV     W0,W7
2FA4:  MOV     W4,W9
2FA6:  BCLR    W4.F
2FA8:  CP0     W4
2FAA:  BRA     NZ,2FB8
2FAC:  BTSC    W9.F
2FAE:  BRA     2FB4
2FB0:  MOV     #0,W5
2FB2:  BRA     2FD6
2FB4:  MOV     #0,W5
2FB6:  BRA     2FD6
2FB8:  SUB.B   W4L,#6,W5L
2FBA:  BRA     NC,2FD4
2FBC:  MOV     #30,W0
2FBE:  BTSS    W9.F
2FC0:  MOV     #20,W0
2FC2:  MOV     W0,[W15++]
2FC4:  BTSC.B  233.1
2FC6:  BRA     2FC4
2FC8:  MOV     W0,234
2FCA:  MOV     [--W15],W0
2FCC:  DEC     W5,W5
2FCE:  BRA     NN,2FC2
2FD0:  MOV     #5,W5
2FD2:  BRA     2FD6
2FD4:  MOV     W4,W5
2FD6:  MOV     #6,W4
2FD8:  BSET    W5.E
2FDA:  BTSC    W9.F
2FDC:  BSET    W5.F
2FDE:  MOV     #2710,W8
2FE0:  REPEAT  #11
2FE2:  DIV.U   W7,W8
2FE4:  CALL    3018
2FE8:  MOV     W1,W7
2FEA:  MOV     #3E8,W8
2FEC:  REPEAT  #11
2FEE:  DIV.U   W7,W8
2FF0:  CALL    3018
2FF4:  MOV     W1,W7
2FF6:  MOV     #64,W8
2FF8:  REPEAT  #11
2FFA:  DIV.U   W7,W8
2FFC:  CALL    3018
3000:  MOV     W1,W7
3002:  MOV     #A,W8
3004:  REPEAT  #11
3006:  DIV.U   W7,W8
3008:  CALL    3018
300C:  MOV     #30,W0
300E:  ADD.B   W1L,W0L,W0L
3010:  BTSC.B  233.1
3012:  BRA     3010
3014:  MOV     W0,234
3016:  BRA     3046
3018:  MOV     #30,W6
301A:  CP0     W0
301C:  BRA     NZ,303A
301E:  BTSS    W5.E
3020:  BRA     303C
3022:  DEC     W4,W4
3024:  CP.B    W4L,W5L
3026:  BRA     Z,302C
3028:  BTSC.B  42.0
302A:  RETURN  
302C:  CP0     W0
302E:  BRA     NZ,303A
3030:  BTSS    W5.E
3032:  BRA     303C
3034:  BTSS    W5.F
3036:  MOV     #20,W6
3038:  BRA     303C
303A:  BCLR    W5.E
303C:  ADD.B   W6L,W0L,W0L
303E:  BTSC.B  233.1
3040:  BRA     303E
3042:  MOV     W0,234
3044:  RETURN  
3046:  MOV     #12,W5
3048:  REPEAT  #3
304A:  MOV     [--W15],[W5--]
304C:  MOV     [--W15],W5
304E:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... //#device ICD=TRUE 
.................... #use delay(clock=16000000) 
*
340E:  CP0     W0
3410:  BTSC.B  42.1
3412:  BRA     341C
3414:  REPEAT  #1F3B
3416:  NOP     
3418:  DEC     W0,W0
341A:  BRA     NZ,3414
341C:  RETURN  
.................... #use rtos(timer=1,minor_cycle=100ms,statistics)// 
....................  
.................... #use fixed_io(b_outputs=PIN_b6) 
.................... #fuses nowdt,protect,FRC_PLL 
.................... //#build (stack=256) 
....................  
.................... #define fet1 PIN_b6//d5 
.................... //#define fet2 PIN_b14//d4 
....................  
.................... //#define led1 PIN_b10 
.................... //#define led2 PIN_b11 
.................... //#define led3 PIN_b12 
.................... //#define led4 PIN_b13 
....................  
.................... //#define TOSTRING(s)   #s 
.................... //#define nmea(ss) NMEA_##ss(); 
.................... //------------------------------------------------------------------------------// 
.................... #include<gsm_7.h> 
.................... /****************IMEI-866762029510326;BAUD-19200  *****************************/ 
.................... /****************IMEI-866593020769383;BAUD-9600  *****************************/ 
.................... /****************IMEI-866762027240124;BAUD-19200  *****************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
*
04F0:  MOV     W5,[W15++]
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
04F2:  PUSH    CB4
04F4:  POP     CBA
04F6:  CP0     CB8
04F8:  BRA     Z,510
04FA:  MOV     CB6,W0
04FC:  CP0.B   [W0]
04FE:  BRA     Z,510
....................      *s++ = *s2++; 
0500:  MOV     CBA,W0
0502:  INC     0CBA
0504:  MOV     W0,W5
0506:  MOV     CB6,W0
0508:  INC     0CB6
050A:  MOV.B   [W0],[W5]
050C:  DEC     0CB8
050E:  BRA     4F6
....................   for (; n > 0; n--) 
0510:  CP0     CB8
0512:  BRA     Z,520
....................      *s++ = '\0'; 
0514:  MOV     CBA,W0
0516:  INC     0CBA
0518:  MOV     W0,W5
051A:  CLR.B   [W5]
051C:  DEC     0CB8
051E:  BRA     510
....................  
....................   return(s1); 
0520:  PUSH    CB4
0522:  POP     0
0524:  MOV     [--W15],W5
0526:  RETURN  
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
*
0628:  MOV     W5,[W15++]
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
062A:  CP0     CBC
062C:  BRA     Z,66A
....................       if (*s1 != *s2) 
062E:  MOV     CB8,W0
0630:  MOV.B   [W0],W5L
0632:  MOV     CBA,W0
0634:  MOV     W0,W4
0636:  MOV.B   [W4],W0L
0638:  CP.B    W5L,W0L
063A:  BRA     Z,654
....................          return((*s1 <*s2) ? -1: 1); 
063C:  MOV     CB8,W0
063E:  MOV.B   [W0],W5L
0640:  MOV     CBA,W0
0642:  MOV     W0,W4
0644:  MOV.B   [W4],W0L
0646:  CP.B    W5L,W0L
0648:  BRA     C,64E
064A:  SETM.B  W0
064C:  BRA     650
064E:  MOV.B   #1,W0L
0650:  BRA     66C
0652:  BRA     65E
....................       else if (*s1 == '\0') 
0654:  MOV     CB8,W0
0656:  CP0.B   [W0]
0658:  BRA     NZ,65E
....................          return(0); 
065A:  CLR.B   0
065C:  BRA     66C
065E:  MOV     CB8,W0
0660:  INC     0CB8
0662:  MOV     CBA,W0
0664:  INC     0CBA
0666:  DEC     0CBC
0668:  BRA     62A
....................    return(0); 
066A:  CLR.B   0
066C:  MOV     [--W15],W5
066E:  RETURN  
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
*
0AF2:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
0AF4:  PUSH    BCA
0AF6:  POP     BCE
0AF8:  MOV     BCE,W0
0AFA:  CP0.B   [W0]
0AFC:  BRA     Z,B24
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0AFE:  PUSH    BCC
0B00:  POP     BD0
0B02:  MOV     BD0,W0
0B04:  CP0.B   [W0]
0B06:  BRA     Z,B20
....................          if (*sc1 == *sc2) 
0B08:  MOV     BCE,W0
0B0A:  MOV.B   [W0],W5L
0B0C:  MOV     BD0,W0
0B0E:  MOV     W0,W4
0B10:  MOV.B   [W4],W0L
0B12:  CP.B    W5L,W0L
0B14:  BRA     NZ,B1C
....................             return(sc1); 
0B16:  PUSH    BCE
0B18:  POP     0
0B1A:  BRA     B26
0B1C:  INC     0BD0
0B1E:  BRA     B02
0B20:  INC     0BCE
0B22:  BRA     AF8
....................    return(0); 
0B24:  CLR     0
0B26:  MOV     [--W15],W5
0B28:  RETURN  
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
*
0AB0:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
0AB2:  PUSH    BCA
0AB4:  POP     BCE
0AB6:  MOV     BCE,W0
0AB8:  CP0.B   [W0]
0ABA:  BRA     Z,AE8
....................       for (sc2 = s2; ; sc2++) 
0ABC:  PUSH    BCC
0ABE:  POP     BD0
....................     if (*sc2 == '\0') 
0AC0:  MOV     BD0,W0
0AC2:  CP0.B   [W0]
0AC4:  BRA     NZ,AD0
....................        return(sc1 - s1); 
0AC6:  MOV     BCE,W4
0AC8:  MOV     BCA,W3
0ACA:  SUB     W4,W3,W0
0ACC:  BRA     AEE
0ACE:  BRA     AE0
....................          else if (*sc1 == *sc2) 
0AD0:  MOV     BCE,W0
0AD2:  MOV.B   [W0],W5L
0AD4:  MOV     BD0,W0
0AD6:  MOV     W0,W4
0AD8:  MOV.B   [W4],W0L
0ADA:  CP.B    W5L,W0L
0ADC:  BRA     NZ,AE0
....................             break; 
0ADE:  BRA     AE4
0AE0:  INC     0BD0
0AE2:  BRA     AC0
0AE4:  INC     0BCE
0AE6:  BRA     AB6
....................    return(sc1 - s1); 
0AE8:  MOV     BCE,W4
0AEA:  MOV     BCA,W3
0AEC:  SUB     W4,W3,W0
0AEE:  MOV     [--W15],W5
0AF0:  RETURN  
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
*
0A94:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
0A96:  PUSH    BCA
0A98:  POP     BCC
0A9A:  MOV     BCC,W0
0A9C:  CP0.B   [W0]
0A9E:  BRA     Z,AA4
0AA0:  INC     0BCC
0AA2:  BRA     A9A
....................    return(sc - s); 
0AA4:  MOV     BCC,W4
0AA6:  MOV     BCA,W3
0AA8:  SUB     W4,W3,W0
0AAA:  MOV     W0,0
0AAC:  MOV     [--W15],W5
0AAE:  RETURN  
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
*
0B2A:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
0B2C:  CP0     BC0
0B2E:  BRA     Z,B34
0B30:  MOV     BC0,W0
0B32:  BRA     B36
0B34:  MOV     85E,W0
0B36:  MOV     W0,BC4
....................    beg += strspn(beg, s2); 
0B38:  PUSH    BC4
0B3A:  POP     BCA
0B3C:  PUSH    BC2
0B3E:  POP     BCC
0B40:  CALL    AB0
0B44:  MOV.B   W0L,W5L
0B46:  ZE      W5,W5
0B48:  MOV     W5,W0
0B4A:  ADD     BC4
....................    if (*beg == '\0') 
0B4C:  MOV     BC4,W0
0B4E:  CP0.B   [W0]
0B50:  BRA     NZ,B56
....................       return(0); 
0B52:  CLR     0
0B54:  BRA     B86
....................        
....................    end = strpbrk(beg, s2); 
0B56:  PUSH    BC4
0B58:  POP     BCA
0B5A:  PUSH    BC2
0B5C:  POP     BCC
0B5E:  CALL    AF2
0B62:  MOV     W0,BC6
....................    if (end != '\0') 
0B64:  CP0     BC6
0B66:  BRA     Z,B74
....................    { 
....................       *end = '\0'; 
0B68:  MOV     BC6,W5
0B6A:  CLR.B   [W5]
....................       end++; 
0B6C:  INC     0BC6
....................       save = end; 
0B6E:  PUSH    BC6
0B70:  POP     85E
....................    } 
0B72:  BRA     B82
....................    else 
....................       save = beg + strlen(beg); 
0B74:  PUSH    BC4
0B76:  POP     BCA
0B78:  CALL    A94
0B7C:  MOV     BC4,W4
0B7E:  ADD     W0,W4,W0
0B80:  MOV     W0,85E
....................     
....................    return(beg); 
0B82:  PUSH    BC4
0B84:  POP     0
0B86:  MOV     [--W15],W5
0B88:  RETURN  
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
*
1F24:  MOV     W5,[W15++]
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
1F26:  MOV     BF0,W0
1F28:  MOV     BF2,W1
1F2A:  MOV     #0,W2
1F2C:  MOV     #0,W3
1F2E:  CALL    1BF8
1F32:  BRA     C,1F36
1F34:  BRA     NZ,1F3C
....................       return(0.0); 
1F36:  MOV     #0,W0
1F38:  MOV     #0,W1
1F3A:  BRA     1FF4
....................  
....................    y=x; 
1F3C:  PUSH    BF0
1F3E:  POP     BF4
1F40:  PUSH    BF2
1F42:  POP     BF6
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
1F44:  MOV     #BF7,W4
1F46:  MOV     W4,C00
....................     data1 = *(((unsigned int8 *)(&y))+3); 
1F48:  MOV     #BF7,W0
1F4A:  MOV     BFC,W4
1F4C:  MOV.B   [W0+#0],W4L
1F4E:  MOV     W4,BFC
1F50:  CLR.B   BFD
....................     data2 = *(((unsigned int8 *)(&y))+2); 
1F52:  MOV     #BF6,W0
1F54:  MOV     BFE,W4
1F56:  MOV.B   [W0+#0],W4L
1F58:  MOV     W4,BFE
1F5A:  CLR.B   BFF
....................     rotate_left(&data1,1);     
1F5C:  MOV     #BFC,W1
1F5E:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7))     
1F60:  BTSS.B  BFE.7
1F62:  BRA     1F66
....................        bit_set(data1,0);     
1F64:  BSET.B  BFC.0
....................     data1 = ((data1+127) >>1); 
1F66:  MOV     #7F,W4
1F68:  MOV     BFC,W3
1F6A:  ADD     W3,W4,W5
1F6C:  MOV     W5,BFC
1F6E:  LSR     BFC
....................     bit_clear(data2,7); 
1F70:  BCLR.B  BFE.7
....................     if(bit_test(data1,0)) 
1F72:  BTSS.B  BFC.0
1F74:  BRA     1F78
....................        bit_set(data2,7); 
1F76:  BSET.B  BFE.7
....................     data1 = data1 >>1; 
1F78:  LSR     BFC
....................     *(((unsigned int8 *)(&y))+3) = data1; 
1F7A:  MOV     #BF7,W5
1F7C:  MOV     BFC,W0
1F7E:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
1F80:  MOV     #BF6,W5
1F82:  MOV     BFE,W0
1F84:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
1F86:  PUSH    BF4
1F88:  POP     BF8
1F8A:  PUSH    BF6
1F8C:  POP     BFA
....................       y+=(x/y); 
1F8E:  MOV     BF0,W0
1F90:  MOV     BF2,W1
1F92:  MOV     BF4,W2
1F94:  MOV     BF6,W3
1F96:  CALL    1984
1F9A:  BCLR.B  43.0
1F9C:  MOV     W0,W2
1F9E:  MOV     W1,W3
1FA0:  MOV     BF4,W0
1FA2:  MOV     BF6,W1
1FA4:  CALL    1A4E
1FA8:  MOV     W0,BF4
1FAA:  MOV     W1,BF6
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
1FAC:  MOV     #BF7,W0
1FAE:  MOV     BFC,W4
1FB0:  MOV.B   [W0+#0],W4L
1FB2:  MOV     W4,BFC
1FB4:  CLR.B   BFD
....................     data2 = *(((unsigned int8 *)(&y))+2); 
1FB6:  MOV     #BF6,W0
1FB8:  MOV     BFE,W4
1FBA:  MOV.B   [W0+#0],W4L
1FBC:  MOV     W4,BFE
1FBE:  CLR.B   BFF
....................     rotate_left(&data1,1); 
1FC0:  MOV     #BFC,W1
1FC2:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7)) 
1FC4:  BTSS.B  BFE.7
1FC6:  BRA     1FCA
....................        bit_set(data1,0);     
1FC8:  BSET.B  BFC.0
....................     data1--; 
1FCA:  DEC     0BFC
....................     bit_clear(data2,7); 
1FCC:  BCLR.B  BFE.7
....................     if(bit_test(data1,0)) 
1FCE:  BTSS.B  BFC.0
1FD0:  BRA     1FD4
....................        bit_set(data2,7); 
1FD2:  BSET.B  BFE.7
....................     data1 = data1 >>1; 
1FD4:  LSR     BFC
....................     *(((unsigned int8 *)(&y))+3) = data1; 
1FD6:  MOV     #BF7,W5
1FD8:  MOV     BFC,W0
1FDA:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
1FDC:  MOV     #BF6,W5
1FDE:  MOV     BFE,W0
1FE0:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................    } while(res != y); 
1FE2:  MOV     BF8,W0
1FE4:  MOV     BFA,W1
1FE6:  MOV     BF4,W2
1FE8:  MOV     BF6,W3
1FEA:  CALL    1BF8
1FEE:  BRA     NZ,1F86
....................  
....................    return(res); 
1FF0:  MOV     BF8,W0
1FF2:  MOV     BFA,W1
1FF4:  MOV     [--W15],W5
1FF6:  RETURN  
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
1D8A:  MOV     W5,[W15++]
1D8C:  MOV     W6,[W15++]
1D8E:  CLR     C0A
1D90:  MOV     #3F80,W4
1D92:  MOV     W4,C0C
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
1D94:  CLR     C12
1D96:  MOV     #BF00,W4
1D98:  MOV     W4,C14
1D9A:  MOV     #AAA3,W4
1D9C:  MOV     W4,C16
1D9E:  MOV     #3D2A,W4
1DA0:  MOV     W4,C18
1DA2:  MOV     #9B4,W4
1DA4:  MOV     W4,C1A
1DA6:  MOV     #BAB6,W4
1DA8:  MOV     W4,C1C
1DAA:  MOV     #B6AA,W4
1DAC:  MOV     W4,C1E
1DAE:  MOV     #37CF,W4
1DB0:  MOV     W4,C20
1DB2:  MOV     #F6E8,W4
1DB4:  MOV     W4,C22
1DB6:  MOV     #B48B,W4
1DB8:  MOV     W4,C24
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
1DBA:  MOV     BFC,W0
1DBC:  MOV     BFE,W1
1DBE:  MOV     #0,W2
1DC0:  MOV     #0,W3
1DC2:  CALL    1BF8
1DC6:  BRA     NC,1DD2
1DC8:  MOV     #BFC,W0
1DCA:  MOV     #BFC,W1
1DCC:  REPEAT  #3
1DCE:  MOV     [W0++],[W1++]
1DD0:  BTG.B   BFF.7
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
1DD2:  MOV     BFC,W0
1DD4:  MOV     BFE,W1
1DD6:  MOV     #F983,W2
1DD8:  MOV     #3F22,W3
1DDA:  CALL    1C60
1DDE:  CALL    1D24
1DE2:  MOV.B   W0L,C00
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
1DE4:  MOV     BFC,W0
1DE6:  MOV     BFE,W1
1DE8:  MOV     #F983,W2
1DEA:  MOV     #3F22,W3
1DEC:  CALL    1C60
1DF0:  MOV     W0,W5
1DF2:  MOV     W1,W6
1DF4:  MOV.B   C00,W0L
1DF6:  CLR.B   1
1DF8:  CALL    1D50
1DFC:  BSET.B  43.0
1DFE:  MOV     W0,W2
1E00:  MOV     W1,W3
1E02:  MOV     W5,W0
1E04:  MOV     W6,W1
1E06:  CALL    1A4E
1E0A:  MOV     W0,C0E
1E0C:  MOV     W1,C10
....................    quad = quad % 4;                    // quadrant (0 to 3) 
1E0E:  MOV.B   C00,W0L
1E10:  AND.B   W0L,#3,W0L
1E12:  MOV.B   W0L,C00
....................  
....................    if (quad == 0 || quad == 2) 
1E14:  CP0.B   C00
1E16:  BRA     Z,1E1E
1E18:  MOV     C00,W4
1E1A:  CP.B    W4L,#2
1E1C:  BRA     NZ,1E30
....................       t = frac * PI_DIV_BY_TWO; 
1E1E:  MOV     C0E,W0
1E20:  MOV     C10,W1
1E22:  MOV     #FDB,W2
1E24:  MOV     #3FC9,W3
1E26:  CALL    1C60
1E2A:  MOV     W0,C06
1E2C:  MOV     W1,C08
1E2E:  BRA     1E7C
....................    else if (quad == 1) 
1E30:  MOV     C00,W4
1E32:  CP.B    W4L,#1
1E34:  BRA     NZ,1E5A
....................       t = (1-frac) * PI_DIV_BY_TWO; 
1E36:  BSET.B  43.0
1E38:  MOV     #0,W0
1E3A:  MOV     #3F80,W1
1E3C:  MOV     C0E,W2
1E3E:  MOV     C10,W3
1E40:  CALL    1A4E
1E44:  MOV     W0,W5
1E46:  MOV     W1,W6
1E48:  MOV     W5,W0
1E4A:  MOV     W6,W1
1E4C:  MOV     #FDB,W2
1E4E:  MOV     #3FC9,W3
1E50:  CALL    1C60
1E54:  MOV     W0,C06
1E56:  MOV     W1,C08
1E58:  BRA     1E7C
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
1E5A:  BSET.B  43.0
1E5C:  MOV     C0E,W0
1E5E:  MOV     C10,W1
1E60:  MOV     #0,W2
1E62:  MOV     #3F80,W3
1E64:  CALL    1A4E
1E68:  MOV     W0,W5
1E6A:  MOV     W1,W6
1E6C:  MOV     W5,W0
1E6E:  MOV     W6,W1
1E70:  MOV     #FDB,W2
1E72:  MOV     #3FC9,W3
1E74:  CALL    1C60
1E78:  MOV     W0,C06
1E7A:  MOV     W1,C08
....................  
....................    y = 1.0; 
1E7C:  CLR     C02
1E7E:  MOV     #3F80,W4
1E80:  MOV     W4,C04
....................    t = t * t; 
1E82:  MOV     C06,W0
1E84:  MOV     C08,W1
1E86:  MOV     C06,W2
1E88:  MOV     C08,W3
1E8A:  CALL    1C60
1E8E:  MOV     W0,C06
1E90:  MOV     W1,C08
....................    for (i = 0; i <= 4; i++) 
1E92:  CLR.B   C01
1E94:  MOV     C00,W4
1E96:  LSR     W4,#8,W4
1E98:  CP.B    W4L,#4
1E9A:  BRA     GTU,1EDE
....................    { 
....................       t2 = t2 * t; 
1E9C:  MOV     C0A,W0
1E9E:  MOV     C0C,W1
1EA0:  MOV     C06,W2
1EA2:  MOV     C08,W3
1EA4:  CALL    1C60
1EA8:  MOV     W0,C0A
1EAA:  MOV     W1,C0C
....................       y = y + p[i] * t2; 
1EAC:  MOV.B   C01,W0L
1EAE:  CLR.B   1
1EB0:  SL      W0,#2,W0
1EB2:  MOV     #C12,W4
1EB4:  ADD     W0,W4,W0
1EB6:  MOV     #A,W4
1EB8:  MOV     [W0++],[W4++]
1EBA:  MOV     [W0++],[W4++]
1EBC:  MOV     W5,W0
1EBE:  MOV     W6,W1
1EC0:  MOV     C0A,W2
1EC2:  MOV     C0C,W3
1EC4:  CALL    1C60
1EC8:  BCLR.B  43.0
1ECA:  MOV     W0,W2
1ECC:  MOV     W1,W3
1ECE:  MOV     C02,W0
1ED0:  MOV     C04,W1
1ED2:  CALL    1A4E
1ED6:  MOV     W0,C02
1ED8:  MOV     W1,C04
1EDA:  INC.B   0C01
1EDC:  BRA     1E94
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
1EDE:  MOV     C00,W4
1EE0:  CP.B    W4L,#2
1EE2:  BRA     Z,1EEA
1EE4:  MOV     C00,W4
1EE6:  CP.B    W4L,#1
1EE8:  BRA     NZ,1EF4
....................       y = -y;  // correct sign 
1EEA:  MOV     #C02,W0
1EEC:  MOV     #C02,W1
1EEE:  REPEAT  #3
1EF0:  MOV     [W0++],[W1++]
1EF2:  BTG.B   C05.7
....................  
....................    return (y); 
1EF4:  MOV     C02,W0
1EF6:  MOV     C04,W1
1EF8:  MOV     [--W15],W6
1EFA:  MOV     [--W15],W5
1EFC:  RETURN  
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
1EFE:  MOV     W5,[W15++]
1F00:  MOV     W6,[W15++]
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
1F02:  BSET.B  43.0
1F04:  MOV     BF4,W0
1F06:  MOV     BF6,W1
1F08:  MOV     #FDB,W2
1F0A:  MOV     #3FC9,W3
1F0C:  CALL    1A4E
1F10:  MOV     W0,W5
1F12:  MOV     W1,W6
1F14:  MOV     W5,BFC
1F16:  MOV     W6,BFE
1F18:  CALL    1D8A
1F1C:  MOV.D   W0,W0
1F1E:  MOV     [--W15],W6
1F20:  MOV     [--W15],W5
1F22:  RETURN  
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
*
1FF8:  MOV     W5,[W15++]
1FFA:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
1FFC:  BCLR.B  C02.0
....................    flag = 0; 
1FFE:  BCLR.B  C02.1
....................    y = x; 
2000:  PUSH    BFE
2002:  POP     C04
2004:  PUSH    C00
2006:  POP     C06
....................  
....................    if (x < 0) 
2008:  MOV     BFE,W0
200A:  MOV     C00,W1
200C:  MOV     #0,W2
200E:  MOV     #0,W3
2010:  CALL    1BF8
2014:  BRA     NC,2022
....................    { 
....................       s = 1; 
2016:  BSET.B  C02.0
....................       y = -y; 
2018:  MOV     #C04,W0
201A:  MOV     #C04,W1
201C:  REPEAT  #3
201E:  MOV     [W0++],[W1++]
2020:  BTG.B   C07.7
....................    } 
....................  
....................    if (y > 1.0) 
2022:  MOV     #0,W0
2024:  MOV     #3F80,W1
2026:  MOV     C04,W2
2028:  MOV     C06,W3
202A:  CALL    1BF8
202E:  BRA     NC,2042
....................    { 
....................       y = 1.0/y; 
2030:  MOV     #0,W0
2032:  MOV     #3F80,W1
2034:  MOV     C04,W2
2036:  MOV     C06,W3
2038:  CALL    1984
203C:  MOV     W0,C04
203E:  MOV     W1,C06
....................       flag = 1; 
2040:  BSET.B  C02.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
2042:  MOV     #890A,W0
2044:  MOV     #3E34,W1
2046:  MOV     C04,W2
2048:  MOV     C06,W3
204A:  CALL    1C60
204E:  MOV     W0,W5
2050:  MOV     W1,W6
2052:  MOV     W5,W0
2054:  MOV     W6,W1
2056:  MOV     C04,W2
2058:  MOV     C06,W3
205A:  CALL    1C60
205E:  MOV     W0,W5
2060:  MOV     W1,W6
2062:  BCLR.B  43.0
2064:  MOV     W5,W0
2066:  MOV     W6,W1
2068:  MOV     #797C,W2
206A:  MOV     #40B5,W3
206C:  CALL    1A4E
2070:  MOV     W0,C08
2072:  MOV     W1,C0A
....................    res = res*y*y + pat[2]; 
2074:  MOV     C08,W0
2076:  MOV     C0A,W1
2078:  MOV     C04,W2
207A:  MOV     C06,W3
207C:  CALL    1C60
2080:  MOV     W0,W5
2082:  MOV     W1,W6
2084:  MOV     W5,W0
2086:  MOV     W6,W1
2088:  MOV     C04,W2
208A:  MOV     C06,W3
208C:  CALL    1C60
2090:  MOV     W0,W5
2092:  MOV     W1,W6
2094:  BCLR.B  43.0
2096:  MOV     W5,W0
2098:  MOV     W6,W1
209A:  MOV     #23F,W2
209C:  MOV     #41B3,W3
209E:  CALL    1A4E
20A2:  MOV     W0,C08
20A4:  MOV     W1,C0A
....................    res = res*y*y + pat[3]; 
20A6:  MOV     C08,W0
20A8:  MOV     C0A,W1
20AA:  MOV     C04,W2
20AC:  MOV     C06,W3
20AE:  CALL    1C60
20B2:  MOV     W0,W5
20B4:  MOV     W1,W6
20B6:  MOV     W5,W0
20B8:  MOV     W6,W1
20BA:  MOV     C04,W2
20BC:  MOV     C06,W3
20BE:  CALL    1C60
20C2:  MOV     W0,W5
20C4:  MOV     W1,W6
20C6:  BCLR.B  43.0
20C8:  MOV     W5,W0
20CA:  MOV     W6,W1
20CC:  MOV     #8C33,W2
20CE:  MOV     #419E,W3
20D0:  CALL    1A4E
20D4:  MOV     W0,C08
20D6:  MOV     W1,C0A
....................  
....................    r = qat[0]*y*y + qat[1]; 
20D8:  MOV     #0,W0
20DA:  MOV     #3F80,W1
20DC:  MOV     C04,W2
20DE:  MOV     C06,W3
20E0:  CALL    1C60
20E4:  MOV     W0,W5
20E6:  MOV     W1,W6
20E8:  MOV     W5,W0
20EA:  MOV     W6,W1
20EC:  MOV     C04,W2
20EE:  MOV     C06,W3
20F0:  CALL    1C60
20F4:  MOV     W0,W5
20F6:  MOV     W1,W6
20F8:  BCLR.B  43.0
20FA:  MOV     W5,W0
20FC:  MOV     W6,W1
20FE:  MOV     #E41B,W2
2100:  MOV     #4135,W3
2102:  CALL    1A4E
2106:  MOV     W0,C0C
2108:  MOV     W1,C0E
....................    r = r*y*y + qat[2]; 
210A:  MOV     C0C,W0
210C:  MOV     C0E,W1
210E:  MOV     C04,W2
2110:  MOV     C06,W3
2112:  CALL    1C60
2116:  MOV     W0,W5
2118:  MOV     W1,W6
211A:  MOV     W5,W0
211C:  MOV     W6,W1
211E:  MOV     C04,W2
2120:  MOV     C06,W3
2122:  CALL    1C60
2126:  MOV     W0,W5
2128:  MOV     W1,W6
212A:  BCLR.B  43.0
212C:  MOV     W5,W0
212E:  MOV     W6,W1
2130:  MOV     #DBA4,W2
2132:  MOV     #41E7,W3
2134:  CALL    1A4E
2138:  MOV     W0,C0C
213A:  MOV     W1,C0E
....................    r = r*y*y + qat[3]; 
213C:  MOV     C0C,W0
213E:  MOV     C0E,W1
2140:  MOV     C04,W2
2142:  MOV     C06,W3
2144:  CALL    1C60
2148:  MOV     W0,W5
214A:  MOV     W1,W6
214C:  MOV     W5,W0
214E:  MOV     W6,W1
2150:  MOV     C04,W2
2152:  MOV     C06,W3
2154:  CALL    1C60
2158:  MOV     W0,W5
215A:  MOV     W1,W6
215C:  BCLR.B  43.0
215E:  MOV     W5,W0
2160:  MOV     W6,W1
2162:  MOV     #8C33,W2
2164:  MOV     #419E,W3
2166:  CALL    1A4E
216A:  MOV     W0,C0C
216C:  MOV     W1,C0E
....................  
....................    res = y*res/r; 
216E:  MOV     C04,W0
2170:  MOV     C06,W1
2172:  MOV     C08,W2
2174:  MOV     C0A,W3
2176:  CALL    1C60
217A:  MOV     W0,W5
217C:  MOV     W1,W6
217E:  MOV     W5,W0
2180:  MOV     W6,W1
2182:  MOV     C0C,W2
2184:  MOV     C0E,W3
2186:  CALL    1984
218A:  MOV     W0,C08
218C:  MOV     W1,C0A
....................  
....................  
....................    if (flag)                              // for |x| > 1 
218E:  BTSS.B  C02.1
2190:  BRA     21A4
....................       res = PI_DIV_BY_TWO - res; 
2192:  BSET.B  43.0
2194:  MOV     #FDB,W0
2196:  MOV     #3FC9,W1
2198:  MOV     C08,W2
219A:  MOV     C0A,W3
219C:  CALL    1A4E
21A0:  MOV     W0,C08
21A2:  MOV     W1,C0A
....................    if (s) 
21A4:  BTSS.B  C02.0
21A6:  BRA     21B2
....................       res = -res; 
21A8:  MOV     #C08,W0
21AA:  MOV     #C08,W1
21AC:  REPEAT  #3
21AE:  MOV     [W0++],[W1++]
21B0:  BTG.B   C0B.7
....................  
....................    return(res); 
21B2:  MOV     C08,W0
21B4:  MOV     C0A,W1
21B6:  MOV     [--W15],W6
21B8:  MOV     [--W15],W5
21BA:  RETURN  
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
21BC:  MOV     W5,[W15++]
21BE:  MOV     W6,[W15++]
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
21C0:  BCLR.B  BF8.0
....................    quad=0; //quadrant 
21C2:  CLR.B   BF9
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
21C4:  MOV     BF0,W0
21C6:  MOV     BF2,W1
21C8:  MOV     #0,W2
21CA:  MOV     #0,W3
21CC:  CALL    1BF8
21D0:  BRA     C,21D4
21D2:  BRA     NZ,21EC
21D4:  MOV     BF4,W0
21D6:  MOV     BF6,W1
21D8:  MOV     #0,W2
21DA:  MOV     #0,W3
21DC:  CALL    1BF8
21E0:  BRA     C,21E4
21E2:  BRA     NZ,21E8
21E4:  MOV.B   #3,W0L
21E6:  BRA     21EA
21E8:  MOV.B   #4,W0L
21EA:  BRA     2200
21EC:  MOV     BF4,W0
21EE:  MOV     BF6,W1
21F0:  MOV     #0,W2
21F2:  MOV     #0,W3
21F4:  CALL    1BF8
21F8:  BRA     NC,21FE
21FA:  MOV.B   #2,W0L
21FC:  BRA     2200
21FE:  MOV.B   #1,W0L
2200:  MOV.B   W0L,BF9
....................    if(y<0.0) 
2202:  MOV     BF0,W0
2204:  MOV     BF2,W1
2206:  MOV     #0,W2
2208:  MOV     #0,W3
220A:  CALL    1BF8
220E:  BRA     NC,221C
....................    { 
....................       sign=1; 
2210:  BSET.B  BF8.0
....................       y=-y; 
2212:  MOV     #BF0,W0
2214:  MOV     #BF0,W1
2216:  REPEAT  #3
2218:  MOV     [W0++],[W1++]
221A:  BTG.B   BF3.7
....................    } 
....................    if(x<0.0) 
221C:  MOV     BF4,W0
221E:  MOV     BF6,W1
2220:  MOV     #0,W2
2222:  MOV     #0,W3
2224:  CALL    1BF8
2228:  BRA     NC,2234
....................    { 
....................       x=-x; 
222A:  MOV     #BF4,W0
222C:  MOV     #BF4,W1
222E:  REPEAT  #3
2230:  MOV     [W0++],[W1++]
2232:  BTG.B   BF7.7
....................    } 
....................    if (x==0.0) 
2234:  MOV     BF4,W0
2236:  MOV     BF6,W1
2238:  MOV     #0,W2
223A:  MOV     #0,W3
223C:  CALL    1BF8
2240:  BRA     NZ,2266
....................    { 
....................       if(y==0.0) 
2242:  MOV     BF0,W0
2244:  MOV     BF2,W1
2246:  MOV     #0,W2
2248:  MOV     #0,W3
224A:  CALL    1BF8
224E:  BRA     NZ,2252
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
2250:  BRA     2264
....................       else 
....................       { 
....................          if(sign) 
2252:  BTSS.B  BF8.0
2254:  BRA     225E
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
2256:  MOV     #FDB,W0
2258:  MOV     #BFC9,W1
225A:  BRA     22F8
....................          } 
225C:  BRA     2264
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
225E:  MOV     #FDB,W0
2260:  MOV     #3FC9,W1
2262:  BRA     22F8
....................          } 
....................       } 
....................    } 
2264:  BRA     22F8
....................    else 
....................    { 
....................       z=y/x; 
2266:  MOV     BF0,W0
2268:  MOV     BF2,W1
226A:  MOV     BF4,W2
226C:  MOV     BF6,W3
226E:  CALL    1984
2272:  MOV     W0,BFA
2274:  MOV     W1,BFC
....................       switch(quad) 
2276:  MOV.B   BF9,W0L
2278:  CLR.B   1
227A:  XOR     #1,W0
227C:  BRA     Z,228C
227E:  XOR     #3,W0
2280:  BRA     Z,229E
2282:  XOR     #1,W0
2284:  BRA     Z,22BE
2286:  XOR     #7,W0
2288:  BRA     Z,22E2
228A:  BRA     22F8
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
228C:  PUSH    BFA
228E:  POP     BFE
2290:  PUSH    BFC
2292:  POP     C00
2294:  CALL    1FF8
2298:  MOV.D   W0,W0
229A:  BRA     22F8
....................             break; 
229C:  BRA     22F8
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
229E:  PUSH    BFA
22A0:  POP     BFE
22A2:  PUSH    BFC
22A4:  POP     C00
22A6:  CALL    1FF8
22AA:  BSET.B  43.0
22AC:  MOV     W0,W2
22AE:  MOV     W1,W3
22B0:  MOV     #FDB,W0
22B2:  MOV     #4049,W1
22B4:  CALL    1A4E
22B8:  MOV.D   W0,W0
22BA:  BRA     22F8
....................             break; 
22BC:  BRA     22F8
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
22BE:  PUSH    BFA
22C0:  POP     BFE
22C2:  PUSH    BFC
22C4:  POP     C00
22C6:  CALL    1FF8
22CA:  MOV     W0,W5
22CC:  MOV     W1,W6
22CE:  BSET.B  43.0
22D0:  MOV     W5,W0
22D2:  MOV     W6,W1
22D4:  MOV     #FDB,W2
22D6:  MOV     #4049,W3
22D8:  CALL    1A4E
22DC:  MOV.D   W0,W0
22DE:  BRA     22F8
....................             break; 
22E0:  BRA     22F8
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
22E2:  PUSH    BFA
22E4:  POP     BFE
22E6:  PUSH    BFC
22E8:  POP     C00
22EA:  CALL    1FF8
22EE:  MOV.D   W0,W0
22F0:  BTG     W1.F
22F2:  MOV.D   W0,W0
22F4:  BRA     22F8
....................             break; 
22F6:  BRA     22F8
....................          } 
....................       } 
....................    } 
22F8:  MOV     [--W15],W6
22FA:  MOV     [--W15],W5
22FC:  RETURN  
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
*
15A6:  MOV     W5,[W15++]
15A8:  MOV     W6,[W15++]
15AA:  MOV     W7,[W15++]
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
15AC:  CLR     BCC
....................    sign = 0; 
15AE:  CLR     BC8
....................    base = 10; 
15B0:  MOV     #A,W4
15B2:  MOV     W4,BCA
....................    result = 0; 
15B4:  CLR     BC4
15B6:  CLR     BC6
....................  
....................    if (!s) 
15B8:  CP0     BC0
15BA:  BRA     NZ,15C2
....................       return 0; 
15BC:  MOV     #0,W0
15BE:  MOV     #0,W1
15C0:  BRA     1788
....................    c = s[index++]; 
15C2:  MOV     BCC,W0
15C4:  INC     0BCC
15C6:  MOV     W0,W5
15C8:  MOV     W5,W0
15CA:  ADD     BC0,W0
15CC:  MOV     BC2,W4
15CE:  MOV.B   [W0+#0],W4L
15D0:  MOV     W4,BC2
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
15D2:  MOV     BC2,W4
15D4:  XOR.B   #2D,W4L
15D6:  BRA     NZ,15EE
....................    { 
....................       sign = 1;         // Set the sign to negative 
15D8:  MOV     #1,W4
15DA:  MOV     W4,BC8
....................       c = s[index++]; 
15DC:  MOV     BCC,W0
15DE:  INC     0BCC
15E0:  MOV     W0,W5
15E2:  MOV     W5,W0
15E4:  ADD     BC0,W0
15E6:  MOV     BC2,W4
15E8:  MOV.B   [W0+#0],W4L
15EA:  MOV     W4,BC2
....................    } 
15EC:  BRA     1604
....................    else if (c == '+') 
15EE:  MOV     BC2,W4
15F0:  XOR.B   #2B,W4L
15F2:  BRA     NZ,1604
....................    { 
....................       c = s[index++]; 
15F4:  MOV     BCC,W0
15F6:  INC     0BCC
15F8:  MOV     W0,W5
15FA:  MOV     W5,W0
15FC:  ADD     BC0,W0
15FE:  MOV     BC2,W4
1600:  MOV.B   [W0+#0],W4L
1602:  MOV     W4,BC2
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1604:  MOV     BC2,W4
1606:  MOV     #30,W3
1608:  CP.B    W3L,W4L
160A:  BRA     GT,1768
160C:  MOV     BC2,W4
160E:  MOV     #39,W3
1610:  CP.B    W3L,W4L
1612:  BRA     LT,1768
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1614:  MOV     BC2,W4
1616:  XOR.B   #30,W4L
1618:  BRA     NZ,1644
161A:  MOV     BCC,W0
161C:  ADD     BC0,W0
161E:  MOV.B   [W0],W4L
1620:  XOR.B   #78,W4L
1622:  BRA     Z,162E
1624:  MOV     BCC,W0
1626:  ADD     BC0,W0
1628:  MOV.B   [W0],W4L
162A:  XOR.B   #58,W4L
162C:  BRA     NZ,1644
....................       { 
....................          base = 16; 
162E:  MOV     #10,W4
1630:  MOV     W4,BCA
....................          index++; 
1632:  INC     0BCC
....................          c = s[index++]; 
1634:  MOV     BCC,W0
1636:  INC     0BCC
1638:  MOV     W0,W5
163A:  MOV     W5,W0
163C:  ADD     BC0,W0
163E:  MOV     BC2,W4
1640:  MOV.B   [W0+#0],W4L
1642:  MOV     W4,BC2
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1644:  MOV     BCA,W4
1646:  CP      W4,#A
1648:  BRA     NZ,1696
....................       { 
....................          while (c >= '0' && c <= '9') 
164A:  MOV     BC2,W4
164C:  MOV     #30,W3
164E:  CP.B    W3L,W4L
1650:  BRA     GT,1694
1652:  MOV     BC2,W4
1654:  MOV     #39,W3
1656:  CP.B    W3L,W4L
1658:  BRA     LT,1694
....................          { 
....................             result = 10*result + (c - '0'); 
165A:  MOV     #A,W0
165C:  MOV     #0,W1
165E:  MOV     BC4,W2
1660:  MOV     BC6,W3
1662:  CALL    1564
1666:  MOV     W0,W5
1668:  MOV     W1,W6
166A:  MOV     BC2,W4
166C:  SUB.B   #30,W4L
166E:  MOV.B   W4L,W0L
1670:  MOV.B   W0L,0
1672:  SE      W0,W0
1674:  CLR     W1
1676:  BTSC    W0.F
1678:  SETM    W1
167A:  ADD     W0,W5,W0
167C:  MOV     W0,BC4
167E:  ADDC    W1,W6,W0
1680:  MOV     W0,BC6
....................             c = s[index++]; 
1682:  MOV     BCC,W0
1684:  INC     0BCC
1686:  MOV     W0,W5
1688:  MOV     W5,W0
168A:  ADD     BC0,W0
168C:  MOV     BC2,W4
168E:  MOV.B   [W0+#0],W4L
1690:  MOV     W4,BC2
1692:  BRA     164A
....................          } 
....................       } 
1694:  BRA     1768
....................       else if (base == 16)    // The number is a hexa number 
1696:  MOV     BCA,W4
1698:  CP      W4,#10
169A:  BRA     NZ,1768
....................       { 
....................          c = toupper(c); 
169C:  MOV     BC2,W4
169E:  MOV     #61,W3
16A0:  CP.B    W3L,W4L
16A2:  BRA     GTU,16B2
16A4:  MOV     BC2,W4
16A6:  MOV     #7A,W3
16A8:  CP.B    W3L,W4L
16AA:  BRA     NC,16B2
16AC:  MOV.B   BC2,W0L
16AE:  AND.B   #DF,W0L
16B0:  BRA     16B4
16B2:  MOV.B   BC2,W0L
16B4:  MOV.B   W0L,BC2
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
16B6:  MOV     BC2,W4
16B8:  MOV     #30,W3
16BA:  CP.B    W3L,W4L
16BC:  BRA     GT,16C8
16BE:  MOV     BC2,W4
16C0:  MOV     #39,W3
16C2:  CP.B    W3L,W4L
16C4:  BRA     LT,16C8
16C6:  BRA     16D8
16C8:  MOV     BC2,W4
16CA:  MOV     #41,W3
16CC:  CP.B    W3L,W4L
16CE:  BRA     GT,1768
16D0:  MOV     BC2,W4
16D2:  MOV     #46,W3
16D4:  CP.B    W3L,W4L
16D6:  BRA     LT,1768
....................          { 
....................             if (c >= '0' && c <= '9') 
16D8:  MOV     BC2,W4
16DA:  MOV     #30,W3
16DC:  CP.B    W3L,W4L
16DE:  BRA     GT,1714
16E0:  MOV     BC2,W4
16E2:  MOV     #39,W3
16E4:  CP.B    W3L,W4L
16E6:  BRA     LT,1714
....................                result = (result << 4) + (c - '0'); 
16E8:  MOV     #4,W4
16EA:  MOV     BC4,W5
16EC:  MOV     BC6,W6
16EE:  INC     W4,W4
16F0:  DEC     W4,W4
16F2:  BRA     Z,16FA
16F4:  SL      W5,W5
16F6:  RLC     W6,W6
16F8:  BRA     16F0
16FA:  MOV     BC2,W4
16FC:  SUB.B   #30,W4L
16FE:  MOV.B   W4L,W0L
1700:  MOV.B   W0L,0
1702:  SE      W0,W0
1704:  CLR     W1
1706:  BTSC    W0.F
1708:  SETM    W1
170A:  ADD     W0,W5,W0
170C:  MOV     W0,BC4
170E:  ADDC    W1,W6,W0
1710:  MOV     W0,BC6
1712:  BRA     173C
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
1714:  MOV     #4,W4
1716:  MOV     BC4,W5
1718:  MOV     BC6,W6
171A:  INC     W4,W4
171C:  DEC     W4,W4
171E:  BRA     Z,1726
1720:  SL      W5,W5
1722:  RLC     W6,W6
1724:  BRA     171C
1726:  MOV     BC2,W4
1728:  SUB.B   #41,W4L
172A:  MOV.B   W4L,W0L
172C:  MOV.B   W0L,0
172E:  ZE      W0,W0
1730:  ADD     W0,#A,W0
1732:  ADD     W0,W5,W0
1734:  MOV     W0,BC4
1736:  MOV     #0,W4
1738:  ADDC    W4,W6,W0
173A:  MOV     W0,BC6
....................  
....................             c = s[index++];c = toupper(c); 
173C:  MOV     BCC,W0
173E:  INC     0BCC
1740:  MOV     W0,W5
1742:  MOV     W5,W0
1744:  ADD     BC0,W0
1746:  MOV     BC2,W4
1748:  MOV.B   [W0+#0],W4L
174A:  MOV     W4,BC2
174C:  MOV     BC2,W4
174E:  MOV     #61,W3
1750:  CP.B    W3L,W4L
1752:  BRA     GTU,1762
1754:  MOV     BC2,W4
1756:  MOV     #7A,W3
1758:  CP.B    W3L,W4L
175A:  BRA     NC,1762
175C:  MOV.B   BC2,W0L
175E:  AND.B   #DF,W0L
1760:  BRA     1764
1762:  MOV.B   BC2,W0L
1764:  MOV.B   W0L,BC2
1766:  BRA     16B6
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1768:  MOV     BCA,W4
176A:  CP      W4,#A
176C:  BRA     NZ,1784
176E:  MOV     BC8,W4
1770:  CP      W4,#1
1772:  BRA     NZ,1784
....................       result = -result; 
1774:  MOV     #0,W4
1776:  MOV     BC4,W3
1778:  SUB     W4,W3,W0
177A:  MOV     W0,BC4
177C:  MOV     #0,W4
177E:  MOV     BC6,W3
1780:  SUBB    W4,W3,W0
1782:  MOV     W0,BC6
....................  
....................    return(result); 
1784:  MOV     BC4,W0
1786:  MOV     BC6,W1
1788:  MOV     [--W15],W7
178A:  MOV     [--W15],W6
178C:  MOV     [--W15],W5
178E:  RETURN  
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
*
1118:  MOV     W5,[W15++]
111A:  MOV     W6,[W15++]
111C:  MOV     W7,[W15++]
111E:  MOV     W8,[W15++]
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
1120:  CLR.B   BC4
....................    sign = 0; 
1122:  CLR.B   BC2
....................    base = 10; 
1124:  MOV.B   #A,W0L
1126:  MOV.B   W0L,BC3
....................    result = 0; 
1128:  CLR     BC6
112A:  CLR     BC8
112C:  CLR     BCA
....................  
....................    if (!s) 
112E:  CP0     BC0
1130:  BRA     NZ,113A
....................       return 0; 
1132:  MOV     #0,W0
1134:  MOV     #0,W1
1136:  MOV     #0,W2
1138:  BRA     1392
....................    c = s[index++]; 
113A:  MOV.B   BC4,W0L
113C:  INC.B   0BC4
113E:  SE      W0,W5
1140:  MOV     W5,W0
1142:  ADD     BC0,W0
1144:  MOV     W0,[W15++]
1146:  MOV.B   [W0],W0L
1148:  MOV.B   W0L,BC5
114A:  MOV     [--W15],W0
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
114C:  MOV     BC4,W4
114E:  LSR     W4,#8,W4
1150:  XOR.B   #2D,W4L
1152:  BRA     NZ,116C
....................    { 
....................       sign = 1;         // Set the sign to negative 
1154:  MOV.B   #1,W0L
1156:  MOV.B   W0L,BC2
....................       c = s[index++]; 
1158:  MOV.B   BC4,W0L
115A:  INC.B   0BC4
115C:  SE      W0,W5
115E:  MOV     W5,W0
1160:  ADD     BC0,W0
1162:  MOV     W0,[W15++]
1164:  MOV.B   [W0],W0L
1166:  MOV.B   W0L,BC5
1168:  MOV     [--W15],W0
....................    } 
116A:  BRA     1186
....................    else if (c == '+') 
116C:  MOV     BC4,W4
116E:  LSR     W4,#8,W4
1170:  XOR.B   #2B,W4L
1172:  BRA     NZ,1186
....................    { 
....................       c = s[index++]; 
1174:  MOV.B   BC4,W0L
1176:  INC.B   0BC4
1178:  SE      W0,W5
117A:  MOV     W5,W0
117C:  ADD     BC0,W0
117E:  MOV     W0,[W15++]
1180:  MOV.B   [W0],W0L
1182:  MOV.B   W0L,BC5
1184:  MOV     [--W15],W0
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1186:  MOV     BC4,W4
1188:  LSR     W4,#8,W4
118A:  MOV     #30,W3
118C:  CP.B    W3L,W4L
118E:  BRA     GT,1364
1190:  MOV     BC4,W4
1192:  LSR     W4,#8,W4
1194:  MOV     #39,W3
1196:  CP.B    W3L,W4L
1198:  BRA     LT,1364
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
119A:  MOV     BC4,W4
119C:  LSR     W4,#8,W4
119E:  XOR.B   #30,W4L
11A0:  BRA     NZ,11D6
11A2:  MOV.B   BC4,W0L
11A4:  SE      W0,W0
11A6:  MOV     BC0,W4
11A8:  ADD     W0,W4,W0
11AA:  MOV.B   [W0],W4L
11AC:  XOR.B   #78,W4L
11AE:  BRA     Z,11BE
11B0:  MOV.B   BC4,W0L
11B2:  SE      W0,W0
11B4:  MOV     BC0,W4
11B6:  ADD     W0,W4,W0
11B8:  MOV.B   [W0],W4L
11BA:  XOR.B   #58,W4L
11BC:  BRA     NZ,11D6
....................       { 
....................          base = 16; 
11BE:  MOV.B   #10,W0L
11C0:  MOV.B   W0L,BC3
....................          index++; 
11C2:  INC.B   0BC4
....................          c = s[index++]; 
11C4:  MOV.B   BC4,W0L
11C6:  INC.B   0BC4
11C8:  SE      W0,W5
11CA:  MOV     W5,W0
11CC:  ADD     BC0,W0
11CE:  MOV     W0,[W15++]
11D0:  MOV.B   [W0],W0L
11D2:  MOV.B   W0L,BC5
11D4:  MOV     [--W15],W0
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
11D6:  MOV.B   BC3,W0L
11D8:  SE      W0,W0
11DA:  CP      W0,#A
11DC:  BRA     NZ,1262
....................       { 
....................          while (c >= '0' && c <= '9') { 
11DE:  MOV     BC4,W4
11E0:  LSR     W4,#8,W4
11E2:  MOV     #30,W3
11E4:  CP.B    W3L,W4L
11E6:  BRA     GT,1260
11E8:  MOV     BC4,W4
11EA:  LSR     W4,#8,W4
11EC:  MOV     #39,W3
11EE:  CP.B    W3L,W4L
11F0:  BRA     LT,1260
....................             result = (result << 1) + (result << 3);  // result *= 10; 
11F2:  MOV     #1,W4
11F4:  MOV     BC6,W5
11F6:  MOV     BC8,W6
11F8:  MOV     BCA,W7
11FA:  INC     W4,W4
11FC:  DEC     W4,W4
11FE:  BRA     Z,1208
1200:  SL      W5,W5
1202:  RLC     W6,W6
1204:  RLC     W7,W7
1206:  BRA     11FC
1208:  MOV     #3,W4
120A:  MOV     BC6,W0
120C:  MOV     BC8,W1
120E:  MOV     BCA,W2
1210:  INC     W4,W4
1212:  DEC     W4,W4
1214:  BRA     Z,121E
1216:  SL      W0,W0
1218:  RLC     W1,W1
121A:  RLC     W2,W2
121C:  BRA     1212
121E:  ADD     W0,W5,W0
1220:  MOV     W0,BC6
1222:  ADDC    W1,W6,W0
1224:  MOV     W0,BC8
1226:  ADDC    W2,W7,W0
1228:  MOV     W0,BCA
....................             result += (c - '0'); 
122A:  MOV     BC4,W4
122C:  LSR     W4,#8,W4
122E:  SUB.B   #30,W4L
1230:  MOV.B   W4L,W0L
1232:  MOV.B   W0L,0
1234:  SE      W0,W0
1236:  CLR     W2
1238:  BTSC    W0.F
123A:  SETM    W2
123C:  MOV     W2,W1
123E:  ADD     BC6
1240:  MOV     BC8,W4
1242:  ADDC    W1,W4,W0
1244:  MOV     W0,BC8
1246:  MOV     BCA,W4
1248:  ADDC    W2,W4,W0
124A:  MOV     W0,BCA
....................             c = s[index++]; 
124C:  MOV.B   BC4,W0L
124E:  INC.B   0BC4
1250:  SE      W0,W5
1252:  MOV     W5,W0
1254:  ADD     BC0,W0
1256:  MOV     W0,[W15++]
1258:  MOV.B   [W0],W0L
125A:  MOV.B   W0L,BC5
125C:  MOV     [--W15],W0
125E:  BRA     11DE
....................          } 
....................       } 
1260:  BRA     1364
....................       else if (base == 16)    // The number is a hexa number 
1262:  MOV.B   BC3,W0L
1264:  SE      W0,W0
1266:  CP      W0,#10
1268:  BRA     NZ,1364
....................       { 
....................          c = toupper(c); 
126A:  MOV     BC4,W4
126C:  LSR     W4,#8,W4
126E:  MOV     #61,W3
1270:  CP.B    W3L,W4L
1272:  BRA     GTU,1284
1274:  MOV     BC4,W4
1276:  LSR     W4,#8,W4
1278:  MOV     #7A,W3
127A:  CP.B    W3L,W4L
127C:  BRA     NC,1284
127E:  MOV.B   BC5,W0L
1280:  AND.B   #DF,W0L
1282:  BRA     1286
1284:  MOV.B   BC5,W0L
1286:  MOV.B   W0L,BC5
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
1288:  MOV     BC4,W4
128A:  LSR     W4,#8,W4
128C:  MOV     #30,W3
128E:  CP.B    W3L,W4L
1290:  BRA     GT,129E
1292:  MOV     BC4,W4
1294:  LSR     W4,#8,W4
1296:  MOV     #39,W3
1298:  CP.B    W3L,W4L
129A:  BRA     LT,129E
129C:  BRA     12B2
129E:  MOV     BC4,W4
12A0:  LSR     W4,#8,W4
12A2:  MOV     #41,W3
12A4:  CP.B    W3L,W4L
12A6:  BRA     GT,1364
12A8:  MOV     BC4,W4
12AA:  LSR     W4,#8,W4
12AC:  MOV     #46,W3
12AE:  CP.B    W3L,W4L
12B0:  BRA     LT,1364
....................          { 
....................             if (c >= '0' && c <= '9') 
12B2:  MOV     BC4,W4
12B4:  LSR     W4,#8,W4
12B6:  MOV     #30,W3
12B8:  CP.B    W3L,W4L
12BA:  BRA     GT,12FE
12BC:  MOV     BC4,W4
12BE:  LSR     W4,#8,W4
12C0:  MOV     #39,W3
12C2:  CP.B    W3L,W4L
12C4:  BRA     LT,12FE
....................                result = (result << 4) + (c - '0'); 
12C6:  MOV     #4,W4
12C8:  MOV     BC6,W5
12CA:  MOV     BC8,W6
12CC:  MOV     BCA,W7
12CE:  INC     W4,W4
12D0:  DEC     W4,W4
12D2:  BRA     Z,12DC
12D4:  SL      W5,W5
12D6:  RLC     W6,W6
12D8:  RLC     W7,W7
12DA:  BRA     12D0
12DC:  MOV     BC4,W4
12DE:  LSR     W4,#8,W4
12E0:  SUB.B   #30,W4L
12E2:  MOV.B   W4L,W0L
12E4:  MOV.B   W0L,0
12E6:  SE      W0,W0
12E8:  CLR     W2
12EA:  BTSC    W0.F
12EC:  SETM    W2
12EE:  MOV     W2,W1
12F0:  ADD     W0,W5,W0
12F2:  MOV     W0,BC6
12F4:  ADDC    W1,W6,W0
12F6:  MOV     W0,BC8
12F8:  ADDC    W2,W7,W0
12FA:  MOV     W0,BCA
12FC:  BRA     1332
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
12FE:  MOV     #4,W4
1300:  MOV     BC6,W5
1302:  MOV     BC8,W6
1304:  MOV     BCA,W7
1306:  INC     W4,W4
1308:  DEC     W4,W4
130A:  BRA     Z,1314
130C:  SL      W5,W5
130E:  RLC     W6,W6
1310:  RLC     W7,W7
1312:  BRA     1308
1314:  MOV     BC4,W4
1316:  LSR     W4,#8,W4
1318:  SUB.B   #41,W4L
131A:  MOV.B   W4L,W0L
131C:  MOV.B   W0L,0
131E:  ZE      W0,W0
1320:  ADD     W0,#A,W0
1322:  ADD     W0,W5,W0
1324:  MOV     W0,BC6
1326:  MOV     #0,W4
1328:  ADDC    W4,W6,W0
132A:  MOV     W0,BC8
132C:  MOV     #0,W4
132E:  ADDC    W4,W7,W0
1330:  MOV     W0,BCA
....................  
....................             c = s[index++];c = toupper(c); 
1332:  MOV.B   BC4,W0L
1334:  INC.B   0BC4
1336:  SE      W0,W5
1338:  MOV     W5,W0
133A:  ADD     BC0,W0
133C:  MOV     W0,[W15++]
133E:  MOV.B   [W0],W0L
1340:  MOV.B   W0L,BC5
1342:  MOV     [--W15],W0
1344:  MOV     BC4,W4
1346:  LSR     W4,#8,W4
1348:  MOV     #61,W3
134A:  CP.B    W3L,W4L
134C:  BRA     GTU,135E
134E:  MOV     BC4,W4
1350:  LSR     W4,#8,W4
1352:  MOV     #7A,W3
1354:  CP.B    W3L,W4L
1356:  BRA     NC,135E
1358:  MOV.B   BC5,W0L
135A:  AND.B   #DF,W0L
135C:  BRA     1360
135E:  MOV.B   BC5,W0L
1360:  MOV.B   W0L,BC5
1362:  BRA     1288
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1364:  MOV.B   BC3,W0L
1366:  SE      W0,W0
1368:  CP      W0,#A
136A:  BRA     NZ,138C
136C:  MOV.B   BC2,W0L
136E:  SE      W0,W0
1370:  CP      W0,#1
1372:  BRA     NZ,138C
....................       result = -result; 
1374:  MOV     #0,W4
1376:  MOV     BC6,W3
1378:  SUB     W4,W3,W0
137A:  MOV     W0,BC6
137C:  MOV     #0,W4
137E:  MOV     BC8,W3
1380:  SUBB    W4,W3,W0
1382:  MOV     W0,BC8
1384:  MOV     #0,W4
1386:  MOV     BCA,W3
1388:  SUBB    W4,W3,W0
138A:  MOV     W0,BCA
....................  
....................    return(result); 
138C:  MOV     BC6,W0
138E:  MOV     BC8,W1
1390:  MOV     BCA,W2
1392:  MOV     [--W15],W8
1394:  MOV     [--W15],W7
1396:  MOV     [--W15],W6
1398:  MOV     [--W15],W5
139A:  RETURN  
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
*
0F74:  MOV     W5,[W15++]
0F76:  MOV     W6,[W15++]
0F78:  MOV     W7,[W15++]
0F7A:  CLR     BC8
0F7C:  CLR     BCA
0F7E:  MOV     #3F80,W4
0F80:  MOV     W4,BCC
0F82:  CLR     BCE
0F84:  CLR     BD0
0F86:  CLR     BD2
0F88:  BSET.B  BC4.0
0F8A:  BCLR.B  BC4.1
0F8C:  BCLR.B  BC4.2
0F8E:  CLR.B   BC6
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0F90:  CP0     BC0
0F92:  BRA     NZ,F9C
....................       return 0; 
0F94:  MOV     #0,W0
0F96:  MOV     #0,W1
0F98:  MOV     #0,W2
0F9A:  BRA     1110
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0F9C:  MOV.B   BC6,W0L
0F9E:  INC.B   0BC6
0FA0:  ZE      W0,W0
0FA2:  MOV     BC0,W4
0FA4:  ADD     W0,W4,W0
0FA6:  MOV     W0,[W15++]
0FA8:  MOV.B   [W0],W0L
0FAA:  MOV.B   W0L,BC5
0FAC:  MOV     [--W15],W0
0FAE:  MOV.B   BC5,W0L
0FB0:  SE      W0,W0
0FB2:  CP0     W0
0FB4:  BRA     Z,10D4
....................    { 
....................       if (skip && !isspace(c)) 
0FB6:  BTSS.B  BC4.0
0FB8:  BRA     FDE
0FBA:  MOV     BC4,W4
0FBC:  LSR     W4,#8,W4
0FBE:  XOR.B   #20,W4L
0FC0:  BRA     Z,FDE
....................       { 
....................          skip = 0; 
0FC2:  BCLR.B  BC4.0
....................          if (c == '+') 
0FC4:  MOV     BC4,W4
0FC6:  LSR     W4,#8,W4
0FC8:  XOR.B   #2B,W4L
0FCA:  BRA     NZ,FD2
....................          { 
....................             sign = 0; 
0FCC:  BCLR.B  BC4.1
....................             continue; 
0FCE:  BRA     10C0
....................          }             
0FD0:  BRA     FDE
....................          else if (c == '-') 
0FD2:  MOV     BC4,W4
0FD4:  LSR     W4,#8,W4
0FD6:  XOR.B   #2D,W4L
0FD8:  BRA     NZ,FDE
....................          { 
....................             sign = 1; 
0FDA:  BSET.B  BC4.1
....................             continue; 
0FDC:  BRA     10C0
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0FDE:  BTSC.B  BC4.0
0FE0:  BRA     FF2
0FE2:  MOV     BC4,W4
0FE4:  LSR     W4,#8,W4
0FE6:  XOR.B   #2E,W4L
0FE8:  BRA     NZ,FF2
0FEA:  BTSC.B  BC4.2
0FEC:  BRA     FF2
....................          point = 1; 
0FEE:  BSET.B  BC4.2
0FF0:  BRA     10C0
....................       else if (!skip && isdigit(c)) 
0FF2:  BTSC.B  BC4.0
0FF4:  BRA     10BA
0FF6:  MOV     BC4,W4
0FF8:  LSR     W4,#8,W4
0FFA:  MOV     #30,W3
0FFC:  CP.B    W3L,W4L
0FFE:  BRA     GTU,10BA
1000:  MOV     BC4,W4
1002:  LSR     W4,#8,W4
1004:  MOV     #39,W3
1006:  CP.B    W3L,W4L
1008:  BRA     NC,10BA
....................       { 
....................          c -= '0'; 
100A:  MOV     BC4,W4
100C:  LSR     W4,#8,W4
100E:  SUB.B   #30,W4L
1010:  MOV.B   W4L,W0L
1012:  MOV.B   W0L,BC5
....................          if (point) 
1014:  BTSS.B  BC4.2
1016:  BRA     1074
....................          { 
....................             pow10 = pow10 * 10.0; 
1018:  MOV     BC8,W0
101A:  MOV     BCA,W1
101C:  MOV     BCC,W2
101E:  MOV     #0,W3
1020:  MOV     #0,W4
1022:  MOV     #4120,W5
1024:  CALL    B8A
1028:  MOV     W0,BC8
102A:  MOV     W1,BCA
102C:  MOV     W2,BCC
....................             result += (float48)c / pow10;    
102E:  MOV.B   BC5,W0L
1030:  SE      W0,W0
1032:  CLR     W3
1034:  BTSC    W0.F
1036:  SETM    W3
1038:  MOV     W3,W1
103A:  MOV     W3,W2
103C:  CALL    C58
1040:  MOV     W0,W5
1042:  MOV     W1,W6
1044:  MOV     W2,W7
1046:  MOV     W5,[W15++]
1048:  MOV     W5,W0
104A:  MOV     W6,W1
104C:  MOV     W7,W2
104E:  MOV     BC8,W3
1050:  MOV     BCA,W4
1052:  MOV     BCC,W5
1054:  CALL    CC2
1058:  MOV     [--W15],W5
105A:  BCLR.B  43.0
105C:  MOV     W0,W3
105E:  MOV     W1,W4
1060:  MOV     W2,W5
1062:  MOV     BCE,W0
1064:  MOV     BD0,W1
1066:  MOV     BD2,W2
1068:  CALL    D98
106C:  MOV     W0,BCE
106E:  MOV     W1,BD0
1070:  MOV     W2,BD2
....................          } 
1072:  BRA     10B8
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
1074:  MOV     #0,W0
1076:  MOV     #0,W1
1078:  MOV     #4120,W2
107A:  MOV     BCE,W3
107C:  MOV     BD0,W4
107E:  MOV     BD2,W5
1080:  CALL    B8A
1084:  MOV     W0,W5
1086:  MOV     W1,W6
1088:  MOV     W2,W7
108A:  MOV.B   BC5,W0L
108C:  SE      W0,W0
108E:  CLR     W3
1090:  BTSC    W0.F
1092:  SETM    W3
1094:  MOV     W3,W1
1096:  MOV     W3,W2
1098:  CALL    C58
109C:  BCLR.B  43.0
109E:  MOV     W5,[W15++]
10A0:  MOV     W0,W3
10A2:  MOV     W1,W4
10A4:  MOV     W5,W0
10A6:  MOV     W6,W1
10A8:  MOV     W2,W5
10AA:  MOV     W7,W2
10AC:  CALL    D98
10B0:  MOV     [--W15],W5
10B2:  MOV     W0,BCE
10B4:  MOV     W1,BD0
10B6:  MOV     W2,BD2
....................          } 
....................       } 
10B8:  BRA     10C0
....................       else if (!skip) 
10BA:  BTSC.B  BC4.0
10BC:  BRA     10C0
....................          break; 
10BE:  BRA     10D4
10C0:  MOV.B   BC6,W0L
10C2:  INC.B   0BC6
10C4:  ZE      W0,W0
10C6:  MOV     BC0,W4
10C8:  ADD     W0,W4,W0
10CA:  MOV     W0,[W15++]
10CC:  MOV.B   [W0],W0L
10CE:  MOV.B   W0L,BC5
10D0:  MOV     [--W15],W0
10D2:  BRA     FAE
....................    } 
....................  
....................    if (sign) 
10D4:  BTSS.B  BC4.1
10D6:  BRA     10EE
....................       result = -1*result; 
10D8:  MOV     #0,W0
10DA:  MOV     #0,W1
10DC:  MOV     #BF80,W2
10DE:  MOV     BCE,W3
10E0:  MOV     BD0,W4
10E2:  MOV     BD2,W5
10E4:  CALL    B8A
10E8:  MOV     W0,BCE
10EA:  MOV     W1,BD0
10EC:  MOV     W2,BD2
....................        
....................    if(endptr) 
10EE:  CP0     BC2
10F0:  BRA     Z,110A
....................    { 
....................       if (ptr) { 
10F2:  CP0.B   BC6
10F4:  BRA     Z,1104
....................          ptr--; 
10F6:  DEC.B   0BC6
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
10F8:  MOV     BC2,W5
10FA:  MOV     BC6,W4
10FC:  CLR.B   9
10FE:  MOV     BC0,W3
1100:  ADD     W3,W4,[W5]
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
1102:  BRA     110A
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
1104:  MOV     BC2,W5
1106:  MOV     BC0,W4
1108:  MOV     W4,[W5+#0]
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
110A:  MOV     BCE,W0
110C:  MOV     BD0,W1
110E:  MOV     BD2,W2
1110:  MOV     [--W15],W7
1112:  MOV     [--W15],W6
1114:  MOV     [--W15],W5
1116:  RETURN  
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <time.h> 
....................  
.................... #pin_select U1TX=PIN_b14 
.................... #pin_select U1RX=PIN_b15 
.................... #pin_select U2RX=PIN_b5 
.................... #pin_select U2TX=PIN_b4 
....................  
.................... //#use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,stream=GPS,errors) 
.................... //#use rs232(baud=19200,xmit=PIN_B14,rcv=PIN_B15,force_sw,stream=BUG,errors) 
.................... //#use rs232(baud=19200,UART1,stream=GPS,errors) 
.................... #use rs232(baud=57600,UART1,stream=BUG,errors) 
.................... #use rs232(baud=57600,UART2,stream=GSM,errors) 
*
05DE:  BTSS.B  232.0
05E0:  BRA     5DE
05E2:  PUSH    232
05E4:  POP     914
05E6:  MOV     236,W0
05E8:  BCLR.B  232.1
05EA:  RETURN  
.................... //#use rs232(baud=9600,xmit=PIN_C2,rcv=PIN_C3,force_sw,stream=GSM,errors) 
....................  
.................... #define GET_GSM_STATUS        fprintf(GSM,"AT+CGREG?%c",enter); 
.................... #define GPS_ON                fprintf(GSM,"AT+CGNSPWR=1%c",enter); 
.................... #define CANCEL_ECHO           fprintf(GSM,"ATE0%c",enter); 
.................... #define START_CIP             fprintf(GSM,"AT+CIPSTART=%cTCP%c,%cwww.gpstraces.com%c,%c80%c%c",set,set,set,set,set,set,enter); 
.................... #define GET_CIP_STATUS        fprintf(GSM,"AT+CIPSTATUS%c",enter);               //119.18.57.60 
.................... #define GET_GPS               fprintf(GSM,"AT+CGNSINF%c",enter); 
.................... #define GET_GPS_STATUS        fprintf(GSM,"AT+CGPSSTATUS?%c",enter); 
.................... #define GPS_REBOOT            fprintf(GSM,"AT+CGNSRST=0%c",enter); 
....................  
.................... //#define ACK_OK "OK"  
.................... //#define ACK_ERROR "ERROR" 
....................  
.................... boolean exception(unsigned char bb,INT8 cc); 
.................... int init_gsm(int dat); 
.................... int init_gsm_1(int dat); 
....................  
.................... int8 cip_start(); 
.................... void cip_send(); 
.................... void cip_send1(); 
.................... void cip_send2(); 
.................... void cip_send3(); 
.................... void cip_close(); 
.................... char timed_getc(); 
....................  
.................... boolean timeout_error=false,timeout_error_2=false,last_a=0,last_a4=0,p_s=0; 
.................... int8 j=0,post_var=0,init_var=0,nd=0; 
.................... unsigned char string2[30]={},v3=0; 
.................... unsigned char string6[30]={}; 
.................... int8 num_attempt=0; 
.................... unsigned char set=0x22,enter=0x0d,sent=0x1a,lf=0x0a; 
.................... unsigned char ACK_OK[3]="OK",APN_RE[18]="CSTTairtelgprscom",STATUS_RE[17]="OKSTATEIPINITIAL",STATUS_CON[12]="OKCONNECTOK"; 
.................... unsigned char GSM_STATE[8]="CGREG01",GSM_STATE_R[8]="CGREG05"; 
.................... unsigned char string3[110]={}; 
....................  
.................... char *ptr=0,term[2],*lat=null,*lon=null,*s_time=0,*s_date=0,*s_date1=0,*speed_k; 
.................... char string[20]={}; 
....................  
.................... INT8 buf_var=0,cmp_val,p_status=0,dir=0; 
.................... int8 jl=1,jm=1,p_hrs=5;  
.................... int8 ack_log=0,ack_log1=0,sec; 
.................... int old_min=0,old_sec=0,new_min=0,new_sec=0,date=0,month=0,year=0; 
.................... int v1=0,post_fail_count=0;  
.................... signed int32 yy=0,f_time=0,i_date=0; 
.................... signed int48 s_date_time; 
.................... int32 timeout,timeout_v,timeout_3=0,r_boot=0; 
....................  
.................... float v4=0,v5=0,f_lat=0,f_lon=0,new_hrs=0,old_hrs=null; 
.................... float v6=0,old_la=null,old_ln=null,new_la,new_ln,distt=0,speed=0; 
....................  
.................... struct rtos_stas_struct { 
....................                      unsigned int32 task_total_ticks;   //number of ticks the task has  
....................                                                                                  //used 
....................                      unsigned int16 task_min_ticks;   //the minimum number of ticks  
....................                                                                                  //used 
....................                      unsigned int16 task_max_ticks;  //the maximum number of ticks  
....................                                                                                  //used 
....................                      unsigned int16 hns_per_tick;       //us = (ticks*hns_per_tick)/10 
....................              }stats; 
....................  
.................... int init_gsm_1(int dat) 
.................... { 
....................    switch (dat) 
*
341E:  MOV     B1C,W0
3420:  XOR     #1,W0
3422:  BRA     Z,342A
3424:  XOR     #3,W0
3426:  BRA     Z,3486
3428:  BRA     34F2
.................... { 
....................    case 1:  strncpy(string2,ACK_OK,2); 
342A:  MOV     #91C,W4
342C:  MOV     W4,CB4
342E:  MOV     #95E,W4
3430:  MOV     W4,CB6
3432:  MOV     #2,W4
3434:  MOV     W4,CB8
3436:  CALL    4F0
....................             fprintf(GSM,"A%c",enter); 
343A:  BTSC.B  233.1
343C:  BRA     343A
343E:  MOV     #41,W4
3440:  MOV     W4,234
3442:  BTSC.B  233.1
3444:  BRA     3442
3446:  MOV.B   95A,W0L
3448:  MOV.B   W0L,234
344A:  CLR.B   235
....................             if(!exception(2,2)) 
344C:  MOV.B   #2,W0L
344E:  MOV.B   W0L,CB4
3450:  MOV.B   #2,W0L
3452:  MOV.B   W0L,CB5
3454:  CALL    670
3458:  CP0.B   W0L
345A:  BRA     NZ,347A
....................             {      
....................                num_attempt+=1; 
345C:  MOV.B   958,W0L
345E:  SE      W0,W0
3460:  ADD     W0,#1,W0
3462:  MOV.B   W0L,958
....................                if(num_attempt>20){output_high(fet1);reset_cpu();}                
3464:  MOV.B   958,W0L
3466:  SE      W0,W0
3468:  CP      W0,#14
346A:  BRA     LE,3474
346C:  MOV     #FFBF,W4
346E:  MOV     W4,2C8
3470:  BSET.B  2CC.6
3472:  RESET   
....................                return 0;    
3474:  CLR     0
3476:  BRA     34F4
....................                break; 
3478:  BRA     34F4
....................             } 
....................                num_attempt=0; 
347A:  CLR.B   958
....................                timeout_error=FALSE;                 
347C:  BCLR.B  916.0
....................                return 1; 
347E:  MOV     #1,W4
3480:  MOV     W4,0
3482:  BRA     34F4
....................                break; 
3484:  BRA     34F4
....................    case 2:  strncpy(string2,ACK_OK,2); 
3486:  MOV     #91C,W4
3488:  MOV     W4,CB4
348A:  MOV     #95E,W4
348C:  MOV     W4,CB6
348E:  MOV     #2,W4
3490:  MOV     W4,CB8
3492:  CALL    4F0
....................             fprintf(GSM,"AT+IPR=57600%c",enter); 
3496:  MOV     #0,W1
3498:  MOV     W1,W0
349A:  CLR.B   1
349C:  CALL    200
34A0:  INC     W1,W1
34A2:  BTSC.B  233.1
34A4:  BRA     34A2
34A6:  MOV     W0,234
34A8:  MOV     #B,W0
34AA:  CPSGT   W1,W0
34AC:  BRA     3498
34AE:  BTSC.B  233.1
34B0:  BRA     34AE
34B2:  MOV.B   95A,W0L
34B4:  MOV.B   W0L,234
34B6:  CLR.B   235
....................             if(!exception(2,2)) 
34B8:  MOV.B   #2,W0L
34BA:  MOV.B   W0L,CB4
34BC:  MOV.B   #2,W0L
34BE:  MOV.B   W0L,CB5
34C0:  CALL    670
34C4:  CP0.B   W0L
34C6:  BRA     NZ,34E6
....................             {      
....................                num_attempt+=1; 
34C8:  MOV.B   958,W0L
34CA:  SE      W0,W0
34CC:  ADD     W0,#1,W0
34CE:  MOV.B   W0L,958
....................                if(num_attempt>20){output_high(fet1);reset_cpu();}                
34D0:  MOV.B   958,W0L
34D2:  SE      W0,W0
34D4:  CP      W0,#14
34D6:  BRA     LE,34E0
34D8:  MOV     #FFBF,W4
34DA:  MOV     W4,2C8
34DC:  BSET.B  2CC.6
34DE:  RESET   
....................                return 0;    
34E0:  CLR     0
34E2:  BRA     34F4
....................                break; 
34E4:  BRA     34F4
....................             } 
....................     
....................                num_attempt=0; 
34E6:  CLR.B   958
....................                timeout_error=FALSE;                 
34E8:  BCLR.B  916.0
....................                return 1; 
34EA:  MOV     #1,W4
34EC:  MOV     W4,0
34EE:  BRA     34F4
....................                break; 
34F0:  BRA     34F4
....................                 
....................    default: break;               
34F2:  BRA     34F4
....................    } 
34F4:  RETURN  
.................... } 
....................  
.................... int init_gsm(int dat){  
.................... switch (dat) 
*
077A:  MOV     B26,W0
077C:  XOR     #1,W0
077E:  BRA     Z,792
0780:  XOR     #3,W0
0782:  BRA     Z,7FE
0784:  XOR     #1,W0
0786:  BRA     Z,87E
0788:  XOR     #7,W0
078A:  BRA     Z,902
078C:  XOR     #1,W0
078E:  BRA     Z,986
0790:  BRA     A0A
.................... { 
....................    case 1:  strncpy(string2,ACK_OK,2);             
0792:  MOV     #91C,W4
0794:  MOV     W4,CB4
0796:  MOV     #95E,W4
0798:  MOV     W4,CB6
079A:  MOV     #2,W4
079C:  MOV     W4,CB8
079E:  CALL    4F0
....................             CANCEL_ECHO 
07A2:  MOV     #0,W1
07A4:  MOV     W1,W0
07A6:  CLR.B   1
07A8:  CALL    21C
07AC:  INC     W1,W1
07AE:  BTSC.B  233.1
07B0:  BRA     7AE
07B2:  MOV     W0,234
07B4:  MOV     #3,W0
07B6:  CPSGT   W1,W0
07B8:  BRA     7A4
07BA:  BTSC.B  233.1
07BC:  BRA     7BA
07BE:  MOV.B   95A,W0L
07C0:  MOV.B   W0L,234
07C2:  CLR.B   235
....................             if(!exception(2,2)) 
07C4:  MOV.B   #2,W0L
07C6:  MOV.B   W0L,CB4
07C8:  MOV.B   #2,W0L
07CA:  MOV.B   W0L,CB5
07CC:  CALL    670
07D0:  CP0.B   W0L
07D2:  BRA     NZ,7F2
....................             {      
....................                num_attempt+=1; 
07D4:  MOV.B   958,W0L
07D6:  SE      W0,W0
07D8:  ADD     W0,#1,W0
07DA:  MOV.B   W0L,958
....................                if(num_attempt>10){output_high(fet1);reset_cpu();}                
07DC:  MOV.B   958,W0L
07DE:  SE      W0,W0
07E0:  CP      W0,#A
07E2:  BRA     LE,7EC
07E4:  MOV     #FFBF,W4
07E6:  MOV     W4,2C8
07E8:  BSET.B  2CC.6
07EA:  RESET   
....................                return 0;    
07EC:  CLR     0
07EE:  BRA     A0C
....................                break; 
07F0:  BRA     A0C
....................             } 
....................                num_attempt=0; 
07F2:  CLR.B   958
....................                timeout_error=FALSE;                 
07F4:  BCLR.B  916.0
....................                return 1; 
07F6:  MOV     #1,W4
07F8:  MOV     W4,0
07FA:  BRA     A0C
....................                break; 
07FC:  BRA     A0C
....................                 
....................    case 2: strncpy(string2,GSM_STATE,7); 
07FE:  MOV     #91C,W4
0800:  MOV     W4,CB4
0802:  MOV     #992,W4
0804:  MOV     W4,CB6
0806:  MOV     #7,W4
0808:  MOV     W4,CB8
080A:  CALL    4F0
....................            strncpy(string6,GSM_STATE_R,7); 
080E:  MOV     #93A,W4
0810:  MOV     W4,CB4
0812:  MOV     #99A,W4
0814:  MOV     W4,CB6
0816:  MOV     #7,W4
0818:  MOV     W4,CB8
081A:  CALL    4F0
....................            GET_GSM_STATUS 
081E:  MOV     #0,W1
0820:  MOV     W1,W0
0822:  CLR.B   1
0824:  CALL    230
0828:  INC     W1,W1
082A:  BTSC.B  233.1
082C:  BRA     82A
082E:  MOV     W0,234
0830:  MOV     #8,W0
0832:  CPSGT   W1,W0
0834:  BRA     820
0836:  BTSC.B  233.1
0838:  BRA     836
083A:  MOV.B   95A,W0L
083C:  MOV.B   W0L,234
083E:  CLR.B   235
....................                timeout_error=FALSE; 
0840:  BCLR.B  916.0
....................                if(!exception(7,7)) 
0842:  MOV.B   #7,W0L
0844:  MOV.B   W0L,CB4
0846:  MOV.B   #7,W0L
0848:  MOV.B   W0L,CB5
084A:  CALL    670
084E:  CP0.B   W0L
0850:  BRA     NZ,872
....................                { 
....................                   num_attempt+=1; 
0852:  MOV.B   958,W0L
0854:  SE      W0,W0
0856:  ADD     W0,#1,W0
0858:  MOV.B   W0L,958
....................                   if(num_attempt>20){output_high(fet1);reset_cpu();}    
085A:  MOV.B   958,W0L
085C:  SE      W0,W0
085E:  CP      W0,#14
0860:  BRA     LE,86A
0862:  MOV     #FFBF,W4
0864:  MOV     W4,2C8
0866:  BSET.B  2CC.6
0868:  RESET   
....................                   return 0;  
086A:  CLR     0
086C:  BRA     A0C
....................                   break; 
086E:  BRA     A0C
....................                }else{ 
0870:  BRA     87E
....................                   num_attempt=0; 
0872:  CLR.B   958
....................                   timeout_error=FALSE;                     
0874:  BCLR.B  916.0
....................                   return 1; 
0876:  MOV     #1,W4
0878:  MOV     W4,0
087A:  BRA     A0C
....................                   break;} 
087C:  BRA     A0C
....................                 
....................    case 3:  strncpy(string2,ACK_OK,2); 
087E:  MOV     #91C,W4
0880:  MOV     W4,CB4
0882:  MOV     #95E,W4
0884:  MOV     W4,CB6
0886:  MOV     #2,W4
0888:  MOV     W4,CB8
088A:  CALL    4F0
....................             fprintf(BUG,"AT+GPS=1\n\r"); 
088E:  MOV     #0,W1
0890:  MOV     W1,W0
0892:  CLR.B   1
0894:  CALL    248
0898:  INC     W1,W1
089A:  BTSC.B  223.1
089C:  BRA     89A
089E:  MOV     W0,224
08A0:  MOV     #9,W0
08A2:  CPSGT   W1,W0
08A4:  BRA     890
....................             GPS_ON 
08A6:  MOV     #0,W1
08A8:  MOV     W1,W0
08AA:  CLR.B   1
08AC:  CALL    260
08B0:  INC     W1,W1
08B2:  BTSC.B  233.1
08B4:  BRA     8B2
08B6:  MOV     W0,234
08B8:  MOV     #B,W0
08BA:  CPSGT   W1,W0
08BC:  BRA     8A8
08BE:  BTSC.B  233.1
08C0:  BRA     8BE
08C2:  MOV.B   95A,W0L
08C4:  MOV.B   W0L,234
08C6:  CLR.B   235
....................             if(!exception(2,2)) 
08C8:  MOV.B   #2,W0L
08CA:  MOV.B   W0L,CB4
08CC:  MOV.B   #2,W0L
08CE:  MOV.B   W0L,CB5
08D0:  CALL    670
08D4:  CP0.B   W0L
08D6:  BRA     NZ,8F6
....................             {      
....................                 num_attempt+=1; 
08D8:  MOV.B   958,W0L
08DA:  SE      W0,W0
08DC:  ADD     W0,#1,W0
08DE:  MOV.B   W0L,958
....................                 if(num_attempt>20){output_high(fet1);reset_cpu();}    
08E0:  MOV.B   958,W0L
08E2:  SE      W0,W0
08E4:  CP      W0,#14
08E6:  BRA     LE,8F0
08E8:  MOV     #FFBF,W4
08EA:  MOV     W4,2C8
08EC:  BSET.B  2CC.6
08EE:  RESET   
....................                 return 0;  
08F0:  CLR     0
08F2:  BRA     A0C
....................                 break; 
08F4:  BRA     A0C
....................             } 
....................                num_attempt=0; 
08F6:  CLR.B   958
....................                timeout_error=FALSE;                
08F8:  BCLR.B  916.0
....................                return 1;   
08FA:  MOV     #1,W4
08FC:  MOV     W4,0
08FE:  BRA     A0C
....................                break;      
0900:  BRA     A0C
....................    case 4:  strncpy(string2,ACK_OK,2); 
0902:  MOV     #91C,W4
0904:  MOV     W4,CB4
0906:  MOV     #95E,W4
0908:  MOV     W4,CB6
090A:  MOV     #2,W4
090C:  MOV     W4,CB8
090E:  CALL    4F0
....................             fprintf(BUG,"AT+ECHARGE=1\n\r"); 
0912:  MOV     #0,W1
0914:  MOV     W1,W0
0916:  CLR.B   1
0918:  CALL    27C
091C:  INC     W1,W1
091E:  BTSC.B  223.1
0920:  BRA     91E
0922:  MOV     W0,224
0924:  MOV     #D,W0
0926:  CPSGT   W1,W0
0928:  BRA     914
....................             fprintf(GSM,"AT+ECHARGE=1%c",enter);    
092A:  MOV     #0,W1
092C:  MOV     W1,W0
092E:  CLR.B   1
0930:  CALL    298
0934:  INC     W1,W1
0936:  BTSC.B  233.1
0938:  BRA     936
093A:  MOV     W0,234
093C:  MOV     #B,W0
093E:  CPSGT   W1,W0
0940:  BRA     92C
0942:  BTSC.B  233.1
0944:  BRA     942
0946:  MOV.B   95A,W0L
0948:  MOV.B   W0L,234
094A:  CLR.B   235
....................             if(!exception(2,2)) 
094C:  MOV.B   #2,W0L
094E:  MOV.B   W0L,CB4
0950:  MOV.B   #2,W0L
0952:  MOV.B   W0L,CB5
0954:  CALL    670
0958:  CP0.B   W0L
095A:  BRA     NZ,97A
....................             {      
....................                 num_attempt+=1; 
095C:  MOV.B   958,W0L
095E:  SE      W0,W0
0960:  ADD     W0,#1,W0
0962:  MOV.B   W0L,958
....................                 if(num_attempt>20){output_high(fet1);reset_cpu();}    
0964:  MOV.B   958,W0L
0966:  SE      W0,W0
0968:  CP      W0,#14
096A:  BRA     LE,974
096C:  MOV     #FFBF,W4
096E:  MOV     W4,2C8
0970:  BSET.B  2CC.6
0972:  RESET   
....................                 return 0;  
0974:  CLR     0
0976:  BRA     A0C
....................                 break; 
0978:  BRA     A0C
....................             } 
....................                num_attempt=0; 
097A:  CLR.B   958
....................                timeout_error=FALSE;                
097C:  BCLR.B  916.0
....................                return 1;   
097E:  MOV     #1,W4
0980:  MOV     W4,0
0982:  BRA     A0C
....................                break;   
0984:  BRA     A0C
....................    case 5:  strncpy(string2,ACK_OK,2); 
0986:  MOV     #91C,W4
0988:  MOV     W4,CB4
098A:  MOV     #95E,W4
098C:  MOV     W4,CB6
098E:  MOV     #2,W4
0990:  MOV     W4,CB8
0992:  CALL    4F0
....................             fprintf(BUG,"AT+RGPS=1\n\r"); 
0996:  MOV     #0,W1
0998:  MOV     W1,W0
099A:  CLR.B   1
099C:  CALL    2B4
09A0:  INC     W1,W1
09A2:  BTSC.B  223.1
09A4:  BRA     9A2
09A6:  MOV     W0,224
09A8:  MOV     #A,W0
09AA:  CPSGT   W1,W0
09AC:  BRA     998
....................             GPS_REBOOT 
09AE:  MOV     #0,W1
09B0:  MOV     W1,W0
09B2:  CLR.B   1
09B4:  CALL    2CC
09B8:  INC     W1,W1
09BA:  BTSC.B  233.1
09BC:  BRA     9BA
09BE:  MOV     W0,234
09C0:  MOV     #B,W0
09C2:  CPSGT   W1,W0
09C4:  BRA     9B0
09C6:  BTSC.B  233.1
09C8:  BRA     9C6
09CA:  MOV.B   95A,W0L
09CC:  MOV.B   W0L,234
09CE:  CLR.B   235
....................             if(!exception(2,2)) 
09D0:  MOV.B   #2,W0L
09D2:  MOV.B   W0L,CB4
09D4:  MOV.B   #2,W0L
09D6:  MOV.B   W0L,CB5
09D8:  CALL    670
09DC:  CP0.B   W0L
09DE:  BRA     NZ,9FE
....................             {      
....................                num_attempt+=1; 
09E0:  MOV.B   958,W0L
09E2:  SE      W0,W0
09E4:  ADD     W0,#1,W0
09E6:  MOV.B   W0L,958
....................                if(num_attempt>10){output_high(fet1);reset_cpu();}                
09E8:  MOV.B   958,W0L
09EA:  SE      W0,W0
09EC:  CP      W0,#A
09EE:  BRA     LE,9F8
09F0:  MOV     #FFBF,W4
09F2:  MOV     W4,2C8
09F4:  BSET.B  2CC.6
09F6:  RESET   
....................                return 0;    
09F8:  CLR     0
09FA:  BRA     A0C
....................                break; 
09FC:  BRA     A0C
....................             } 
....................                num_attempt=0; 
09FE:  CLR.B   958
....................                timeout_error=FALSE;                
0A00:  BCLR.B  916.0
....................                return 1;   
0A02:  MOV     #1,W4
0A04:  MOV     W4,0
0A06:  BRA     A0C
....................                break;                 
0A08:  BRA     A0C
....................     
....................     default: break;               
0A0A:  BRA     A0C
....................    } 
0A0C:  RETURN  
.................... }          
....................  
.................... boolean exception(unsigned char bb,INT8 cc) 
*
0670:  MOV     W5,[W15++]
.................... {    
.................... //   string[1]='X'; 
....................    buf_var=0;cmp_val=bb;    
0672:  CLR.B   95D
0674:  MOV.B   CB4,W0L
0676:  MOV.B   W0L,961
....................    fprintf(BUG,"CASE-%u\n\r",jm);    
0678:  MOV     #0,W1
067A:  MOV     W1,W0
067C:  CLR.B   1
067E:  CALL    2E8
0682:  INC     W1,W1
0684:  BTSC.B  223.1
0686:  BRA     684
0688:  MOV     W0,224
068A:  MOV     #4,W0
068C:  CPSGT   W1,W0
068E:  BRA     67A
0690:  MOV.B   A36,W0L
0692:  CLR.B   1
0694:  MOV     #0,W4
0696:  CALL    528
069A:  BTSC.B  223.1
069C:  BRA     69A
069E:  MOV     #A,W4
06A0:  MOV     W4,224
06A2:  BTSC.B  223.1
06A4:  BRA     6A2
06A6:  MOV     #D,W4
06A8:  MOV     W4,224
....................    timeout_error=FALSE; 
06AA:  BCLR.B  916.0
....................    timeout_v = 400000; 
06AC:  MOV     #1A80,W4
06AE:  MOV     W4,A64
06B0:  MOV     #6,W4
06B2:  MOV     W4,A66
....................    while(buf_var <= cc && !timeout_error)    
06B4:  MOV.B   95D,W0L
06B6:  MOV     CB4,W4
06B8:  LSR     W4,#8,W4
06BA:  CP.B    W4L,W0L
06BC:  BRA     LT,722
06BE:  BTSC.B  916.0
06C0:  BRA     722
....................    { 
....................       v3 = timed_getc(); 
06C2:  CALL    5EC
06C6:  MOV.B   W0L,91B
....................       if(isalpha(v3) || isdigit(v3)){ 
06C8:  MOV     91A,W4
06CA:  LSR     W4,#8,W4
06CC:  MOV     #41,W3
06CE:  CP.B    W3L,W4L
06D0:  BRA     GTU,6DE
06D2:  MOV     91A,W4
06D4:  LSR     W4,#8,W4
06D6:  MOV     #5A,W3
06D8:  CP.B    W3L,W4L
06DA:  BRA     NC,6DE
06DC:  BRA     708
06DE:  MOV     91A,W4
06E0:  LSR     W4,#8,W4
06E2:  MOV     #61,W3
06E4:  CP.B    W3L,W4L
06E6:  BRA     GTU,6F4
06E8:  MOV     91A,W4
06EA:  LSR     W4,#8,W4
06EC:  MOV     #7A,W3
06EE:  CP.B    W3L,W4L
06F0:  BRA     NC,6F4
06F2:  BRA     708
06F4:  MOV     91A,W4
06F6:  LSR     W4,#8,W4
06F8:  MOV     #30,W3
06FA:  CP.B    W3L,W4L
06FC:  BRA     GTU,720
06FE:  MOV     91A,W4
0700:  LSR     W4,#8,W4
0702:  MOV     #39,W3
0704:  CP.B    W3L,W4L
0706:  BRA     NC,720
....................       string[buf_var]=v3;    
0708:  MOV.B   95D,W0L
070A:  SE      W0,W0
070C:  MOV     #A20,W4
070E:  ADD     W0,W4,W5
0710:  MOV.B   91B,W0L
0712:  MOV.B   W0L,[W5]
....................       fprintf(BUG,"%c",v3);  
0714:  BTSC.B  223.1
0716:  BRA     714
0718:  MOV.B   91B,W0L
071A:  MOV.B   W0L,224
071C:  CLR.B   225
....................       buf_var++; 
071E:  INC.B   095D
....................       }       
0720:  BRA     6B4
....................    }    
.................... //   fprintf(BUG,"%s",string); 
....................    fprintf(BUG,"-\n\r"); 
0722:  BTSC.B  223.1
0724:  BRA     722
0726:  MOV     #2D,W4
0728:  MOV     W4,224
072A:  BTSC.B  223.1
072C:  BRA     72A
072E:  MOV     #A,W4
0730:  MOV     W4,224
0732:  BTSC.B  223.1
0734:  BRA     732
0736:  MOV     #D,W4
0738:  MOV     W4,224
.................... //   timeout_error=FALSE; 
.................... //   gets(string,GSM); 
....................    if(!strncmp(string,string2,cmp_val) || !strncmp(string,string6,cmp_val))   
073A:  MOV.B   961,W0L
073C:  MOV.B   W0L,W4L
073E:  SE      W4,W3
0740:  MOV     W3,CBC
0742:  MOV     #A20,W3
0744:  MOV     W3,CB8
0746:  MOV     #91C,W3
0748:  MOV     W3,CBA
074A:  CALL    628
074E:  CP0.B   W0L
0750:  BRA     Z,76A
0752:  MOV.B   961,W0L
0754:  MOV.B   W0L,W4L
0756:  SE      W4,W3
0758:  MOV     W3,CBC
075A:  MOV     #A20,W3
075C:  MOV     W3,CB8
075E:  MOV     #93A,W3
0760:  MOV     W3,CBA
0762:  CALL    628
0766:  CP0.B   W0L
0768:  BRA     NZ,772
....................    return 1;    
076A:  MOV.B   #1,W0L
076C:  MOV.B   W0L,0
076E:  BRA     776
0770:  BRA     776
....................    else 
....................    return 0;    
0772:  CLR.B   0
0774:  BRA     776
0776:  MOV     [--W15],W5
0778:  RETURN  
.................... } 
....................  
.................... char timed_getc() {    
....................  
....................    timeout_error=FALSE; 
*
05EC:  BCLR.B  916.0
....................    timeout=0; 
05EE:  CLR     A60
05F0:  CLR     A62
....................    while(!kbhit(GSM) && (++timeout<timeout_v)) // 1/2 // second 
05F2:  BTSC.B  232.0
05F4:  BRA     614
05F6:  INC     0A60
05F8:  BTSC.B  42.1
05FA:  INC     0A62
05FC:  MOV     A62,W0
05FE:  MOV     A66,W4
0600:  CP      W4,W0
0602:  BRA     LT,614
0604:  BRA     GT,60E
0606:  MOV     A60,W0
0608:  MOV     A64,W4
060A:  CP      W4,W0
060C:  BRA     LEU,614
....................           delay_us(5); 
060E:  REPEAT  #26
0610:  NOP     
0612:  BRA     5F2
....................    if(kbhit(GSM)) {       
0614:  BTSS.B  232.0
0616:  BRA     620
....................           return(getc(GSM));} 
0618:  CALL    5DE
061C:  BRA     626
061E:  BRA     626
....................    else { 
....................           timeout_error=TRUE;  
0620:  BSET.B  916.0
....................           return(0); 
0622:  CLR.B   0
0624:  BRA     626
....................    } 
0626:  RETURN  
.................... } 
....................  
.................... boolean ack_1(char dat) 
*
2B2E:  MOV     W5,[W15++]
.................... { 
....................       timeout_v = 40000000;            
2B30:  MOV     #5A00,W4
2B32:  MOV     W4,A64
2B34:  MOV     #262,W4
2B36:  MOV     W4,A66
....................       if(timed_getc() == dat || timeout_error==TRUE) 
2B38:  CALL    5EC
2B3C:  CP.B    CAC
2B3E:  BRA     Z,2B44
2B40:  BTSS.B  916.0
2B42:  BRA     2B4A
....................       return 1;     
2B44:  MOV.B   #1,W0L
2B46:  MOV.B   W0L,0
2B48:  BRA     2B4A
2B4A:  MOV     [--W15],W5
2B4C:  RETURN  
.................... } 
....................  
.................... int8 cip_start() 
.................... { 
....................     strncpy(string2,STATUS_CON,11); 
*
2A2C:  MOV     #91C,W4
2A2E:  MOV     W4,CB4
2A30:  MOV     #986,W4
2A32:  MOV     W4,CB6
2A34:  MOV     #B,W4
2A36:  MOV     W4,CB8
2A38:  CALL    4F0
....................     START_CIP 
2A3C:  MOV     #0,W1
2A3E:  MOV     W1,W0
2A40:  CLR.B   1
2A42:  CALL    2FE
2A46:  INC     W1,W1
2A48:  BTSC.B  233.1
2A4A:  BRA     2A48
2A4C:  MOV     W0,234
2A4E:  MOV     #B,W0
2A50:  CPSGT   W1,W0
2A52:  BRA     2A3E
2A54:  BTSC.B  233.1
2A56:  BRA     2A54
2A58:  MOV.B   959,W0L
2A5A:  MOV.B   W0L,234
2A5C:  CLR.B   235
2A5E:  BTSC.B  233.1
2A60:  BRA     2A5E
2A62:  MOV     #54,W4
2A64:  MOV     W4,234
2A66:  BTSC.B  233.1
2A68:  BRA     2A66
2A6A:  MOV     #43,W4
2A6C:  MOV     W4,234
2A6E:  BTSC.B  233.1
2A70:  BRA     2A6E
2A72:  MOV     #50,W4
2A74:  MOV     W4,234
2A76:  BTSC.B  233.1
2A78:  BRA     2A76
2A7A:  MOV.B   959,W0L
2A7C:  MOV.B   W0L,234
2A7E:  CLR.B   235
2A80:  BTSC.B  233.1
2A82:  BRA     2A80
2A84:  MOV     #2C,W4
2A86:  MOV     W4,234
2A88:  BTSC.B  233.1
2A8A:  BRA     2A88
2A8C:  MOV.B   959,W0L
2A8E:  MOV.B   W0L,234
2A90:  CLR.B   235
2A92:  MOV     #16,W1
2A94:  MOV     W1,W0
2A96:  CLR.B   1
2A98:  CALL    2FE
2A9C:  INC     W1,W1
2A9E:  BTSC.B  233.1
2AA0:  BRA     2A9E
2AA2:  MOV     W0,234
2AA4:  MOV     #26,W0
2AA6:  CPSGT   W1,W0
2AA8:  BRA     2A94
2AAA:  BTSC.B  233.1
2AAC:  BRA     2AAA
2AAE:  MOV.B   959,W0L
2AB0:  MOV.B   W0L,234
2AB2:  CLR.B   235
2AB4:  BTSC.B  233.1
2AB6:  BRA     2AB4
2AB8:  MOV     #2C,W4
2ABA:  MOV     W4,234
2ABC:  BTSC.B  233.1
2ABE:  BRA     2ABC
2AC0:  MOV.B   959,W0L
2AC2:  MOV.B   W0L,234
2AC4:  CLR.B   235
2AC6:  BTSC.B  233.1
2AC8:  BRA     2AC6
2ACA:  MOV     #38,W4
2ACC:  MOV     W4,234
2ACE:  BTSC.B  233.1
2AD0:  BRA     2ACE
2AD2:  MOV     #30,W4
2AD4:  MOV     W4,234
2AD6:  BTSC.B  233.1
2AD8:  BRA     2AD6
2ADA:  MOV.B   959,W0L
2ADC:  MOV.B   W0L,234
2ADE:  CLR.B   235
2AE0:  BTSC.B  233.1
2AE2:  BRA     2AE0
2AE4:  MOV.B   95A,W0L
2AE6:  MOV.B   W0L,234
2AE8:  CLR.B   235
....................  //   fprintf(BUG,"AT+\n\r");     
....................     if(!exception(10,11)) 
2AEA:  MOV.B   #A,W0L
2AEC:  MOV.B   W0L,CB4
2AEE:  MOV.B   #B,W0L
2AF0:  MOV.B   W0L,CB5
2AF2:  CALL    670
2AF6:  CP0.B   W0L
2AF8:  BRA     NZ,2B02
....................     { 
.................... //      if(num_attempt++<=2) 
.................... //      goto l0; 
.................... //      else  
....................       return 80;  
2AFA:  MOV.B   #50,W0L
2AFC:  MOV.B   W0L,0
2AFE:  BRA     2B08
....................       } 
2B00:  BRA     2B08
....................       else return 81;   
2B02:  MOV.B   #51,W0L
2B04:  MOV.B   W0L,0
2B06:  BRA     2B08
2B08:  RETURN  
.................... } 
....................  
.................... void post() 
.................... {  
.................... //     disable_interrupts(INT_CNI); 
.................... //      cip_send(); 
....................       cip_send1(); 
*
3186:  CALL    2F1C
....................       cip_send2();   
318A:  CALL    3050
....................       cip_send3(); 
318E:  CALL    30C4
3192:  RETURN  
.................... //      timeout_v = 800000; 
.................... //      rtos_await(kbhit()); 
.................... //      while(timed_getc()!='1' && timeout_error!=TRUE);             
.................... //      cip_close();      
.................... //      enable_interrupts(INT_CNI); 
.................... } 
....................  
.................... void cip_send() 
.................... {    
....................    fprintf(GSM,"AT+CIPSEND"); 
*
2B0A:  MOV     #0,W1
2B0C:  MOV     W1,W0
2B0E:  CLR.B   1
2B10:  CALL    33C
2B14:  INC     W1,W1
2B16:  BTSC.B  233.1
2B18:  BRA     2B16
2B1A:  MOV     W0,234
2B1C:  MOV     #9,W0
2B1E:  CPSGT   W1,W0
2B20:  BRA     2B0C
....................    fprintf(GSM,"%c",enter);    
2B22:  BTSC.B  233.1
2B24:  BRA     2B22
2B26:  MOV.B   95A,W0L
2B28:  MOV.B   W0L,234
2B2A:  CLR.B   235
2B2C:  RETURN  
.................... //   while(timed_getc()!='>' && timeout_error!=TRUE); 
.................... //   if(timeout_error==TRUE){ 
.................... //      cip_close();      
.................... //      return;       
.................... } 
....................  
.................... void cip_send1() 
*
2F1C:  MOV     W9,[W15++]
2F1E:  MOV     W10,[W15++]
.................... {                                                                    //139.59.8.190 
....................    fprintf(GSM,"GET http://www.gpstraces.com/u/u?i=865067022435708&");   //imeiid=866762027240124//imeiid=866593020769383//866762027261112 
2F20:  MOV     #0,W1
2F22:  MOV     W1,W0
2F24:  CLR.B   1
2F26:  CALL    354
2F2A:  INC     W1,W1
2F2C:  BTSC.B  233.1
2F2E:  BRA     2F2C
2F30:  MOV     W0,234
2F32:  MOV     #32,W0
2F34:  CPSGT   W1,W0
2F36:  BRA     2F22
....................    fprintf(GSM,"ln="); 
2F38:  BTSC.B  233.1
2F3A:  BRA     2F38
2F3C:  MOV     #6C,W4
2F3E:  MOV     W4,234
2F40:  BTSC.B  233.1
2F42:  BRA     2F40
2F44:  MOV     #6E,W4
2F46:  MOV     W4,234
2F48:  BTSC.B  233.1
2F4A:  BRA     2F48
2F4C:  MOV     #3D,W4
2F4E:  MOV     W4,234
....................    fprintf(GSM,"%2.5g",new_ln);//2.6    
2F50:  MOV     A9A,W2
2F52:  MOV     A98,W1
2F54:  MOV     #0,W0
2F56:  CALL    2B4E
2F5A:  MOV     #5,W9
2F5C:  MOV     #6,W10
2F5E:  CALL    2D9A
....................    fprintf(GSM,"&");       
2F62:  BTSC.B  233.1
2F64:  BRA     2F62
2F66:  MOV     #26,W4
2F68:  MOV     W4,234
....................    fprintf(GSM,"lt="); 
2F6A:  BTSC.B  233.1
2F6C:  BRA     2F6A
2F6E:  MOV     #6C,W4
2F70:  MOV     W4,234
2F72:  BTSC.B  233.1
2F74:  BRA     2F72
2F76:  MOV     #74,W4
2F78:  MOV     W4,234
2F7A:  BTSC.B  233.1
2F7C:  BRA     2F7A
2F7E:  MOV     #3D,W4
2F80:  MOV     W4,234
....................    fprintf(GSM,"%2.5g",new_la);    
2F82:  MOV     A96,W2
2F84:  MOV     A94,W1
2F86:  MOV     #0,W0
2F88:  CALL    2B4E
2F8C:  MOV     #5,W9
2F8E:  MOV     #6,W10
2F90:  CALL    2D9A
2F94:  MOV     [--W15],W10
2F96:  MOV     [--W15],W9
2F98:  RETURN  
.................... } 
....................  
.................... void cip_send2() 
*
3050:  MOV     W9,[W15++]
3052:  MOV     W10,[W15++]
.................... { 
....................    fprintf(GSM,"&");  
3054:  BTSC.B  233.1
3056:  BRA     3054
3058:  MOV     #26,W4
305A:  MOV     W4,234
....................    fprintf(GSM,"s=");    
305C:  BTSC.B  233.1
305E:  BRA     305C
3060:  MOV     #73,W4
3062:  MOV     W4,234
3064:  BTSC.B  233.1
3066:  BRA     3064
3068:  MOV     #3D,W4
306A:  MOV     W4,234
.................... //   if(dir == 1)fprintf(GSM"1"); else     
....................    fprintf(GSM,"%3.1g",speed); 
306C:  MOV     AA2,W2
306E:  MOV     AA0,W1
3070:  MOV     #0,W0
3072:  CALL    2B4E
3076:  MOV     #1,W9
3078:  MOV     #2,W10
307A:  CALL    2D9A
....................    fprintf(GSM,"&t="); 
307E:  BTSC.B  233.1
3080:  BRA     307E
3082:  MOV     #26,W4
3084:  MOV     W4,234
3086:  BTSC.B  233.1
3088:  BRA     3086
308A:  MOV     #74,W4
308C:  MOV     W4,234
308E:  BTSC.B  233.1
3090:  BRA     308E
3092:  MOV     #3D,W4
3094:  MOV     W4,234
....................    fprintf(GSM,"%04lu/%02u/%02u",year,month,date);    
3096:  MOV     A48,W0
3098:  MOV     #8004,W4
309A:  CALL    2F9A
309E:  BTSC.B  233.1
30A0:  BRA     309E
30A2:  MOV     #2F,W4
30A4:  MOV     W4,234
30A6:  MOV     A46,W0
30A8:  MOV     #8002,W4
30AA:  CALL    2F9A
30AE:  BTSC.B  233.1
30B0:  BRA     30AE
30B2:  MOV     #2F,W4
30B4:  MOV     W4,234
30B6:  MOV     A44,W0
30B8:  MOV     #8002,W4
30BA:  CALL    2F9A
30BE:  MOV     [--W15],W10
30C0:  MOV     [--W15],W9
30C2:  RETURN  
.................... } 
....................  
.................... void cip_send3() 
.................... {       
....................    fputc('%',GSM); 
30C4:  MOV.B   #25,W0L
30C6:  BTSC.B  233.1
30C8:  BRA     30C6
30CA:  MOV.B   W0L,234
30CC:  CLR.B   235
....................    fprintf(GSM,"20");  
30CE:  BTSC.B  233.1
30D0:  BRA     30CE
30D2:  MOV     #32,W4
30D4:  MOV     W4,234
30D6:  BTSC.B  233.1
30D8:  BRA     30D6
30DA:  MOV     #30,W4
30DC:  MOV     W4,234
....................    fprintf(GSM,"%02u:%02u:%02u",v1,new_min,new_sec);   
30DE:  MOV     A4A,W0
30E0:  MOV     #8002,W4
30E2:  CALL    2F9A
30E6:  BTSC.B  233.1
30E8:  BRA     30E6
30EA:  MOV     #3A,W4
30EC:  MOV     W4,234
30EE:  MOV     A40,W0
30F0:  MOV     #8002,W4
30F2:  CALL    2F9A
30F6:  BTSC.B  233.1
30F8:  BRA     30F6
30FA:  MOV     #3A,W4
30FC:  MOV     W4,234
30FE:  MOV     A42,W0
3100:  MOV     #8002,W4
3102:  CALL    2F9A
....................    fprintf(GSM,"&");  
3106:  BTSC.B  233.1
3108:  BRA     3106
310A:  MOV     #26,W4
310C:  MOV     W4,234
....................    fprintf(GSM,"u=%02u",dir);   
310E:  BTSC.B  233.1
3110:  BRA     310E
3112:  MOV     #75,W4
3114:  MOV     W4,234
3116:  BTSC.B  233.1
3118:  BRA     3116
311A:  MOV     #3D,W4
311C:  MOV     W4,234
311E:  MOV.B   A34,W0L
3120:  CLR.B   1
3122:  MOV     #8002,W4
3124:  CALL    2F9A
....................    fprintf(BUG,"u=%02u\n\r",dir);   
3128:  BTSC.B  223.1
312A:  BRA     3128
312C:  MOV     #75,W4
312E:  MOV     W4,224
3130:  BTSC.B  223.1
3132:  BRA     3130
3134:  MOV     #3D,W4
3136:  MOV     W4,224
3138:  MOV.B   A34,W0L
313A:  CLR.B   1
313C:  MOV     #8002,W4
313E:  CALL    528
3142:  BTSC.B  223.1
3144:  BRA     3142
3146:  MOV     #A,W4
3148:  MOV     W4,224
314A:  BTSC.B  223.1
314C:  BRA     314A
314E:  MOV     #D,W4
3150:  MOV     W4,224
.................... //   delay_ms(50); 
....................    fprintf(GSM,"%c",enter); 
3152:  BTSC.B  233.1
3154:  BRA     3152
3156:  MOV.B   95A,W0L
3158:  MOV.B   W0L,234
315A:  CLR.B   235
....................    fprintf(GSM,"%c",lf); 
315C:  BTSC.B  233.1
315E:  BRA     315C
3160:  MOV.B   95C,W0L
3162:  MOV.B   W0L,234
3164:  CLR.B   235
....................    fprintf(GSM,"%c",enter); 
3166:  BTSC.B  233.1
3168:  BRA     3166
316A:  MOV.B   95A,W0L
316C:  MOV.B   W0L,234
316E:  CLR.B   235
....................    fprintf(GSM,"%c",lf); 
3170:  BTSC.B  233.1
3172:  BRA     3170
3174:  MOV.B   95C,W0L
3176:  MOV.B   W0L,234
3178:  CLR.B   235
....................    fprintf(GSM,"%c",sent);   
317A:  BTSC.B  233.1
317C:  BRA     317A
317E:  MOV.B   95B,W0L
3180:  MOV.B   W0L,234
3182:  CLR.B   235
3184:  RETURN  
.................... //   for(sec=0;sec<=5;sec++) 
.................... //   fprintf(BUG,"A-%c\n\r",timed_getc()); 
.................... } 
.................... void cip_close() 
.................... { 
.................... //   delay_ms(100);//100 
....................    fprintf(GSM,"AT+CIPCLOSE"); 
*
3194:  MOV     #0,W1
3196:  MOV     W1,W0
3198:  CLR.B   1
319A:  CALL    394
319E:  INC     W1,W1
31A0:  BTSC.B  233.1
31A2:  BRA     31A0
31A4:  MOV     W0,234
31A6:  MOV     #A,W0
31A8:  CPSGT   W1,W0
31AA:  BRA     3196
....................    fprintf(GSM,"%c",enter); 
31AC:  BTSC.B  233.1
31AE:  BRA     31AC
31B0:  MOV.B   95A,W0L
31B2:  MOV.B   W0L,234
31B4:  CLR.B   235
31B6:  RETURN  
.................... }  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------// 
.................... #task(rate=500ms,max=10ms) 
.................... void boot(); 
.................... #task(rate=2000ms,max=20ms) 
.................... void process_data(); 
.................... #task(rate=10000ms,max=50ms,enabled=false) 
.................... void post_data(); 
.................... #task(rate=1500ms,max=15ms,enabled=false) 
.................... void post_data_fail(); 
.................... #task(rate=300ms,max=15ms) 
.................... void battery_fail_check(); 
.................... #task(rate=1000ms,max=50ms,enabled=false) 
.................... void gps_rx(); 
.................... //#task(rate=60s,max=30ms) 
.................... //void post_status(); 
....................  
.................... void key_scan(); 
.................... void cmd_exe(); 
.................... //void get_gps();  
.................... //void NMEA_GPRMC();  
.................... void process(); 
.................... float rad2deg(float rad); 
.................... float deg2rad(float deg); 
.................... float distance(float lat1, float lon1, float lat2, float lon2, char unit); 
.................... void conversion(int dat,int add); 
.................... float conversion2(float yyy); 
....................  
.................... void boot() 
.................... {   
....................    fprintf(BUG,"-TASK1-\n\r");     
*
0A0E:  MOV     #0,W1
0A10:  MOV     W1,W0
0A12:  CLR.B   1
0A14:  CALL    3AC
0A18:  INC     W1,W1
0A1A:  BTSC.B  223.1
0A1C:  BRA     A1A
0A1E:  MOV     W0,224
0A20:  MOV     #8,W0
0A22:  CPSGT   W1,W0
0A24:  BRA     A10
....................    ack_log=init_gsm(jl);  
0A26:  MOV.B   A35,W0L
0A28:  MOV.B   W0L,W4L
0A2A:  SE      W4,W3
0A2C:  MOV     W3,B26
0A2E:  CALL    77A
0A32:  MOV.B   W0L,A38
....................    fprintf(BUG,"ACK-%u\n\r",ack_log);     
0A34:  MOV     #0,W1
0A36:  MOV     W1,W0
0A38:  CLR.B   1
0A3A:  CALL    3C2
0A3E:  INC     W1,W1
0A40:  BTSC.B  223.1
0A42:  BRA     A40
0A44:  MOV     W0,224
0A46:  MOV     #3,W0
0A48:  CPSGT   W1,W0
0A4A:  BRA     A36
0A4C:  MOV.B   A38,W0L
0A4E:  CLR.B   1
0A50:  MOV     #0,W4
0A52:  CALL    528
0A56:  BTSC.B  223.1
0A58:  BRA     A56
0A5A:  MOV     #A,W4
0A5C:  MOV     W4,224
0A5E:  BTSC.B  223.1
0A60:  BRA     A5E
0A62:  MOV     #D,W4
0A64:  MOV     W4,224
....................    if(ack_log){jl++;} 
0A66:  CP0.B   A38
0A68:  BRA     Z,A6C
0A6A:  INC.B   0A35
....................    if(jl>=4){ 
0A6C:  MOV.B   A35,W0L
0A6E:  SE      W0,W0
0A70:  CP      W0,#4
0A72:  BRA     LT,A84
....................       init_var=1; 
0A74:  MOV.B   #1,W0L
0A76:  MOV.B   W0L,919
....................       post_var=0; 
0A78:  CLR.B   918
....................       jl=1; 
0A7A:  MOV.B   #1,W0L
0A7C:  MOV.B   W0L,A35
....................       rtos_disable(boot); 
0A7E:  BSET.B  AAE.7
....................       rtos_enable(gps_rx);    
0A80:  BCLR.B  B08.7
....................       rtos_enable(post_data);    
0A82:  BCLR.B  AD2.7
....................       }      
....................    ack_log = 0; 
0A84:  CLR.B   A38
0A86:  MOV     #A0E,W0
0A88:  MOV     W0,AB4
0A8A:  MOV     #0,W0
0A8C:  MOV     W0,AB6
0A8E:  GOTO    3928
0A92:  RETURN  
.................... } 
....................     
.................... void process_data() 
.................... {   
....................     process();      
*
2916:  CALL    24B0
....................     fprintf(BUG,"*");   
291A:  BTSC.B  223.1
291C:  BRA     291A
291E:  MOV     #2A,W4
2920:  MOV     W4,224
2922:  MOV     #2916,W0
2924:  MOV     W0,AC6
2926:  MOV     #0,W0
2928:  MOV     W0,AC8
292A:  GOTO    3928
292E:  RETURN  
.................... } 
....................  
.................... void gps_rx() 
.................... {     
.................... //if (post_var == 0 ){ 
....................       GET_GPS    
2930:  MOV     #0,W1
2932:  MOV     W1,W0
2934:  CLR.B   1
2936:  CALL    3D8
293A:  INC     W1,W1
293C:  BTSC.B  233.1
293E:  BRA     293C
2940:  MOV     W0,234
2942:  MOV     #9,W0
2944:  CPSGT   W1,W0
2946:  BRA     2932
2948:  BTSC.B  233.1
294A:  BRA     2948
294C:  MOV.B   95A,W0L
294E:  MOV.B   W0L,234
2950:  CLR.B   235
....................       timeout_v = 400000; 
2952:  MOV     #1A80,W4
2954:  MOV     W4,A64
2956:  MOV     #6,W4
2958:  MOV     W4,A66
....................       timeout_error=FALSE; 
295A:  BCLR.B  916.0
....................       
....................       while((string3 [0] != 'C' || string3 [j] != 0x0d) && !timeout_error){ 
295C:  MOV     9A2,W4
295E:  XOR.B   #43,W4L
2960:  BRA     NZ,2970
2962:  MOV.B   917,W0L
2964:  SE      W0,W0
2966:  MOV     #9A2,W4
2968:  ADD     W0,W4,W0
296A:  MOV.B   [W0],W4L
296C:  CP.B    W4L,#D
296E:  BRA     Z,299A
2970:  BTSC.B  916.0
2972:  BRA     299A
....................       string3[j] = timed_getc(); 
2974:  MOV.B   917,W0L
2976:  SE      W0,W0
2978:  MOV     #9A2,W4
297A:  ADD     W0,W4,W5
297C:  CALL    5EC
2980:  MOV.B   W0L,[W5]
....................       if(string3 [0] == 'C' && string3 [j] != 0x0d) 
2982:  MOV     9A2,W4
2984:  XOR.B   #43,W4L
2986:  BRA     NZ,2998
2988:  MOV.B   917,W0L
298A:  SE      W0,W0
298C:  MOV     #9A2,W4
298E:  ADD     W0,W4,W0
2990:  MOV.B   [W0],W4L
2992:  CP.B    W4L,#D
2994:  BRA     Z,2998
....................       j++; 
2996:  INC.B   0917
2998:  BRA     295C
....................       } 
....................       if(string3 [0] == 'C' && string3 [j] == 0x0d){ 
299A:  MOV     9A2,W4
299C:  XOR.B   #43,W4L
299E:  BRA     NZ,29FE
29A0:  MOV.B   917,W0L
29A2:  SE      W0,W0
29A4:  MOV     #9A2,W4
29A6:  ADD     W0,W4,W0
29A8:  MOV.B   [W0],W4L
29AA:  CP.B    W4L,#D
29AC:  BRA     NZ,29FE
....................          timeout_error_2 = true; 
29AE:  BSET.B  916.1
....................          fprintf(BUG,"LL-%s,%02u\n\r",string3,j);    
29B0:  BTSC.B  223.1
29B2:  BRA     29B0
29B4:  MOV     #4C,W4
29B6:  MOV     W4,224
29B8:  BTSC.B  223.1
29BA:  BRA     29B8
29BC:  MOV     #4C,W4
29BE:  MOV     W4,224
29C0:  BTSC.B  223.1
29C2:  BRA     29C0
29C4:  MOV     #2D,W4
29C6:  MOV     W4,224
29C8:  MOV     #9A2,W1
29CA:  CP0.B   [W1]
29CC:  BRA     Z,29DC
29CE:  BTSC.B  223.1
29D0:  BRA     29CE
29D2:  MOV.B   [W1+#0],W0L
29D4:  MOV.B   W0L,224
29D6:  CLR.B   225
29D8:  INC     W1,W1
29DA:  BRA     29CA
29DC:  BTSC.B  223.1
29DE:  BRA     29DC
29E0:  MOV     #2C,W4
29E2:  MOV     W4,224
29E4:  MOV.B   917,W0L
29E6:  CLR.B   1
29E8:  MOV     #8002,W4
29EA:  CALL    528
29EE:  BTSC.B  223.1
29F0:  BRA     29EE
29F2:  MOV     #A,W4
29F4:  MOV     W4,224
29F6:  BTSC.B  223.1
29F8:  BRA     29F6
29FA:  MOV     #D,W4
29FC:  MOV     W4,224
....................       }         
.................... //      fprintf(BUG,"LL-%s,%c\n\r",string3,string3[j]);    
.................... //   } 
....................    if(timeout_error){ 
29FE:  BTSS.B  916.0
2A00:  BRA     2A1E
....................    j=0; 
2A02:  CLR.B   917
....................    string3 [0] = 0; 
2A04:  CLR.B   9A2
....................    fprintf(BUG,"TO\r\n"); 
2A06:  MOV     #0,W1
2A08:  MOV     W1,W0
2A0A:  CLR.B   1
2A0C:  CALL    3F2
2A10:  INC     W1,W1
2A12:  BTSC.B  223.1
2A14:  BRA     2A12
2A16:  MOV     W0,224
2A18:  MOV     #3,W0
2A1A:  CPSGT   W1,W0
2A1C:  BRA     2A08
....................    }    
2A1E:  MOV     #2930,W0
2A20:  MOV     W0,B0E
2A22:  MOV     #0,W0
2A24:  MOV     W0,B10
2A26:  GOTO    3928
2A2A:  RETURN  
.................... } 
....................  
....................  
.................... void post_data() 
.................... {      
.................... //   set_timer2(0); 
....................    output_bit(fet1,0); 
*
31B8:  BCLR.B  2CC.6
31BA:  MOV     #FFBF,W4
31BC:  MOV     W4,2C8
....................    if(post_var==1 && init_var==1){    
31BE:  MOV.B   918,W0L
31C0:  SE      W0,W0
31C2:  CP      W0,#1
31C4:  BRA     NZ,32A0
31C6:  MOV.B   919,W0L
31C8:  SE      W0,W0
31CA:  CP      W0,#1
31CC:  BRA     NZ,32A0
....................    ack_log1=cip_start();    
31CE:  CALL    2A2C
31D2:  MOV.B   W0L,A39
.................... //   fprintf(BUG,"PF-%u\n\r",post_fail_count);     
....................    if(ack_log1==81) 
31D4:  MOV.B   A39,W0L
31D6:  SE      W0,W0
31D8:  MOV     #51,W4
31DA:  CP      W4,W0
31DC:  BRA     NZ,3292
....................    {   
....................       cip_send(); 
31DE:  CALL    2B0A
....................       fprintf(BUG,"Stage 1\n\r"); 
31E2:  MOV     #0,W1
31E4:  MOV     W1,W0
31E6:  CLR.B   1
31E8:  CALL    404
31EC:  INC     W1,W1
31EE:  BTSC.B  223.1
31F0:  BRA     31EE
31F2:  MOV     W0,224
31F4:  MOV     #8,W0
31F6:  CPSGT   W1,W0
31F8:  BRA     31E4
....................       rtos_await(ack_1('>')); 
31FA:  MOV.B   #3E,W0L
31FC:  MOV.B   W0L,CAC
31FE:  CALL    2B2E
3202:  MOV.B   W0L,W5L
3204:  MOV     #31FA,W0
3206:  MOV     W0,AD8
3208:  MOV     #0,W0
320A:  MOV     W0,ADA
320C:  BSET.B  AC0.3
320E:  CP0.B   W5L
3210:  BRA     NZ,3216
3212:  GOTO    396E
3216:  BCLR.B  AC0.3
....................       if(timeout_error!=TRUE){ 
3218:  BTSC.B  916.0
321A:  BRA     3272
....................       post(); 
321C:  CALL    3186
....................       fprintf(BUG,"Stage 2\n\r"); 
3220:  MOV     #0,W1
3222:  MOV     W1,W0
3224:  CLR.B   1
3226:  CALL    41A
322A:  INC     W1,W1
322C:  BTSC.B  223.1
322E:  BRA     322C
3230:  MOV     W0,224
3232:  MOV     #8,W0
3234:  CPSGT   W1,W0
3236:  BRA     3222
....................       rtos_await(ack_1('1')); 
3238:  MOV.B   #31,W0L
323A:  MOV.B   W0L,CAC
323C:  CALL    2B2E
3240:  MOV.B   W0L,W5L
3242:  MOV     #3238,W0
3244:  MOV     W0,AD8
3246:  MOV     #0,W0
3248:  MOV     W0,ADA
324A:  BSET.B  AC0.3
324C:  CP0.B   W5L
324E:  BRA     NZ,3254
3250:  GOTO    396E
3254:  BCLR.B  AC0.3
....................       if(timeout_error!=TRUE) 
3256:  BTSC.B  916.0
3258:  BRA     3272
....................       fprintf(BUG,"Stage 3\n\r"); 
325A:  MOV     #0,W1
325C:  MOV     W1,W0
325E:  CLR.B   1
3260:  CALL    430
3264:  INC     W1,W1
3266:  BTSC.B  223.1
3268:  BRA     3266
326A:  MOV     W0,224
326C:  MOV     #8,W0
326E:  CPSGT   W1,W0
3270:  BRA     325C
....................       } 
....................       cip_close();   
3272:  CALL    3194
....................       old_la=new_la; 
3276:  PUSH    A94
3278:  POP     A8C
327A:  PUSH    A96
327C:  POP     A8E
....................       old_ln=new_ln; 
327E:  PUSH    A98
3280:  POP     A90
3282:  PUSH    A9A
3284:  POP     A92
....................       old_hrs=new_hrs;       
3286:  PUSH    A80
3288:  POP     A84
328A:  PUSH    A82
328C:  POP     A86
....................    //   output_low(led2); 
....................   //    output_high(led1); 
....................       post_fail_count=0;       
328E:  CLR     A4C
....................    }else{ 
3290:  BRA     329C
....................  //     output_low(led1); 
....................  //     output_high(led2);  
....................       cip_close(); 
3292:  CALL    3194
....................       rtos_disable(post_data);    
3296:  BSET.B  AD2.7
....................       rtos_disable(gps_rx);    
3298:  BSET.B  B08.7
....................  //     rtos_disable(post_status);    
....................       rtos_enable(post_data_fail);    
329A:  BCLR.B  AE4.7
....................    } 
....................    post_var=0; 
329C:  CLR.B   918
....................    ack_log1=0;       
329E:  CLR.B   A39
....................    }// else {delay_ms(25);} 
32A0:  MOV     #31B8,W0
32A2:  MOV     W0,AD8
32A4:  MOV     #0,W0
32A6:  MOV     W0,ADA
32A8:  GOTO    3928
32AC:  RETURN  
.................... //   rtos_stats(post_data,&stats); 
.................... //   fprintf(BUG,"TASK4:%lu-%lu-%lu-%lu",stats.task_total_ticks,stats.task_min_ticks,stats.task_max_ticks,stats.hns_per_tick);  
....................    //  rtos_stats(post_data); 
.................... } 
....................  
.................... void post_data_fail() 
.................... { 
....................    ack_log1=cip_start();   
32AE:  CALL    2A2C
32B2:  MOV.B   W0L,A39
....................    if(ack_log1==81) 
32B4:  MOV.B   A39,W0L
32B6:  SE      W0,W0
32B8:  MOV     #51,W4
32BA:  CP      W4,W0
32BC:  BRA     NZ,32CC
....................    {   
....................       post_fail_count=0; 
32BE:  CLR     A4C
....................       cip_close(); 
32C0:  CALL    3194
....................       rtos_disable(post_data_fail); 
32C4:  BSET.B  AE4.7
....................       rtos_enable(post_data); 
32C6:  BCLR.B  AD2.7
....................       rtos_enable(gps_rx); 
32C8:  BCLR.B  B08.7
.................... //      rtos_enable(post_status);    
....................       } 
32CA:  BRA     32F0
....................    else{ 
....................       post_fail_count+=1; 
32CC:  MOV     A4C,W4
32CE:  ADD     W4,#1,W0
32D0:  MOV     W0,A4C
....................       cip_close(); 
32D2:  CALL    3194
....................       if(post_fail_count>=5){ 
32D6:  MOV     A4C,W4
32D8:  CP      W4,#5
32DA:  BRA     LT,32F0
....................       output_bit(fet1,1); 
32DC:  BSET.B  2CC.6
32DE:  MOV     #FFBF,W4
32E0:  MOV     W4,2C8
....................       post_fail_count=0; 
32E2:  CLR     A4C
....................       init_var=0; 
32E4:  CLR.B   919
....................       jl=1; 
32E6:  MOV.B   #1,W0L
32E8:  MOV.B   W0L,A35
....................       rtos_disable(post_data_fail); 
32EA:  BSET.B  AE4.7
....................       rtos_enable(boot); 
32EC:  BCLR.B  AAE.7
....................       rtos_enable(post_data); 
32EE:  BCLR.B  AD2.7
.................... //     rtos_enable(post_status);    
....................       } 
....................    } 
32F0:  MOV     #32AE,W0
32F2:  MOV     W0,AEA
32F4:  MOV     #0,W0
32F6:  MOV     W0,AEC
32F8:  GOTO    3928
32FC:  RETURN  
.................... } 
....................  
.................... void battery_fail_check() 
.................... { 
.................... boolean x,x1; 
....................  
....................    x = input(pin_A1); 
32FE:  BSET.B  2C0.1
3300:  BCLR.B  CBC.0
3302:  BTSC.B  2C2.1
3304:  BSET.B  CBC.0
....................    x1 = input(pin_A4); 
3306:  BSET.B  2C0.4
3308:  BCLR.B  CBC.1
330A:  BTSC.B  2C2.4
330C:  BSET.B  CBC.1
....................    p_s = x; 
330E:  BCLR.B  916.4
3310:  BTSC.B  CBC.0
3312:  BSET.B  916.4
....................    if(x ^ last_a){    
3314:  CLR     W0
3316:  BTSC.B  CBC.0
3318:  INC     W0,W0
331A:  MOV.B   W0L,W6L
331C:  CLR     W0
331E:  BTSC.B  916.2
3320:  INC     W0,W0
3322:  XOR.B   W6L,W0L,W0L
3324:  CP0.B   W0L
3326:  BRA     Z,332E
....................    p_status=1;        
3328:  MOV.B   #1,W0L
332A:  MOV.B   W0L,985
....................    }else   
332C:  BRA     3346
....................    if(x1 ^ last_a4){ 
332E:  CLR     W0
3330:  BTSC.B  CBC.1
3332:  INC     W0,W0
3334:  MOV.B   W0L,W6L
3336:  CLR     W0
3338:  BTSC.B  916.3
333A:  INC     W0,W0
333C:  XOR.B   W6L,W0L,W0L
333E:  CP0.B   W0L
3340:  BRA     Z,3346
....................    p_status=2;        
3342:  MOV.B   #2,W0L
3344:  MOV.B   W0L,985
....................    }   
....................    last_a = x; 
3346:  BCLR.B  916.2
3348:  BTSC.B  CBC.0
334A:  BSET.B  916.2
....................    last_a4 = x1; 
334C:  BCLR.B  916.3
334E:  BTSC.B  CBC.1
3350:  BSET.B  916.3
3352:  MOV     #32FE,W0
3354:  MOV     W0,AFC
3356:  MOV     #0,W0
3358:  MOV     W0,AFE
335A:  GOTO    3928
335E:  RETURN  
.................... } 
.................... /* 
.................... void post_status() 
.................... { 
....................    fprintf(BUG,"ST\n\r");  
....................    ack_log1=cip_start();       
....................    if(ack_log1==81) 
....................    {      
....................       dir = 1; 
....................       post();      
....................       dir = 0; 
....................    }else{            
....................       cip_close(); 
....................       rtos_disable(post_data);    
....................       rtos_disable(post_status);    
....................       rtos_enable(post_data_fail);    
....................    } 
.................... }*/ 
....................  
.................... void NMEA_GPRMC() 
*
143E:  MOV     W5,[W15++]
.................... { 
....................    while(ptr!=0) {   
1440:  CP0     A10
1442:  BRA     Z,1496
....................       if(nd == 1){nd++;s_time = strtok(0, term);} 
1444:  MOV.B   91A,W0L
1446:  SE      W0,W0
1448:  CP      W0,#1
144A:  BRA     NZ,145A
144C:  INC.B   091A
144E:  CLR     BC0
1450:  MOV     #A12,W4
1452:  MOV     W4,BC2
1454:  CALL    B2A
1458:  MOV     W0,A18
....................       if(nd == 2){nd++;lat = strtok(0, term);} 
145A:  MOV.B   91A,W0L
145C:  SE      W0,W0
145E:  CP      W0,#2
1460:  BRA     NZ,1470
1462:  INC.B   091A
1464:  CLR     BC0
1466:  MOV     #A12,W4
1468:  MOV     W4,BC2
146A:  CALL    B2A
146E:  MOV     W0,A14
....................       if(nd == 3){nd++;lon = strtok(0, term);} 
1470:  MOV.B   91A,W0L
1472:  SE      W0,W0
1474:  CP      W0,#3
1476:  BRA     NZ,1486
1478:  INC.B   091A
147A:  CLR     BC0
147C:  MOV     #A12,W4
147E:  MOV     W4,BC2
1480:  CALL    B2A
1484:  MOV     W0,A16
....................  //     if(nd == 7){nd++;s_date = strtok(0, term);} 
....................  //     if(nd == 8){nd++;s_date1 = strtok(0, term);} 
....................       ptr = strtok(0, term);   
1486:  CLR     BC0
1488:  MOV     #A12,W4
148A:  MOV     W4,BC2
148C:  CALL    B2A
1490:  MOV     W0,A10
....................       nd++; 
1492:  INC.B   091A
1494:  BRA     1440
....................       } 
....................       f_lat = atof48(lat); 
1496:  PUSH    A14
1498:  POP     BC0
149A:  CLR     BC2
149C:  CALL    F74
14A0:  MOV     W1,A78
14A2:  MOV     W2,A7A
....................       f_lon = atof48(lon);       
14A4:  PUSH    A16
14A6:  POP     BC0
14A8:  CLR     BC2
14AA:  CALL    F74
14AE:  MOV     W1,A7C
14B0:  MOV     W2,A7E
....................       s_date_time = atoi48(s_time); 
14B2:  PUSH    A18
14B4:  POP     BC0
14B6:  CALL    1118
14BA:  MOV     W0,A5A
14BC:  MOV     W1,A5C
14BE:  MOV     W2,A5E
....................       i_date = s_date_time / 1000000; 
14C0:  BCLR.B  43.0
14C2:  MOV     A5A,W0
14C4:  MOV     A5C,W1
14C6:  MOV     A5E,W2
14C8:  MOV     #4240,W3
14CA:  MOV     #F,W4
14CC:  MOV     #0,W5
14CE:  CALL    139C
14D2:  MOV     W0,A56
14D4:  MOV     W1,A58
....................       f_time = s_date_time % 1000000; 
14D6:  BSET.B  43.0
14D8:  MOV     A5A,W0
14DA:  MOV     A5C,W1
14DC:  MOV     A5E,W2
14DE:  MOV     #4240,W3
14E0:  MOV     #F,W4
14E2:  MOV     #0,W5
14E4:  CALL    139C
14E8:  MOV     W0,A52
14EA:  MOV     W1,A54
....................        
.................... //      if(i_date < 500) 
.................... //      i_date = atoi32(s_date1); 
....................       fprintf(BUG,"GC-%s,%s,%s\n\r",s_time,lat,lon);  
14EC:  BTSC.B  223.1
14EE:  BRA     14EC
14F0:  MOV     #47,W4
14F2:  MOV     W4,224
14F4:  BTSC.B  223.1
14F6:  BRA     14F4
14F8:  MOV     #43,W4
14FA:  MOV     W4,224
14FC:  BTSC.B  223.1
14FE:  BRA     14FC
1500:  MOV     #2D,W4
1502:  MOV     W4,224
1504:  MOV     A18,W1
1506:  CP0.B   [W1]
1508:  BRA     Z,1518
150A:  BTSC.B  223.1
150C:  BRA     150A
150E:  MOV.B   [W1+#0],W0L
1510:  MOV.B   W0L,224
1512:  CLR.B   225
1514:  INC     W1,W1
1516:  BRA     1506
1518:  BTSC.B  223.1
151A:  BRA     1518
151C:  MOV     #2C,W4
151E:  MOV     W4,224
1520:  MOV     A14,W1
1522:  CP0.B   [W1]
1524:  BRA     Z,1534
1526:  BTSC.B  223.1
1528:  BRA     1526
152A:  MOV.B   [W1+#0],W0L
152C:  MOV.B   W0L,224
152E:  CLR.B   225
1530:  INC     W1,W1
1532:  BRA     1522
1534:  BTSC.B  223.1
1536:  BRA     1534
1538:  MOV     #2C,W4
153A:  MOV     W4,224
153C:  MOV     A16,W1
153E:  CP0.B   [W1]
1540:  BRA     Z,1550
1542:  BTSC.B  223.1
1544:  BRA     1542
1546:  MOV.B   [W1+#0],W0L
1548:  MOV.B   W0L,224
154A:  CLR.B   225
154C:  INC     W1,W1
154E:  BRA     153E
1550:  BTSC.B  223.1
1552:  BRA     1550
1554:  MOV     #A,W4
1556:  MOV     W4,224
1558:  BTSC.B  223.1
155A:  BRA     1558
155C:  MOV     #D,W4
155E:  MOV     W4,224
1560:  MOV     [--W15],W5
1562:  RETURN  
.................... } 
....................  
.................... void NMEA_GPVTG() 
.................... { 
....................    while(ptr!=0) {   
*
1890:  CP0     A10
1892:  BRA     Z,18BA
....................       if(nd == 4){nd++;speed_k = strtok(0, term);}          
1894:  MOV.B   91A,W0L
1896:  SE      W0,W0
1898:  CP      W0,#4
189A:  BRA     NZ,18AA
189C:  INC.B   091A
189E:  CLR     BC0
18A0:  MOV     #A12,W4
18A2:  MOV     W4,BC2
18A4:  CALL    B2A
18A8:  MOV     W0,A1E
....................       ptr = strtok(0, term);   
18AA:  CLR     BC0
18AC:  MOV     #A12,W4
18AE:  MOV     W4,BC2
18B0:  CALL    B2A
18B4:  MOV     W0,A10
....................       nd++; 
18B6:  INC.B   091A
18B8:  BRA     1890
....................       } 
18BA:  RETURN  
.................... //      fprintf(BUG,"GV-%s\n\r",speed_k);    
.................... } 
....................  
.................... void NMEA_GPGLL() 
.................... { 
....................    while(ptr!=0) {   
*
1790:  CP0     A10
1792:  BRA     Z,17E6
....................       if(nd == 0){nd++;lat = strtok(0, term);} 
1794:  MOV.B   91A,W0L
1796:  SE      W0,W0
1798:  CP0     W0
179A:  BRA     NZ,17AA
179C:  INC.B   091A
179E:  CLR     BC0
17A0:  MOV     #A12,W4
17A2:  MOV     W4,BC2
17A4:  CALL    B2A
17A8:  MOV     W0,A14
....................       if(nd == 2){nd++;lon = strtok(0, term);} 
17AA:  MOV.B   91A,W0L
17AC:  SE      W0,W0
17AE:  CP      W0,#2
17B0:  BRA     NZ,17C0
17B2:  INC.B   091A
17B4:  CLR     BC0
17B6:  MOV     #A12,W4
17B8:  MOV     W4,BC2
17BA:  CALL    B2A
17BE:  MOV     W0,A16
....................       if(nd == 4){nd++;s_time = strtok(0, term);}       
17C0:  MOV.B   91A,W0L
17C2:  SE      W0,W0
17C4:  CP      W0,#4
17C6:  BRA     NZ,17D6
17C8:  INC.B   091A
17CA:  CLR     BC0
17CC:  MOV     #A12,W4
17CE:  MOV     W4,BC2
17D0:  CALL    B2A
17D4:  MOV     W0,A18
....................       ptr = strtok(0, term);   
17D6:  CLR     BC0
17D8:  MOV     #A12,W4
17DA:  MOV     W4,BC2
17DC:  CALL    B2A
17E0:  MOV     W0,A10
....................       nd++; 
17E2:  INC.B   091A
17E4:  BRA     1790
....................       } 
....................       f_lat = atof48(lat); 
17E6:  PUSH    A14
17E8:  POP     BC0
17EA:  CLR     BC2
17EC:  CALL    F74
17F0:  MOV     W1,A78
17F2:  MOV     W2,A7A
....................       f_lon = atof48(lon); 
17F4:  PUSH    A16
17F6:  POP     BC0
17F8:  CLR     BC2
17FA:  CALL    F74
17FE:  MOV     W1,A7C
1800:  MOV     W2,A7E
....................       f_time = atoi32(s_time); 
1802:  PUSH    A18
1804:  POP     BC0
1806:  CALL    15A6
180A:  MOV     W0,A52
180C:  MOV     W1,A54
180E:  RETURN  
.................... //      fprintf(BUG,"GL-%s,%s,%s\n\r",time,lat,lon);     
.................... } 
....................  
.................... void NMEA_GPGGA() 
.................... { 
....................    while(ptr!=0) {   
1810:  CP0     A10
1812:  BRA     Z,1866
....................       if(nd == 0){nd++;s_time = strtok(0, term);} 
1814:  MOV.B   91A,W0L
1816:  SE      W0,W0
1818:  CP0     W0
181A:  BRA     NZ,182A
181C:  INC.B   091A
181E:  CLR     BC0
1820:  MOV     #A12,W4
1822:  MOV     W4,BC2
1824:  CALL    B2A
1828:  MOV     W0,A18
....................       if(nd == 1){nd++;lat = strtok(0, term);} 
182A:  MOV.B   91A,W0L
182C:  SE      W0,W0
182E:  CP      W0,#1
1830:  BRA     NZ,1840
1832:  INC.B   091A
1834:  CLR     BC0
1836:  MOV     #A12,W4
1838:  MOV     W4,BC2
183A:  CALL    B2A
183E:  MOV     W0,A14
....................       if(nd == 3){nd++;lon = strtok(0, term);} 
1840:  MOV.B   91A,W0L
1842:  SE      W0,W0
1844:  CP      W0,#3
1846:  BRA     NZ,1856
1848:  INC.B   091A
184A:  CLR     BC0
184C:  MOV     #A12,W4
184E:  MOV     W4,BC2
1850:  CALL    B2A
1854:  MOV     W0,A16
....................       ptr = strtok(0, term);   
1856:  CLR     BC0
1858:  MOV     #A12,W4
185A:  MOV     W4,BC2
185C:  CALL    B2A
1860:  MOV     W0,A10
....................       nd++; 
1862:  INC.B   091A
1864:  BRA     1810
....................       } 
....................       f_lat = atof48(lat); 
1866:  PUSH    A14
1868:  POP     BC0
186A:  CLR     BC2
186C:  CALL    F74
1870:  MOV     W1,A78
1872:  MOV     W2,A7A
....................       f_lon = atof48(lon); 
1874:  PUSH    A16
1876:  POP     BC0
1878:  CLR     BC2
187A:  CALL    F74
187E:  MOV     W1,A7C
1880:  MOV     W2,A7E
....................       f_time = atoi32(s_time); 
1882:  PUSH    A18
1884:  POP     BC0
1886:  CALL    15A6
188A:  MOV     W0,A52
188C:  MOV     W1,A54
188E:  RETURN  
.................... //      fprintf(BUG,"GA-%s,%s,%s\n\r",s_time,lat,lon);    
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... void main ( ) 
*
34F6:  MOV     #2760,W15
34F8:  MOV     #27FF,W0
34FA:  MOV     W0,20
34FC:  NOP     
34FE:  MOV     #4444,W0
3500:  MOV     W0,A8
3502:  MOV     #4444,W0
3504:  MOV     W0,AC
3506:  BSET.B  81.7
3508:  DISI    #6
350A:  MOV     #742,W1
350C:  MOV     #46,W2
350E:  MOV     #57,W3
3510:  MOV.B   W2L,[W1]
3512:  MOV.B   W3L,[W1]
3514:  BCLR.B  742.6
3516:  MOV     #3F0F,W0
3518:  MOV     W0,6A4
351A:  MOV     #3F05,W0
351C:  MOV     W0,6A6
351E:  MOV     #5,W0
3520:  MOV     W0,6C4
3522:  MOV     #3,W0
3524:  MOV     W0,6CE
3526:  DISI    #6
3528:  MOV     #742,W1
352A:  MOV     #46,W2
352C:  MOV     #57,W3
352E:  MOV.B   W2L,[W1]
3530:  MOV.B   W3L,[W1]
3532:  BSET.B  742.6
3534:  MOV     #3,W4
3536:  MOV     W4,85C
3538:  CLR     914
353A:  MOV     #8000,W4
353C:  MOV     W4,220
353E:  MOV     #400,W4
3540:  MOV     W4,222
3542:  BSET.B  220.3
3544:  MOV     #22,W4
3546:  MOV     W4,228
3548:  MOV     #8000,W4
354A:  MOV     W4,230
354C:  MOV     #400,W4
354E:  MOV     W4,232
3550:  BSET.B  230.3
3552:  MOV     #22,W4
3554:  MOV     W4,238
3556:  BCLR.B  916.0
3558:  BCLR.B  916.1
355A:  BCLR.B  916.2
355C:  BCLR.B  916.3
355E:  BCLR.B  916.4
3560:  CLR.B   917
3562:  CLR.B   918
3564:  CLR.B   919
3566:  CLR.B   91A
3568:  CLR.B   91B
356A:  CLR.B   958
356C:  MOV.B   #22,W0L
356E:  MOV.B   W0L,959
3570:  MOV.B   #D,W0L
3572:  MOV.B   W0L,95A
3574:  MOV.B   #1A,W0L
3576:  MOV.B   W0L,95B
3578:  MOV.B   #A,W0L
357A:  MOV.B   W0L,95C
357C:  CLR     A10
357E:  CLR     A14
3580:  CLR     A16
3582:  CLR     A18
3584:  CLR     A1A
3586:  CLR     A1C
3588:  CLR.B   95D
358A:  CLR.B   985
358C:  CLR.B   A34
358E:  MOV.B   #1,W0L
3590:  MOV.B   W0L,A35
3592:  MOV.B   #1,W0L
3594:  MOV.B   W0L,A36
3596:  MOV.B   #5,W0L
3598:  MOV.B   W0L,A37
359A:  CLR.B   A38
359C:  CLR.B   A39
359E:  CLR     A3C
35A0:  CLR     A3E
35A2:  CLR     A40
35A4:  CLR     A42
35A6:  CLR     A44
35A8:  CLR     A46
35AA:  CLR     A48
35AC:  CLR     A4A
35AE:  CLR     A4C
35B0:  CLR     A4E
35B2:  CLR     A50
35B4:  CLR     A52
35B6:  CLR     A54
35B8:  CLR     A56
35BA:  CLR     A58
35BC:  CLR     A68
35BE:  CLR     A6A
35C0:  CLR     A6C
35C2:  CLR     A6E
35C4:  CLR     A70
35C6:  CLR     A72
35C8:  CLR     A74
35CA:  CLR     A76
35CC:  CLR     A78
35CE:  CLR     A7A
35D0:  CLR     A7C
35D2:  CLR     A7E
35D4:  CLR     A80
35D6:  CLR     A82
35D8:  CLR     A84
35DA:  CLR     A86
35DC:  CLR     A88
35DE:  CLR     A8A
35E0:  CLR     A8C
35E2:  CLR     A8E
35E4:  CLR     A90
35E6:  CLR     A92
35E8:  CLR     A9C
35EA:  CLR     A9E
35EC:  CLR     AA0
35EE:  CLR     AA2
35F0:  CLR     B1A
35F2:  SETM    32C
35F4:  BRA     36C6
35F6:  DATA    C0,08,08
35F8:  DATA    5E,00,00
35FA:  DATA    4B,F0,3F
35FC:  DATA    5C,0A,58
35FE:  DATA    F6,3B,8F
3600:  DATA    00,C0,3C
3602:  DATA    8B,28,AC
3604:  DATA    3C,BE,F6
3606:  DATA    3F,D2,D5
3608:  DATA    44,16,8C
360A:  DATA    15,D7,BF
360C:  DATA    69,00,5A
360E:  DATA    2E,1B,87
3610:  DATA    99,3F,9A
3612:  DATA    5F,AD,4B
3614:  DATA    91,E4,01
3616:  DATA    C0,5D,11
3618:  DATA    2F,92,E4
361A:  DATA    81,FB,3F
361C:  DATA    38,DA,91
361E:  DATA    80,9D,C5
3620:  DATA    E0,BF,6F
3622:  DATA    12,C0,B4
3624:  DATA    C3,09,AB
3626:  DATA    3F,6B,C1
3628:  DATA    03,4E,C1
362A:  DATA    B5,45,BF
362C:  DATA    F7,40,05
362E:  DATA    FF,00,5A
3630:  DATA    EF,3F,F3
3632:  DATA    A3,E2,F7
3634:  DATA    D7,FF,01
3636:  DATA    40,C0,B4
3638:  DATA    FF,05,3C
363A:  DATA    58,FC,3F
363C:  DATA    3B,D3,C0
363E:  DATA    B5,BA,8C
3640:  DATA    E2,3F,39
3642:  DATA    D3,C7,3D
3644:  DATA    41,79,B2
3646:  DATA    3F,87,0D
3648:  DATA    3C,50,D0
364A:  DATA    AF,62,3F
364C:  DATA    30,4B,8D
364E:  DATA    A2,82,AA
3650:  DATA    04,40,09
3652:  DATA    A0,40,4A
3654:  DATA    05,76,03
3656:  DATA    40,EC,9E
3658:  DATA    37,88,A6
365A:  DATA    44,F0,3F
365C:  DATA    8F,12,8D
365E:  DATA    29,9A,5B
3660:  DATA    C7,3F,0E
3662:  DATA    E0,80,7C
3664:  DATA    A1,D8,86
3666:  DATA    3F,29,4B
3668:  DATA    FB,95,C2
366A:  DATA    37,1A,3F
366C:  DATA    C0,3C,09
366E:  DATA    1C,00,80
3670:  DATA    03,09,5E
3672:  DATA    4F,4B,00
3674:  DATA    80,23,09
3676:  DATA    62,43,53
3678:  DATA    54,54,61
367A:  DATA    69,72,74
367C:  DATA    65,6C,67
367E:  DATA    70,72,73
3680:  DATA    63,6F,6D
3682:  DATA    00,4F,4B
3684:  DATA    53,54,41
3686:  DATA    54,45,49
3688:  DATA    50,49,4E
368A:  DATA    49,54,49
368C:  DATA    41,4C,00
368E:  DATA    80,1B,09
3690:  DATA    86,4F,4B
3692:  DATA    43,4F,4E
3694:  DATA    4E,45,43
3696:  DATA    54,4F,4B
3698:  DATA    00,43,47
369A:  DATA    52,45,47
369C:  DATA    30,31,00
369E:  DATA    43,47,52
36A0:  DATA    45,47,30
36A2:  DATA    35,40,6F
36A4:  DATA    00,C0,14
36A6:  DATA    0A,20,00
36A8:  DATA    00,00,00
36AA:  INC     W2,W2
36AC:  CP      W2,#1
36AE:  BRA     NZ,36B8
36B0:  TBLRDL  [W1],W3
36B2:  TBLRDH  [W1++],W4
36B4:  MOV.B   6,W0L
36B6:  RETURN  
36B8:  CP      W2,#2
36BA:  BRA     NZ,36C0
36BC:  MOV.B   7,W0L
36BE:  RETURN  
36C0:  MOV.B   8,W0L
36C2:  CLR     W2
36C4:  RETURN  
36C6:  MOV     #0,W6
36C8:  MOV     #0,W0
36CA:  MOV     W0,32
36CC:  MOV     #35F6,W0
36CE:  MOV     W0,W1
36D0:  CLR     W2
36D2:  CALL    36AA
36D6:  MOV.B   W0L,B
36D8:  CALL    36AA
36DC:  MOV.B   W0L,A
36DE:  CP0     W5
36E0:  BRA     Z,3714
36E2:  BTSS    W5.F
36E4:  BRA     36F4
36E6:  CALL    36AA
36EA:  MOV.B   W0L,D
36EC:  CALL    36AA
36F0:  MOV.B   W0L,C
36F2:  BCLR    W5.F
36F4:  BTSS    W5.E
36F6:  BRA     3708
36F8:  BCLR    W5.E
36FA:  DEC     W5,W5
36FC:  CALL    36AA
3700:  MOV.B   W0L,W7L
3702:  REPEAT  W5
3704:  MOV.B   W7L,[W6++]
3706:  BRA     36D2
3708:  CALL    36AA
370C:  MOV.B   W0L,[W6++]
370E:  DEC     W5,W5
3710:  BRA     NZ,3708
3712:  BRA     36D2
.................... { 
.................... //   setup_oscillator(OSC_INTERNAL);       
.................... //   set_tris_b( 0x00 ); 
....................    set_pullup(true,pin_b6); 
3714:  BSET.B  6B.0
.................... //   set_pullup(false,pin_b15);  
....................    last_a = input_state(pin_A1); 
3716:  BCLR.B  916.2
3718:  BTSC.B  2C2.1
371A:  BSET.B  916.2
....................    last_a4 = input_state(pin_A4); 
371C:  BCLR.B  916.3
371E:  BTSC.B  2C2.4
3720:  BSET.B  916.3
....................     
....................    delay_ms(2000); 
3722:  MOV     #7D0,W0
3724:  CALL    340E
.................... //   enable_interrupts(global); 
.................... //   enable_interrupts(INT_CNI); 
.................... //   enable_interrupts(INTR_CN_PIN | PIN_A1); 
.................... //   enable_interrupts(int_rda); 
.................... //   disable_interrupts(int_rda2); 
....................  //  setup_timer2(TMR_INTERNAL | TMR_DIV_BY_64); 
.................... //   set_timer2(0);  
....................     
.................... //   setup_adc_ports( sAN0 ); 
.................... //   setup_adc(ADC_CLOCK_INTERNAL ); 
.................... //   set_adc_channel( 0 ); 
....................  
.................... //   port_b_pullups(true);     
....................    output_high(fet1); 
3728:  MOV     #FFBF,W4
372A:  MOV     W4,2C8
372C:  BSET.B  2CC.6
....................    delay_ms(1000); 
372E:  MOV     #3E8,W0
3730:  CALL    340E
....................    output_low(fet1); 
3734:  MOV     #FFBF,W4
3736:  MOV     W4,2C8
3738:  BCLR.B  2CC.6
.................... //   output_low(led1);output_high(led2); 
.................... //   output_low(led4);output_high(led3); 
....................   // fprintf(GPS"Hello World"); 
....................    if(init_gsm_1(1))init_gsm_1(2);  
373A:  MOV     #1,W4
373C:  MOV     W4,B1C
373E:  CALL    341E
3742:  CP0     W0
3744:  BRA     Z,374E
3746:  MOV     #2,W4
3748:  MOV     W4,B1C
374A:  CALL    341E
....................    switch ( restart_cause() ) { 
374E:  MOV     #C0D3,W0
3750:  AND     740,W0
3752:  MOV     W0,W1
3754:  MOV     #FFFF,W0
3756:  INC     W0,W0
3758:  LSR     W1,W1
375A:  BSET.B  3.7
375C:  BTSS.B  42.0
375E:  BRA     3756
3760:  MOV     W0,W1
3762:  MOV     #3D20,W0
3764:  AND     740
3766:  MOV     W1,W0
3768:  XOR     #0,W0
376A:  BRA     Z,3786
376C:  XOR     #1,W0
376E:  BRA     Z,37B0
3770:  XOR     #5,W0
3772:  BRA     Z,37CA
3774:  XOR     #2,W0
3776:  BRA     Z,37E4
3778:  XOR     #1,W0
377A:  BRA     Z,37FE
377C:  XOR     #9,W0
377E:  BRA     Z,3818
3780:  XOR     #1,W0
3782:  BRA     Z,3832
3784:  BRA     384C
....................    case RESTART_POWER_UP:delay_ms(10000);  
3786:  MOV     #2710,W0
3788:  CALL    340E
.................... //                        if(init_gsm_1(1))init_gsm_1(2);                         
....................                         fprintf(GSM,"ATE0%c",enter); 
378C:  MOV     #0,W1
378E:  MOV     W1,W0
3790:  CLR.B   1
3792:  CALL    21C
3796:  INC     W1,W1
3798:  BTSC.B  233.1
379A:  BRA     3798
379C:  MOV     W0,234
379E:  MOV     #3,W0
37A0:  CPSGT   W1,W0
37A2:  BRA     378E
37A4:  BTSC.B  233.1
37A6:  BRA     37A4
37A8:  MOV.B   95A,W0L
37AA:  MOV.B   W0L,234
37AC:  CLR.B   235
.................... //                        init_gsm_1(2); 
.................... //                        delay_ms(10); 
.................... //                        fprintf(GSM,"AT+CGREG=1%c",enter); 
.................... //                        delay_ms(10); 
.................... //                        reset_cpu(); 
....................                         break;  
37AE:  BRA     384C
....................    case RESTART_BROWNOUT:fprintf(BUG,"BOOT 1\n\r"); 
37B0:  MOV     #0,W1
37B2:  MOV     W1,W0
37B4:  CLR.B   1
37B6:  CALL    446
37BA:  INC     W1,W1
37BC:  BTSC.B  223.1
37BE:  BRA     37BC
37C0:  MOV     W0,224
37C2:  MOV     #7,W0
37C4:  CPSGT   W1,W0
37C6:  BRA     37B2
....................                         break;  
37C8:  BRA     384C
....................    case RESTART_WATCHDOG:fprintf(BUG,"BOOT 2\n\r");   
37CA:  MOV     #0,W1
37CC:  MOV     W1,W0
37CE:  CLR.B   1
37D0:  CALL    45C
37D4:  INC     W1,W1
37D6:  BTSC.B  223.1
37D8:  BRA     37D6
37DA:  MOV     W0,224
37DC:  MOV     #7,W0
37DE:  CPSGT   W1,W0
37E0:  BRA     37CC
....................                         break;  
37E2:  BRA     384C
....................    case RESTART_SOFTWARE:fprintf(BUG,"BOOT 3\n\r"); 
37E4:  MOV     #0,W1
37E6:  MOV     W1,W0
37E8:  CLR.B   1
37EA:  CALL    472
37EE:  INC     W1,W1
37F0:  BTSC.B  223.1
37F2:  BRA     37F0
37F4:  MOV     W0,224
37F6:  MOV     #7,W0
37F8:  CPSGT   W1,W0
37FA:  BRA     37E6
....................                         break;  
37FC:  BRA     384C
....................    case RESTART_MCLR :  fprintf(BUG,"BOOT 4\n\r");                         
37FE:  MOV     #0,W1
3800:  MOV     W1,W0
3802:  CLR.B   1
3804:  CALL    488
3808:  INC     W1,W1
380A:  BTSC.B  223.1
380C:  BRA     380A
380E:  MOV     W0,224
3810:  MOV     #7,W0
3812:  CPSGT   W1,W0
3814:  BRA     3800
....................                         break;    
3816:  BRA     384C
....................    case RESTART_ILLEGAL_OP:fprintf(BUG,"BOOT 5\n\r"); 
3818:  MOV     #0,W1
381A:  MOV     W1,W0
381C:  CLR.B   1
381E:  CALL    49E
3822:  INC     W1,W1
3824:  BTSC.B  223.1
3826:  BRA     3824
3828:  MOV     W0,224
382A:  MOV     #7,W0
382C:  CPSGT   W1,W0
382E:  BRA     381A
....................                         break; 
3830:  BRA     384C
....................    case RESTART_TRAP_CONFLICT:fprintf(BUG,"BOOT 6\n\r"); 
3832:  MOV     #0,W1
3834:  MOV     W1,W0
3836:  CLR.B   1
3838:  CALL    4B4
383C:  INC     W1,W1
383E:  BTSC.B  223.1
3840:  BRA     383E
3842:  MOV     W0,224
3844:  MOV     #7,W0
3846:  CPSGT   W1,W0
3848:  BRA     3834
....................                         break; 
384A:  BRA     384C
....................    }   
.................... //   output_low(led1); 
.................... //   output_low(led2); 
.................... //   output_low(led3); 
.................... //   output_low(led4);       
....................       
....................    rtos_run(); 
384C:  CLR     AAE
384E:  MOV     #5,W4
3850:  MOV     W4,AB0
3852:  CLR     AB2
3854:  CLR     AB8
3856:  CLR     ABA
3858:  SETM    ABC
385A:  CLR     ABE
385C:  MOV     #A0E,W0
385E:  MOV     W0,AB4
3860:  MOV     #0,W0
3862:  MOV     W0,AB6
3864:  CLR     AC0
3866:  MOV     #14,W4
3868:  MOV     W4,AC2
386A:  CLR     AC4
386C:  CLR     ACA
386E:  CLR     ACC
3870:  SETM    ACE
3872:  CLR     AD0
3874:  MOV     #2916,W0
3876:  MOV     W0,AC6
3878:  MOV     #0,W0
387A:  MOV     W0,AC8
387C:  MOV     #80,W4
387E:  MOV     W4,AD2
3880:  MOV     #64,W4
3882:  MOV     W4,AD4
3884:  CLR     AD6
3886:  CLR     ADC
3888:  CLR     ADE
388A:  SETM    AE0
388C:  CLR     AE2
388E:  MOV     #31B8,W0
3890:  MOV     W0,AD8
3892:  MOV     #0,W0
3894:  MOV     W0,ADA
3896:  MOV     #80,W4
3898:  MOV     W4,AE4
389A:  MOV     #F,W4
389C:  MOV     W4,AE6
389E:  CLR     AE8
38A0:  CLR     AEE
38A2:  CLR     AF0
38A4:  SETM    AF2
38A6:  CLR     AF4
38A8:  MOV     #32AE,W0
38AA:  MOV     W0,AEA
38AC:  MOV     #0,W0
38AE:  MOV     W0,AEC
38B0:  CLR     AF6
38B2:  MOV     #3,W4
38B4:  MOV     W4,AF8
38B6:  CLR     AFA
38B8:  CLR     B00
38BA:  CLR     B02
38BC:  SETM    B04
38BE:  CLR     B06
38C0:  MOV     #32FE,W0
38C2:  MOV     W0,AFC
38C4:  MOV     #0,W0
38C6:  MOV     W0,AFE
38C8:  MOV     #80,W4
38CA:  MOV     W4,B08
38CC:  MOV     #A,W4
38CE:  MOV     W4,B0A
38D0:  CLR     B0C
38D2:  CLR     B12
38D4:  CLR     B14
38D6:  SETM    B16
38D8:  CLR     B18
38DA:  MOV     #2930,W0
38DC:  MOV     W0,B0E
38DE:  MOV     #0,W0
38E0:  MOV     W0,B10
38E2:  CLR     85A
38E4:  CLR     104
38E6:  MOV     #30D4,W4
38E8:  MOV     W4,102
38EA:  MOV     #A020,W4
38EC:  MOV     W4,104
38EE:  CLR     100
38F0:  BCLR.B  84.3
38F2:  MOV     #1,W4
38F4:  MOV     W4,85C
38F6:  MOV     85A,W1
38F8:  SL      W1,#1,W1
38FA:  MOV     W1,W0
38FC:  CALL    4CA
3900:  MOV.B   W0L,W2L
3902:  ADD.B   W1L,#1,W0L
3904:  CALL    4CA
3908:  MOV.B   W0L,5
390A:  MOV     W2,W6
390C:  MOV     [W6++],W1
390E:  MOV     [W6],W2
3910:  INC     [++W6],[W6]
3912:  MOV     [W6],W0
3914:  SUB     W0,W2,W0
3916:  BTSS.B  42.1
3918:  BRA     396E
391A:  CLR     [W6++]
391C:  BTSC    W1.7
391E:  BRA     396E
3920:  MOV     [W6++],[W15++]
3922:  MOV     #0,W0
3924:  MOV     W0,[W15++]
3926:  RETURN  
3928:  MOV     85A,W1
392A:  SL      W1,#1,W1
392C:  MOV     W1,W0
392E:  CALL    4CA
3932:  MOV.B   W0L,W2L
3934:  ADD.B   W1L,#1,W0L
3936:  CALL    4CA
393A:  MOV.B   W0L,5
393C:  MOV     W2,W6
393E:  BCLR    [W6].4
3940:  BTSC.B  84.3
3942:  BSET    [W6].4
3944:  MOV     100,W0
3946:  BTSS.B  84.3
3948:  BRA     394E
394A:  MOV     #30D4,W1
394C:  ADD     W0,W1,W0
394E:  MOV     W0,W1
3950:  ADD     W6,#A,W6
3952:  MOV     [W6],W4
3954:  ADD     W4,W0,[W6++]
3956:  BTSC.B  42.0
3958:  INC     [W6],[W6]
395A:  INC2    W6,W6
395C:  MOV     [W6],W0
395E:  SUB     W0,W1,W0
3960:  BTSC.B  42.0
3962:  MOV     W1,[W6]
3964:  INC2    W6,W6
3966:  MOV     [W6],W0
3968:  SUB     W0,W1,W0
396A:  BTSS.B  42.0
396C:  MOV     W1,[W6]
396E:  INC     085A
3970:  MOV     #6,W0
3972:  SUB     85A,W0
3974:  BTSS.B  42.1
3976:  BRA     38F6
3978:  CLR     85A
397A:  MOV     100,W0
397C:  BTSC.B  84.3
397E:  BRA     38EE
3980:  BRA     397A
3982:  SETM    85A
.................... }    
.................... //------------------------------------------------------------------------------ 
3984:  BRA     3984
....................  
.................... void process() 
*
24B0:  MOV     W5,[W15++]
24B2:  MOV     W6,[W15++]
.................... {   
.................... p_hrs = 5; 
24B4:  MOV.B   #5,W0L
24B6:  MOV.B   W0L,A37
.................... int8 clng=0,ip=0; 
.................... char sstring[110]={},nmea[8]="CGNSINF",nmea1[7]="$GPGLL",nmea2[7]="$GPGGA",nmea3[7]="$GPVTG"; 
24B8:  CLR.B   B30
24BA:  CLR.B   B31
24BC:  CLR     B32
24BE:  CLR     B34
24C0:  CLR     B36
24C2:  CLR     B38
24C4:  CLR     B3A
24C6:  CLR     B3C
24C8:  CLR     B3E
24CA:  CLR     B40
24CC:  CLR     B42
24CE:  CLR     B44
24D0:  CLR     B46
24D2:  CLR     B48
24D4:  CLR     B4A
24D6:  CLR     B4C
24D8:  CLR     B4E
24DA:  CLR     B50
24DC:  CLR     B52
24DE:  CLR     B54
24E0:  CLR     B56
24E2:  CLR     B58
24E4:  CLR     B5A
24E6:  CLR     B5C
24E8:  CLR     B5E
24EA:  CLR     B60
24EC:  CLR     B62
24EE:  CLR     B64
24F0:  CLR     B66
24F2:  CLR     B68
24F4:  CLR     B6A
24F6:  CLR     B6C
24F8:  CLR     B6E
24FA:  CLR     B70
24FC:  CLR     B72
24FE:  CLR     B74
2500:  CLR     B76
2502:  CLR     B78
2504:  CLR     B7A
2506:  CLR     B7C
2508:  CLR     B7E
250A:  CLR     B80
250C:  CLR     B82
250E:  CLR     B84
2510:  CLR     B86
2512:  CLR     B88
2514:  CLR     B8A
2516:  CLR     B8C
2518:  CLR     B8E
251A:  CLR     B90
251C:  CLR     B92
251E:  CLR     B94
2520:  CLR     B96
2522:  CLR     B98
2524:  CLR     B9A
2526:  CLR     B9C
2528:  CLR     B9E
252A:  MOV     #4743,W4
252C:  MOV     W4,BA0
252E:  MOV     #534E,W4
2530:  MOV     W4,BA2
2532:  MOV     #4E49,W4
2534:  MOV     W4,BA4
2536:  MOV     #46,W4
2538:  MOV     W4,BA6
253A:  MOV     #4724,W4
253C:  MOV     W4,BA8
253E:  MOV     #4750,W4
2540:  MOV     W4,BAA
2542:  MOV     #4C4C,W4
2544:  MOV     W4,BAC
2546:  CLR.B   BAE
2548:  MOV     #4724,W4
254A:  MOV     W4,BB0
254C:  MOV     #4750,W4
254E:  MOV     W4,BB2
2550:  MOV     #4147,W4
2552:  MOV     W4,BB4
2554:  CLR.B   BB6
2556:  MOV     #4724,W4
2558:  MOV     W4,BB8
255A:  MOV     #5650,W4
255C:  MOV     W4,BBA
255E:  MOV     #4754,W4
2560:  MOV     W4,BBC
2562:  CLR.B   BBE
....................    nd=0; 
2564:  CLR.B   91A
.................... //   strcpy(string3,"$GPRMC,073004.00,A,1120.62884,N,07743.04195,E,0.009,,070815,,,A*7E");    
....................    strcpy(term,","); 
2566:  MOV     #0,W2
2568:  MOV     #A12,W1
256A:  MOV     W2,W0
256C:  CALL    4E2
2570:  MOV.B   W0L,[W1++]
2572:  INC     W2,W2
2574:  CP0.B   W0L
2576:  BTSS.B  42.1
2578:  BRA     256A
....................    if(timeout_error_2 == true){  
257A:  BTSS.B  916.1
257C:  BRA     268A
....................    clng = strlen(string3); 
257E:  MOV     #9A2,W4
2580:  MOV     W4,BCA
2582:  CALL    A94
2586:  MOV.B   W0L,B30
....................    strcpy(sstring,string3);   
2588:  MOV     #B32,W1
258A:  MOV     #9A2,W2
258C:  MOV.B   [W2++],[W1]
258E:  CP0.B   [W1++]
2590:  BTSS.B  42.1
2592:  BRA     258C
....................    fprintf(BUG,"L-%s>%u\n\r",sstring,clng);                                          //&& string3[strlen (string3)] == 0x0a 
2594:  BTSC.B  223.1
2596:  BRA     2594
2598:  MOV     #4C,W4
259A:  MOV     W4,224
259C:  BTSC.B  223.1
259E:  BRA     259C
25A0:  MOV     #2D,W4
25A2:  MOV     W4,224
25A4:  MOV     #B32,W1
25A6:  CP0.B   [W1]
25A8:  BRA     Z,25B8
25AA:  BTSC.B  223.1
25AC:  BRA     25AA
25AE:  MOV.B   [W1+#0],W0L
25B0:  MOV.B   W0L,224
25B2:  CLR.B   225
25B4:  INC     W1,W1
25B6:  BRA     25A6
25B8:  BTSC.B  223.1
25BA:  BRA     25B8
25BC:  MOV     #3E,W4
25BE:  MOV     W4,224
25C0:  MOV.B   B30,W0L
25C2:  CLR.B   1
25C4:  MOV     #0,W4
25C6:  CALL    528
25CA:  BTSC.B  223.1
25CC:  BRA     25CA
25CE:  MOV     #A,W4
25D0:  MOV     W4,224
25D2:  BTSC.B  223.1
25D4:  BRA     25D2
25D6:  MOV     #D,W4
25D8:  MOV     W4,224
....................    ptr = strtok(sstring, term); 
25DA:  MOV     #B32,W4
25DC:  MOV     W4,BC0
25DE:  MOV     #A12,W4
25E0:  MOV     W4,BC2
25E2:  CALL    B2A
25E6:  MOV     W0,A10
....................    if(!strncmp(sstring,nmea,7) && clng >= 62)NMEA_GPRMC();    
25E8:  MOV     #B32,W4
25EA:  MOV     W4,CB8
25EC:  MOV     #BA0,W4
25EE:  MOV     W4,CBA
25F0:  MOV     #7,W4
25F2:  MOV     W4,CBC
25F4:  CALL    628
25F8:  CP0.B   W0L
25FA:  BRA     NZ,260A
25FC:  MOV.B   B30,W0L
25FE:  SE      W0,W0
2600:  MOV     #3E,W4
2602:  CP      W4,W0
2604:  BRA     GT,260A
2606:  CALL    143E
....................    if(!strncmp(sstring,nmea1,6) && clng >= 30)NMEA_GPGLL();    
260A:  MOV     #B32,W4
260C:  MOV     W4,CB8
260E:  MOV     #BA8,W4
2610:  MOV     W4,CBA
2612:  MOV     #6,W4
2614:  MOV     W4,CBC
2616:  CALL    628
261A:  CP0.B   W0L
261C:  BRA     NZ,262A
261E:  MOV.B   B30,W0L
2620:  SE      W0,W0
2622:  CP      W0,#1E
2624:  BRA     LT,262A
2626:  CALL    1790
....................    if(!strncmp(sstring,nmea2,6) && clng >= 50)NMEA_GPGGA();    
262A:  MOV     #B32,W4
262C:  MOV     W4,CB8
262E:  MOV     #BB0,W4
2630:  MOV     W4,CBA
2632:  MOV     #6,W4
2634:  MOV     W4,CBC
2636:  CALL    628
263A:  CP0.B   W0L
263C:  BRA     NZ,264C
263E:  MOV.B   B30,W0L
2640:  SE      W0,W0
2642:  MOV     #32,W4
2644:  CP      W4,W0
2646:  BRA     GT,264C
2648:  CALL    1810
....................    if(!strncmp(sstring,nmea3,6) && clng >= 30)NMEA_GPVTG();  
264C:  MOV     #B32,W4
264E:  MOV     W4,CB8
2650:  MOV     #BB8,W4
2652:  MOV     W4,CBA
2654:  MOV     #6,W4
2656:  MOV     W4,CBC
2658:  CALL    628
265C:  CP0.B   W0L
265E:  BRA     NZ,266C
2660:  MOV.B   B30,W0L
2662:  SE      W0,W0
2664:  CP      W0,#1E
2666:  BRA     LT,266C
2668:  CALL    1890
....................  
.................... for(ip=0;ip<=j;ip++)  
266C:  CLR.B   B31
266E:  MOV.B   B31,W0L
2670:  MOV     916,W4
2672:  LSR     W4,#8,W4
2674:  CP.B    W4L,W0L
2676:  BRA     LT,2686
....................       string3[ip]=0; 
2678:  MOV.B   B31,W0L
267A:  SE      W0,W0
267C:  MOV     #9A2,W4
267E:  ADD     W0,W4,W5
2680:  CLR.B   [W5]
2682:  INC.B   0B31
2684:  BRA     266E
....................       j=0;       
2686:  CLR.B   917
....................       timeout_error_2 = false;      
2688:  BCLR.B  916.1
....................    } 
.................... //   new_la = conversion2(f_lat); 
.................... //   new_ln = conversion2(f_lon); 
....................    new_la = f_lat; 
268A:  PUSH    A78
268C:  POP     A94
268E:  PUSH    A7A
2690:  POP     A96
....................    new_ln = f_lon; 
2692:  PUSH    A7C
2694:  POP     A98
2696:  PUSH    A7E
2698:  POP     A9A
.................... //   fprintf(BUG,"GC-%lu,%lu,%2.5f,%2.5f\n\r",f_time,i_date,new_la,new_ln);     
.................... //---------------- TIME  ------------------------------------------------------             
....................   new_sec = f_time % 100;             
269A:  BSET.B  43.0
269C:  MOV     A52,W0
269E:  MOV     A54,W1
26A0:  MOV     #64,W2
26A2:  MOV     #0,W3
26A4:  CALL    18BC
26A8:  MOV     W0,A42
....................        v1 = f_time / 10000;             
26AA:  BCLR.B  43.0
26AC:  MOV     A52,W0
26AE:  MOV     A54,W1
26B0:  MOV     #2710,W2
26B2:  MOV     #0,W3
26B4:  CALL    18BC
26B8:  MOV     W0,A4A
....................   new_min = (f_time % 10000) / 100; 
26BA:  BSET.B  43.0
26BC:  MOV     A52,W0
26BE:  MOV     A54,W1
26C0:  MOV     #2710,W2
26C2:  MOV     #0,W3
26C4:  CALL    18BC
26C8:  MOV     W0,W5
26CA:  MOV     W1,W6
26CC:  BCLR.B  43.0
26CE:  MOV     W5,W0
26D0:  MOV     W6,W1
26D2:  MOV     #64,W2
26D4:  MOV     #0,W3
26D6:  CALL    18BC
26DA:  MOV     W0,A40
....................        v4 = (new_min * 60) + new_sec; 
26DC:  MOV     A40,W4
26DE:  MOV     #3C,W3
26E0:  MUL.SS  W4,W3,W0
26E2:  MOV     W0,W5
26E4:  MOV     W5,W0
26E6:  ADD     A42,W0
26E8:  CALL    193A
26EC:  MOV     W0,A70
26EE:  MOV     W1,A72
....................   new_hrs = v1 + (  v4 / 3600 ); 
26F0:  MOV     A70,W0
26F2:  MOV     A72,W1
26F4:  MOV     #0,W2
26F6:  MOV     #4561,W3
26F8:  CALL    1984
26FC:  MOV     W0,W5
26FE:  MOV     W1,W6
2700:  MOV     A4A,W0
2702:  CALL    193A
2706:  BCLR.B  43.0
2708:  MOV     W5,W2
270A:  MOV     W6,W3
270C:  CALL    1A4E
2710:  MOV     W0,A80
2712:  MOV     W1,A82
....................   fprintf(BUG,"%02u:%02u:%02u\n\r",v1,new_min,new_sec);       
2714:  MOV     A4A,W0
2716:  MOV     #8002,W4
2718:  CALL    528
271C:  BTSC.B  223.1
271E:  BRA     271C
2720:  MOV     #3A,W4
2722:  MOV     W4,224
2724:  MOV     A40,W0
2726:  MOV     #8002,W4
2728:  CALL    528
272C:  BTSC.B  223.1
272E:  BRA     272C
2730:  MOV     #3A,W4
2732:  MOV     W4,224
2734:  MOV     A42,W0
2736:  MOV     #8002,W4
2738:  CALL    528
273C:  BTSC.B  223.1
273E:  BRA     273C
2740:  MOV     #A,W4
2742:  MOV     W4,224
2744:  BTSC.B  223.1
2746:  BRA     2744
2748:  MOV     #D,W4
274A:  MOV     W4,224
.................... //  fprintf(BUG,"GT-%f\n\r",v4);  
.................... //-----------------DATE -------------------------------------------------------             
....................   date = i_date % 100;             
274C:  BSET.B  43.0
274E:  MOV     A56,W0
2750:  MOV     A58,W1
2752:  MOV     #64,W2
2754:  MOV     #0,W3
2756:  CALL    18BC
275A:  MOV     W0,A44
....................   year = i_date / 10000;             
275C:  BCLR.B  43.0
275E:  MOV     A56,W0
2760:  MOV     A58,W1
2762:  MOV     #2710,W2
2764:  MOV     #0,W3
2766:  CALL    18BC
276A:  MOV     W0,A48
....................   month = (i_date % 10000) / 100;        
276C:  BSET.B  43.0
276E:  MOV     A56,W0
2770:  MOV     A58,W1
2772:  MOV     #2710,W2
2774:  MOV     #0,W3
2776:  CALL    18BC
277A:  MOV     W0,W5
277C:  MOV     W1,W6
277E:  BCLR.B  43.0
2780:  MOV     W5,W0
2782:  MOV     W6,W1
2784:  MOV     #64,W2
2786:  MOV     #0,W3
2788:  CALL    18BC
278C:  MOV     W0,A46
....................   fprintf(BUG,"%04lu/%02u/%02u\n\r",year,month,date);  
278E:  MOV     A48,W0
2790:  MOV     #8004,W4
2792:  CALL    528
2796:  BTSC.B  223.1
2798:  BRA     2796
279A:  MOV     #2F,W4
279C:  MOV     W4,224
279E:  MOV     A46,W0
27A0:  MOV     #8002,W4
27A2:  CALL    528
27A6:  BTSC.B  223.1
27A8:  BRA     27A6
27AA:  MOV     #2F,W4
27AC:  MOV     W4,224
27AE:  MOV     A44,W0
27B0:  MOV     #8002,W4
27B2:  CALL    528
27B6:  BTSC.B  223.1
27B8:  BRA     27B6
27BA:  MOV     #A,W4
27BC:  MOV     W4,224
27BE:  BTSC.B  223.1
27C0:  BRA     27BE
27C2:  MOV     #D,W4
27C4:  MOV     W4,224
.................... //----------------INIT DATE/TME------------------------------------------------             
....................   if(old_hrs == null) 
27C6:  MOV     A84,W0
27C8:  MOV     A86,W1
27CA:  MOV     #0,W2
27CC:  MOV     #0,W3
27CE:  CALL    1BF8
27D2:  BRA     NZ,27DC
....................   old_hrs = new_hrs; 
27D4:  PUSH    A80
27D6:  POP     A84
27D8:  PUSH    A82
27DA:  POP     A86
....................   if(old_la == null && old_ln == null){ 
27DC:  MOV     A8C,W0
27DE:  MOV     A8E,W1
27E0:  MOV     #0,W2
27E2:  MOV     #0,W3
27E4:  CALL    1BF8
27E8:  BRA     NZ,2808
27EA:  MOV     A90,W0
27EC:  MOV     A92,W1
27EE:  MOV     #0,W2
27F0:  MOV     #0,W3
27F2:  CALL    1BF8
27F6:  BRA     NZ,2808
....................     old_la = new_la; 
27F8:  PUSH    A94
27FA:  POP     A8C
27FC:  PUSH    A96
27FE:  POP     A8E
....................     old_ln = new_ln; 
2800:  PUSH    A98
2802:  POP     A90
2804:  PUSH    A9A
2806:  POP     A92
....................     }         
.................... //------------------------------------------------------------------------------      
....................     if(abs(old_la - new_la) >= 0.0001 || abs(old_ln-new_ln) >= 0.0001){ 
2808:  BSET.B  43.0
280A:  MOV     A8C,W0
280C:  MOV     A8E,W1
280E:  MOV     A94,W2
2810:  MOV     A96,W3
2812:  CALL    1A4E
2816:  MOV     W0,W5
2818:  MOV     W1,W6
281A:  MOV     W5,W0
281C:  MOV     W6,W1
281E:  BCLR    W1.F
2820:  MOV     W0,W5
2822:  MOV     W1,W6
2824:  MOV     #B717,W0
2826:  MOV     #38D1,W1
2828:  MOV     W5,W2
282A:  MOV     W6,W3
282C:  CALL    1BF8
2830:  BRA     C,2860
2832:  BRA     Z,2860
2834:  BSET.B  43.0
2836:  MOV     A90,W0
2838:  MOV     A92,W1
283A:  MOV     A98,W2
283C:  MOV     A9A,W3
283E:  CALL    1A4E
2842:  MOV     W0,W5
2844:  MOV     W1,W6
2846:  MOV     W5,W0
2848:  MOV     W6,W1
284A:  BCLR    W1.F
284C:  MOV     W0,W5
284E:  MOV     W1,W6
2850:  MOV     #B717,W0
2852:  MOV     #38D1,W1
2854:  MOV     W5,W2
2856:  MOV     W6,W3
2858:  CALL    1BF8
285C:  BRA     C,2860
285E:  BRA     NZ,28F0
....................     post_var = 1;  
2860:  MOV.B   #1,W0L
2862:  MOV.B   W0L,918
....................     dir = 1; 
2864:  MOV.B   #1,W0L
2866:  MOV.B   W0L,A34
....................     distt = distance(old_la,old_ln,new_la,new_ln,'K');   
2868:  MOV.B   #4B,W0L
286A:  MOV.B   W0L,BD0
286C:  PUSH    A8C
286E:  POP     BC0
2870:  PUSH    A8E
2872:  POP     BC2
2874:  PUSH    A90
2876:  POP     BC4
2878:  PUSH    A92
287A:  POP     BC6
287C:  PUSH    A94
287E:  POP     BC8
2880:  PUSH    A96
2882:  POP     BCA
2884:  PUSH    A98
2886:  POP     BCC
2888:  PUSH    A9A
288A:  POP     BCE
288C:  CALL    22FE
2890:  MOV     W0,A9C
2892:  MOV     W1,A9E
....................     if(old_hrs > new_hrs){                
2894:  MOV     A80,W0
2896:  MOV     A82,W1
2898:  MOV     A84,W2
289A:  MOV     A86,W3
289C:  CALL    1BF8
28A0:  BRA     NC,28D0
....................        speed = distt / (24 - (old_hrs - new_hrs));     
28A2:  BSET.B  43.0
28A4:  MOV     A84,W0
28A6:  MOV     A86,W1
28A8:  MOV     A80,W2
28AA:  MOV     A82,W3
28AC:  CALL    1A4E
28B0:  BSET.B  43.0
28B2:  MOV     W0,W2
28B4:  MOV     W1,W3
28B6:  MOV     #0,W0
28B8:  MOV     #41C0,W1
28BA:  CALL    1A4E
28BE:  MOV     W0,W2
28C0:  MOV     W1,W3
28C2:  MOV     A9C,W0
28C4:  MOV     A9E,W1
28C6:  CALL    1984
28CA:  MOV     W0,AA0
28CC:  MOV     W1,AA2
....................           }else { 
28CE:  BRA     28EE
....................            speed = distt / (new_hrs - old_hrs); 
28D0:  BSET.B  43.0
28D2:  MOV     A80,W0
28D4:  MOV     A82,W1
28D6:  MOV     A84,W2
28D8:  MOV     A86,W3
28DA:  CALL    1A4E
28DE:  MOV     W0,W2
28E0:  MOV     W1,W3
28E2:  MOV     A9C,W0
28E4:  MOV     A9E,W1
28E6:  CALL    1984
28EA:  MOV     W0,AA0
28EC:  MOV     W1,AA2
....................           }     
.................... //    fprintf(BUG,"Di-%0.5f,%0.5f\n\r",abs(old_la-new_la),old_ln-new_ln); 
....................     }else if(old_hrs != new_hrs && year >= 2016){ 
28EE:  BRA     2910
28F0:  MOV     A84,W0
28F2:  MOV     A86,W1
28F4:  MOV     A80,W2
28F6:  MOV     A82,W3
28F8:  CALL    1BF8
28FC:  BRA     Z,2910
28FE:  MOV     A48,W4
2900:  MOV     #7E0,W3
2902:  CP      W3,W4
2904:  BRA     GT,2910
....................     post_var = 1;  
2906:  MOV.B   #1,W0L
2908:  MOV.B   W0L,918
....................     dir = 0; 
290A:  CLR.B   A34
....................     speed = 0; 
290C:  CLR     AA0
290E:  CLR     AA2
....................     } 
2910:  MOV     [--W15],W6
2912:  MOV     [--W15],W5
2914:  RETURN  
....................  
....................  /*            
....................    p_min = min + 30; 
....................    if(p_min>59){ 
....................       p_min -= 60 ; 
....................       p_hrs+=1; 
....................       } 
....................       p_hrs += hrss; 
....................       if(p_hrs>23){ 
....................       p_hrs -=24; 
....................       } 
....................       if(p_hrs > 12){am_pm="PM"; 
....................          p_hrs -= 12; 
....................       }else am_pm="AM"; 
....................       if(p_hrs == 0) 
....................       p_hrs = 12; 
....................       */ 
.................... } 
....................  
.................... float distance(float lat1, float lon1, float lat2, float lon2, char unit) { 
*
22FE:  MOV     W5,[W15++]
2300:  MOV     #C,W5
2302:  REPEAT  #4
2304:  MOV     [W5++],[W15++]
2306:  MOV     #18E3,W4
2308:  MOV     W4,BE6
....................  
....................     float dlat,dlon,a,c,d; 
....................     int16 R = 6371; 
....................  
....................    dlat = (lat2-lat1) * 0.0174532925;  
230A:  BSET.B  43.0
230C:  MOV     BC8,W0
230E:  MOV     BCA,W1
2310:  MOV     BC0,W2
2312:  MOV     BC2,W3
2314:  CALL    1A4E
2318:  MOV     W0,W5
231A:  MOV     W1,W6
231C:  MOV     W5,W0
231E:  MOV     W6,W1
2320:  MOV     #FA35,W2
2322:  MOV     #3C8E,W3
2324:  CALL    1C60
2328:  MOV     W0,BD2
232A:  MOV     W1,BD4
....................    dlon = (lon2-lon1) * 0.0174532925; 
232C:  BSET.B  43.0
232E:  MOV     BCC,W0
2330:  MOV     BCE,W1
2332:  MOV     BC4,W2
2334:  MOV     BC6,W3
2336:  CALL    1A4E
233A:  MOV     W0,W5
233C:  MOV     W1,W6
233E:  MOV     W5,W0
2340:  MOV     W6,W1
2342:  MOV     #FA35,W2
2344:  MOV     #3C8E,W3
2346:  CALL    1C60
234A:  MOV     W0,BD6
234C:  MOV     W1,BD8
....................  
....................     a = sin(dlat/2) * sin(dlat/2) + 
....................             cos((lat1 * 0.0174532925)) * cos((lat2 * 0.0174532925)) * 
....................             sin(dlon/2) * sin(dlon/2); 
234E:  MOV     BD2,W0
2350:  MOV     BD4,W1
2352:  MOV     #0,W2
2354:  MOV     #4000,W3
2356:  CALL    1984
235A:  MOV     W0,W5
235C:  MOV     W1,W6
235E:  MOV     W5,BF4
2360:  MOV     W6,BF6
2362:  CALL    1EFE
2366:  MOV     W0,W5
2368:  MOV     W1,W6
236A:  MOV     BD2,W0
236C:  MOV     BD4,W1
236E:  MOV     #0,W2
2370:  MOV     #4000,W3
2372:  CALL    1984
2376:  MOV     W0,W7
2378:  MOV     W1,W8
237A:  MOV     W7,BF4
237C:  MOV     W8,BF6
237E:  CALL    1EFE
2382:  MOV     W0,W2
2384:  MOV     W1,W3
2386:  MOV     W5,W0
2388:  MOV     W6,W1
238A:  CALL    1C60
238E:  MOV     W0,W5
2390:  MOV     W1,W6
2392:  MOV     BC0,W0
2394:  MOV     BC2,W1
2396:  MOV     #FA35,W2
2398:  MOV     #3C8E,W3
239A:  CALL    1C60
239E:  MOV     W0,W7
23A0:  MOV     W1,W8
23A2:  MOV     W7,BFC
23A4:  MOV     W8,BFE
23A6:  CALL    1D8A
23AA:  MOV     W0,W7
23AC:  MOV     W1,W8
23AE:  MOV     BC8,W0
23B0:  MOV     BCA,W1
23B2:  MOV     #FA35,W2
23B4:  MOV     #3C8E,W3
23B6:  CALL    1C60
23BA:  MOV     W0,W9
23BC:  MOV     W1,W10
23BE:  MOV     W9,BFC
23C0:  MOV     W10,BFE
23C2:  CALL    1D8A
23C6:  MOV     W0,W2
23C8:  MOV     W1,W3
23CA:  MOV     W7,W0
23CC:  MOV     W8,W1
23CE:  CALL    1C60
23D2:  MOV     W0,W7
23D4:  MOV     W1,W8
23D6:  MOV     BD6,W0
23D8:  MOV     BD8,W1
23DA:  MOV     #0,W2
23DC:  MOV     #4000,W3
23DE:  CALL    1984
23E2:  MOV     W0,W9
23E4:  MOV     W1,W10
23E6:  MOV     W9,BF4
23E8:  MOV     W10,BF6
23EA:  CALL    1EFE
23EE:  MOV     W0,W2
23F0:  MOV     W1,W3
23F2:  MOV     W7,W0
23F4:  MOV     W8,W1
23F6:  CALL    1C60
23FA:  MOV     W0,W7
23FC:  MOV     W1,W8
23FE:  MOV     BD6,W0
2400:  MOV     BD8,W1
2402:  MOV     #0,W2
2404:  MOV     #4000,W3
2406:  CALL    1984
240A:  MOV     W0,W9
240C:  MOV     W1,W10
240E:  MOV     W9,BF4
2410:  MOV     W10,BF6
2412:  CALL    1EFE
2416:  MOV     W0,W2
2418:  MOV     W1,W3
241A:  MOV     W7,W0
241C:  MOV     W8,W1
241E:  CALL    1C60
2422:  BCLR.B  43.0
2424:  MOV     W0,W2
2426:  MOV     W1,W3
2428:  MOV     W5,W0
242A:  MOV     W6,W1
242C:  CALL    1A4E
2430:  MOV     W0,BDA
2432:  MOV     W1,BDC
....................              
....................     c = 2 * atan2(sqrt(a),sqrt(1-a)); 
2434:  PUSH    BDA
2436:  POP     BF0
2438:  PUSH    BDC
243A:  POP     BF2
243C:  CALL    1F24
2440:  MOV     W0,W5
2442:  MOV     W1,W6
2444:  BSET.B  43.0
2446:  MOV     #0,W0
2448:  MOV     #3F80,W1
244A:  MOV     BDA,W2
244C:  MOV     BDC,W3
244E:  CALL    1A4E
2452:  MOV     W0,W7
2454:  MOV     W1,W8
2456:  MOV     W7,BF0
2458:  MOV     W8,BF2
245A:  CALL    1F24
245E:  MOV     W0,W7
2460:  MOV     W1,W8
2462:  MOV     W5,BF0
2464:  MOV     W6,BF2
2466:  MOV     W7,BF4
2468:  MOV     W8,BF6
246A:  CALL    21BC
246E:  MOV     W0,W2
2470:  MOV     W1,W3
2472:  MOV     #0,W0
2474:  MOV     #4000,W1
2476:  CALL    1C60
247A:  MOV     W0,BDE
247C:  MOV     W1,BE0
....................     d = R * c;     
247E:  MOV     BE6,W0
2480:  CALL    193A
2484:  MOV     BDE,W2
2486:  MOV     BE0,W3
2488:  CALL    1C60
248C:  MOV     W0,BE2
248E:  MOV     W1,BE4
....................     d = d - 0.00144974;  
2490:  BSET.B  43.0
2492:  MOV     BE2,W0
2494:  MOV     BE4,W1
2496:  MOV     #534,W2
2498:  MOV     #3ABE,W3
249A:  CALL    1A4E
249E:  MOV     W0,BE2
24A0:  MOV     W1,BE4
....................     return d; 
24A2:  MOV     BE2,W0
24A4:  MOV     BE4,W1
24A6:  MOV     #14,W5
24A8:  REPEAT  #4
24AA:  MOV     [--W15],[W5--]
24AC:  MOV     [--W15],W5
24AE:  RETURN  
.................... } 
....................  
.................... float conversion2(float yyy) 
.................... { 
....................    v4 = modf(yyy,&v5); 
....................    v1 = v5; 
....................    yy = v1 /100; 
....................    v5 = v1 % 100; 
.................... //   v4 = v2; 
.................... //   v2 = v4 / 10000; 
....................    v4 = (v5 + v4) / 60;        
....................    v6 = yy; 
.................... //   v6 = v6 + v5;   
....................    return v6 + v4;   
.................... } 
....................  
.................... /* 
.................... void conversion(int dat,int add) 
.................... { 
....................    int i,j,k; 
....................    i=dat/100; 
....................    j=dat%100; 
....................    k=j%10; 
....................    j=j/10; 
....................    i=i|0x30; 
....................    j=j|0x30; 
....................    k=k|0x30; 
....................    lcd_com(add); 
....................   // lcd_data(i); 
....................    lcd_data(j); 
....................    lcd_data(k); 
.................... }*/ 
....................  
.................... #INT_RDA 
.................... void rda_isp() 
*
3360:  PUSH    42
3362:  PUSH    36
3364:  PUSH    32
3366:  MOV     W0,[W15++]
3368:  MOV     #2,W0
336A:  REPEAT  #C
336C:  MOV     [W0++],[W15++]
.................... { 
....................    unsigned char vv3;   
....................     
....................  //  if(string3[j] != 0x0d)string3[j] = getch(GPS);    
....................    if(string3[j] == 0x0d){ 
336E:  MOV.B   917,W0L
3370:  SE      W0,W0
3372:  MOV     #9A2,W4
3374:  ADD     W0,W4,W0
3376:  MOV.B   [W0],W4L
3378:  CP.B    W4L,#D
337A:  BRA     NZ,3394
....................       if(string3[0] != 'C') 
337C:  MOV     9A2,W4
337E:  XOR.B   #43,W4L
3380:  BRA     Z,3390
....................       { 
....................       string3[j]=0; 
3382:  MOV.B   917,W0L
3384:  SE      W0,W0
3386:  MOV     #9A2,W4
3388:  ADD     W0,W4,W5
338A:  CLR.B   [W5]
....................       j=0; 
338C:  CLR.B   917
....................       } 
338E:  BRA     3392
....................       else{ 
.................... //      vv3 = getch(GPS); 
....................       timeout_error_2 = true; 
3390:  BSET.B  916.1
....................       } 
....................    } 
3392:  BRA     33AA
....................    else 
....................    if(string3[0] == 'C' && string3[j] != 0x0d){ 
3394:  MOV     9A2,W4
3396:  XOR.B   #43,W4L
3398:  BRA     NZ,33AA
339A:  MOV.B   917,W0L
339C:  SE      W0,W0
339E:  MOV     #9A2,W4
33A0:  ADD     W0,W4,W0
33A2:  MOV.B   [W0],W4L
33A4:  CP.B    W4L,#D
33A6:  BRA     Z,33AA
....................    j++; 
33A8:  INC.B   0917
....................    } 
.................... } 
....................  
33AA:  BCLR.B  85.3
33AC:  MOV     #1A,W0
33AE:  REPEAT  #C
33B0:  MOV     [--W15],[W0--]
33B2:  MOV     [--W15],W0
33B4:  POP     32
33B6:  POP     36
33B8:  POP     42
33BA:  RETFIE  
.................... #INT_ADDRERR  
.................... void default_isr() { 
33BC:  PUSH    42
33BE:  PUSH    36
33C0:  PUSH    32
33C2:  MOV     W0,[W15++]
33C4:  MOV     #2,W0
33C6:  REPEAT  #C
33C8:  MOV     [W0++],[W15++]
....................  
.................... //   printf("Unexplained interrupt\r\n"); 
.................... } 
....................  
33CA:  BCLR.B  80.3
33CC:  MOV     #1A,W0
33CE:  REPEAT  #C
33D0:  MOV     [--W15],[W0--]
33D2:  MOV     [--W15],W0
33D4:  POP     32
33D6:  POP     36
33D8:  POP     42
33DA:  RETFIE  
.................... #INT_CNI 
.................... void cni_isr() { 
33DC:  PUSH    42
33DE:  PUSH    36
33E0:  PUSH    32
33E2:  MOV     W0,[W15++]
33E4:  MOV     #2,W0
33E6:  REPEAT  #C
33E8:  MOV     [W0++],[W15++]
....................  
....................    if((!input(pin_A1)) && (last_a)){ 
33EA:  BSET.B  2C0.1
33EC:  BTSC.B  2C2.1
33EE:  BRA     33FC
33F0:  BTSS.B  916.2
33F2:  BRA     33FC
....................    p_status=1;  
33F4:  MOV.B   #1,W0L
33F6:  MOV.B   W0L,985
....................    last_a = 0; 
33F8:  BCLR.B  916.2
....................    disable_interrupts(INT_CNI); 
33FA:  BCLR.B  96.3
....................    }   
.................... //   clear_interrupt(INT_CNI); 
.................... //   clear_interrupt(INTR_CN_PIN | PIN_A1); 
33FC:  BCLR.B  86.3
33FE:  MOV     #1A,W0
3400:  REPEAT  #C
3402:  MOV     [--W15],[W0--]
3404:  MOV     [--W15],W0
3406:  POP     32
3408:  POP     36
340A:  POP     42
340C:  RETFIE  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1L: 377F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 DEBUG NOWRT NOPROTECT NOJTAG
          H: 0000  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
